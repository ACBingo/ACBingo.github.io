<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[c++初始化列表]]></title>
      <url>http://blog.acbingo.cn/2016/08/07/c++%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>今天做题的时候，一直在想c++初始化列表到底有啥用？<br><a id="more"></a></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>要搞明白初始化列表的作用，得先搞明白构造函数的两个执行阶段.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> p;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base():p(<span class="number">10</span>)&#123;&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>构造函数在被调用后，要执行两个阶段:</p>
<ol>
<li>初始化阶段</li>
<li>计算阶段</li>
</ol>
<p>初始化阶段是先于计算阶段的。</p>
<p>在初始化阶段，该构造函数所用到的成员会在初始化阶段进行初始化，如果有初始化列表，就执行初始化列表的赋值操作，如果没有或是有的成员没有在初始化列表中，对于类类型那么就会调用该类的无参构造函数进行初始化。</p>
<p>第二阶段才会执行构造函数函数体内的代码。</p>
<p>借用两个例子来说明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Test1</div><div class="line">&#123;</div><div class="line">    Test1() <span class="comment">// 无参构造函数</span></div><div class="line">    &#123; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct Test1"</span> &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Test1(<span class="keyword">const</span> Test1&amp; t1) <span class="comment">// 拷贝构造函数</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor for Test1"</span> &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">        <span class="keyword">this</span>-&gt;a = t1.a ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Test1&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Test1&amp; t1) <span class="comment">// 赋值运算符</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment for Test1"</span> &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">        <span class="keyword">this</span>-&gt;a = t1.a ;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> a ;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Test2</div><div class="line">&#123;</div><div class="line">    Test1 test1 ;</div><div class="line">    Test2(Test1 &amp;t1)</div><div class="line">    &#123;</div><div class="line">        test1 = t1 ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>调用代码为</p>
<pre><code>Test1 t1 ;
Test2 t2(t1) ;
</code></pre><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Construct Test1</div><div class="line">Construct Test1</div><div class="line">assignment for Test1</div></pre></td></tr></table></figure></p>
<p>显然，输出第一行是由mian中的Test1 t1 产生的。</p>
<p>输出的第二行则是在Test2的构造函数进入函数体前，对成员变量test1进行初始化产生的，而第三行则是由于test1 = t1 调用赋值语句产生的。</p>
<p>那么我们换成初始化列表看看会发生什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Test2</div><div class="line">&#123;</div><div class="line">    Test1 test1 ;</div><div class="line">    Test2(Test1 &amp;t1):test1(t1)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Construct Test1</div><div class="line">Copy Constructor for Test1</div></pre></td></tr></table></figure></p>
<p>不再调用Test1的默认构造函数！而且只用利用复制构造函数对test1进行构造并初始化</p>
<p>没错，其实对于test1来说，调用默认构造函数是多余的。这对于数据密集型的类来说，是非常高效的。</p>
<p><strong>那么，你估计也想到了，要是Test1没有默认的构造函数呢？</strong><br>没错！要是没有默认的构造函数，而且没有初始化列表的话，是编译不过的。<br>所以，对于没有默认构造函数的类来说，就必须使用初始化列表进行初始化。</p>
<p>同样的，对于成员变量是<strong>常量或引用类型</strong>，若是你没有在声明的时候一同给出初始化的声明，那么就只能在初始化列表中进行初始化。</p>
<p><strong>最后一个需要注意的一点是</strong>：类成员是按照他们在类中出现（声明）的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一步一步学习红黑树-2]]></title>
      <url>http://blog.acbingo.cn/2016/08/05/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%BA%A2%E9%BB%91%E6%A0%91-2/</url>
      <content type="html"><![CDATA[<p>一步一步来，这篇文章熟悉下平衡二叉树。<br><a id="more"></a></p>
<h1 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>父节点的左子树和右子树的高度之差不能大于1，也就是说不能高过1层，否则该树就失衡了，此时就要旋转节点，在编码时，我们可以记录当前节点的高度，比如空节点是-1，叶子节点是0，非叶子节点的height往根节点递增，比如在下图中我们认为树的高度为h=2。</p>
<p><img src="http://pic002.cnblogs.com/images/2012/214741/2012072218340434.png" alt=""></p>
<p>平衡因子：结点左子树的深度-结点右子树的深度。（0、1、-1）</p>
<p><img src="http://img.blog.csdn.net/20130506224404606" alt=""></p>
<p>转换为平衡二叉树之后的二叉树为：</p>
<p><img src="http://img.blog.csdn.net/20130506224544947" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVLTreeNode&#123;</div><div class="line">    Type key;                    <span class="comment">// 关键字(键值)</span></div><div class="line">    <span class="keyword">int</span> height;</div><div class="line">    <span class="keyword">struct</span> AVLTreeNode *left;    <span class="comment">// 左孩子</span></div><div class="line">    <span class="keyword">struct</span> AVLTreeNode *right;    <span class="comment">// 右孩子</span></div><div class="line">&#125;Node, *AVLTree;</div></pre></td></tr></table></figure>
<p>AVL树的节点包括的几个组成对象:\<br>(01) key – 是关键字，是用来对AVL树的节点进行排序的。<br>(02) left – 是左孩子。<br>(03) right – 是右孩子。<br>(04) height – 是高度。</p>
<h2 id="平衡保持"><a href="#平衡保持" class="headerlink" title="平衡保持"></a>平衡保持</h2><p>很显然，平衡二叉树旨在“平衡”二字，其平衡是如何保持的呢？换句话说，二叉查找树是如何转换为平衡二叉树的呢？就像上面两张图片，到底如何转换的呢？基本的思想就是:</p>
<p>当二叉查找树中插入一个结点时，首先检查是否因为插入而破坏了平衡。若破坏了则找出其中的最小不平衡二叉树，在保持二叉查找树特性的情况下，调整最小不平衡子树中结点之间的关系，以达到平衡。</p>
<p>最小不平衡二叉树指距离插入结点最近且以平衡因子的绝对值大于1的结点作为根的子树。</p>
<p>那么最小不平衡二叉树结点的关系到底是如何进行调整的呢？分为四种情况讨论。</p>
<ol>
<li>左左情况（左子树的左边节点）</li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2012/214741/2012072218213884.png" alt=""></p>
<p>我们看到，在向树中追加“节点1”的时候，根据定义我们知道这样会导致了“节点3”失衡，满足“左左情况“，可以这样想，把这棵树比作齿轮，我们在“节点5”处把齿轮往下拉一个位置，也就变成了后面这样“平衡”的形式，如果用动画解释就最好理解了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * LL：左左对应的情况(左单旋转)。</div><div class="line"> *</div><div class="line"> * 返回值：旋转后的根节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> Node* <span class="title">left_left_rotation</span><span class="params">(AVLTree k2)</span></span></div><div class="line">&#123;</div><div class="line">    AVLTree k1;</div><div class="line"></div><div class="line">    k1 = k2-&gt;left;</div><div class="line">    k2-&gt;left = k1-&gt;right;</div><div class="line">    k1-&gt;right = k2;</div><div class="line"></div><div class="line">    k2-&gt;height = MAX( HEIGHT(k2-&gt;left), HEIGHT(k2-&gt;right)) + <span class="number">1</span>;</div><div class="line">    k1-&gt;height = MAX( HEIGHT(k1-&gt;left), k2-&gt;height) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> k1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>右右情况（右子树的右边节点）</li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2012/214741/2012072218444051.png" alt=""></p>
<p>同样，”节点5“满足”右右情况“，其实我们也看到，这两种情况是一种镜像，当然操作方式也大同小异，我们在”节点1“的地方将树往下拉一位，最后也就形成了我们希望的平衡效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * RR：右右对应的情况(右单旋转)。</div><div class="line"> *</div><div class="line"> * 返回值：旋转后的根节点</div><div class="line"> */</div><div class="line">static Node* right_right_rotation(AVLTree k1)</div><div class="line">&#123;</div><div class="line">    AVLTree k2;</div><div class="line"></div><div class="line">    k2 = k1-&gt;right;</div><div class="line">    k1-&gt;right = k2-&gt;left;</div><div class="line">    k2-&gt;left = k1;</div><div class="line"></div><div class="line">    k1-&gt;height = MAX( HEIGHT(k1-&gt;left), HEIGHT(k1-&gt;right)) + 1;</div><div class="line">    k2-&gt;height = MAX( HEIGHT(k2-&gt;right), k1-&gt;height) + 1;</div><div class="line"></div><div class="line">    return k2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>左右情况（左子树的右边节点）</li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2012/214741/2012072219144367.png" alt=""></p>
<p>从图中我们可以看到，当我们插入”节点3“时，“节点5”处失衡，注意，找到”失衡点“是非常重要的，当面对”左右情况“时，我们将失衡点的左子树进行”右右情况旋转”，然后进行”左左情况旋转“，经过这样两次的旋转就OK了，很有意思，对吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * LR：左右对应的情况(左双旋转)。</div><div class="line"> *</div><div class="line"> * 返回值：旋转后的根节点</div><div class="line"> */</div><div class="line">static Node* left_right_rotation(AVLTree k3)</div><div class="line">&#123;</div><div class="line">    k3-&gt;left = right_right_rotation(k3-&gt;left);</div><div class="line"></div><div class="line">    return left_left_rotation(k3);</div><div class="line">&#125;</div><div class="line">复制代码</div></pre></td></tr></table></figure>
<ol>
<li>右左情况(右子树的左边节点）</li>
</ol>
<p><img src="http://pic002.cnblogs.com/images/2012/214741/2012072219540371.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * RL：右左对应的情况(右双旋转)。</div><div class="line"> *</div><div class="line"> * 返回值：旋转后的根节点</div><div class="line"> */</div><div class="line">static Node* right_left_rotation(AVLTree k1)</div><div class="line">&#123;</div><div class="line">    k1-&gt;right = left_left_rotation(k1-&gt;right);</div><div class="line"></div><div class="line">    return right_right_rotation(k1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>如果我们理解了上面的这几种旋转，那么添加方法简直是轻而易举，出现了哪一种情况调用哪一种方法而已。</p>
<h3 id="节点的创建"><a href="#节点的创建" class="headerlink" title="节点的创建"></a>节点的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 创建AVL树结点。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     key 是键值。</div><div class="line"> *     left 是左孩子。</div><div class="line"> *     right 是右孩子。</div><div class="line"> */</div><div class="line">static Node* avltree_create_node(Type key, Node *left, Node* right)</div><div class="line">&#123;</div><div class="line">    Node* p;</div><div class="line"></div><div class="line">    if ((p = (Node *)malloc(sizeof(Node))) == NULL)</div><div class="line">        return NULL;</div><div class="line">    p-&gt;key = key;</div><div class="line">    p-&gt;height = 0;</div><div class="line">    p-&gt;left = left;</div><div class="line">    p-&gt;right = right;</div><div class="line"></div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#define HEIGHT(p)    ( (p==NULL) ? 0 : (((Node *)(p))-&gt;height) )</div><div class="line"></div><div class="line">/*</div><div class="line"> * 获取AVL树的高度</div><div class="line"> */</div><div class="line">int avltree_height(AVLTree tree)</div><div class="line">&#123;</div><div class="line">    return HEIGHT(tree);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于高度，有的文章中将”空二叉树的高度定义为-1”，而本文采用维基百科上的定义：树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * 将结点插入到AVL树中，并返回根节点</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     tree AVL树的根结点</div><div class="line"> *     key 插入的结点的键值</div><div class="line"> * 返回值：</div><div class="line"> *     根节点</div><div class="line"> */</div><div class="line">Node* avltree_insert(AVLTree tree, Type key)</div><div class="line">&#123;</div><div class="line">    if (tree == NULL) </div><div class="line">    &#123;</div><div class="line">        // 新建节点</div><div class="line">        tree = avltree_create_node(key, NULL, NULL);</div><div class="line">        if (tree==NULL)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;ERROR: create avltree node failed!\n&quot;);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (key &lt; tree-&gt;key) // 应该将key插入到&quot;tree的左子树&quot;的情况</div><div class="line">    &#123;</div><div class="line">        tree-&gt;left = avltree_insert(tree-&gt;left, key);</div><div class="line">        // 插入节点后，若AVL树失去平衡，则进行相应的调节。</div><div class="line">        if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) == 2)</div><div class="line">        &#123;</div><div class="line">            if (key &lt; tree-&gt;left-&gt;key)</div><div class="line">                tree = left_left_rotation(tree);</div><div class="line">            else</div><div class="line">                tree = left_right_rotation(tree);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (key &gt; tree-&gt;key) // 应该将key插入到&quot;tree的右子树&quot;的情况</div><div class="line">    &#123;</div><div class="line">        tree-&gt;right = avltree_insert(tree-&gt;right, key);</div><div class="line">        // 插入节点后，若AVL树失去平衡，则进行相应的调节。</div><div class="line">        if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) == 2)</div><div class="line">        &#123;</div><div class="line">            if (key &gt; tree-&gt;right-&gt;key)</div><div class="line">                tree = right_right_rotation(tree);</div><div class="line">            else</div><div class="line">                tree = right_left_rotation(tree);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else //key == tree-&gt;key)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;添加失败：不允许添加相同的节点！\n&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tree-&gt;height = MAX( HEIGHT(tree-&gt;left), HEIGHT(tree-&gt;right)) + 1;</div><div class="line"></div><div class="line">    return tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除方法跟添加方法也类似，当删除一个结点的时候，可能会引起祖先结点的失衡，所以在每次”结点“回退的时候计算结点高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">复制代码</div><div class="line">/* </div><div class="line"> * 删除结点(z)，返回根节点</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     ptree AVL树的根结点</div><div class="line"> *     z 待删除的结点</div><div class="line"> * 返回值：</div><div class="line"> *     根节点</div><div class="line"> */</div><div class="line">static Node* delete_node(AVLTree tree, Node *z)</div><div class="line">&#123;</div><div class="line">    // 根为空 或者 没有要删除的节点，直接返回NULL。</div><div class="line">    if (tree==NULL || z==NULL)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    if (z-&gt;key &lt; tree-&gt;key)        // 待删除的节点在&quot;tree的左子树&quot;中</div><div class="line">    &#123;</div><div class="line">        tree-&gt;left = delete_node(tree-&gt;left, z);</div><div class="line">        // 删除节点后，若AVL树失去平衡，则进行相应的调节。</div><div class="line">        if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) == 2)</div><div class="line">        &#123;</div><div class="line">            Node *r =  tree-&gt;right;</div><div class="line">            if (HEIGHT(r-&gt;left) &gt; HEIGHT(r-&gt;right))</div><div class="line">                tree = right_left_rotation(tree);</div><div class="line">            else</div><div class="line">                tree = right_right_rotation(tree);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (z-&gt;key &gt; tree-&gt;key)// 待删除的节点在&quot;tree的右子树&quot;中</div><div class="line">    &#123;</div><div class="line">        tree-&gt;right = delete_node(tree-&gt;right, z);</div><div class="line">        // 删除节点后，若AVL树失去平衡，则进行相应的调节。</div><div class="line">        if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) == 2)</div><div class="line">        &#123;</div><div class="line">            Node *l =  tree-&gt;left;</div><div class="line">            if (HEIGHT(l-&gt;right) &gt; HEIGHT(l-&gt;left))</div><div class="line">                tree = left_right_rotation(tree);</div><div class="line">            else</div><div class="line">                tree = left_left_rotation(tree);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else    // tree是对应要删除的节点。</div><div class="line">    &#123;</div><div class="line">        // tree的左右孩子都非空</div><div class="line">        if ((tree-&gt;left) &amp;&amp; (tree-&gt;right))</div><div class="line">        &#123;</div><div class="line">            if (HEIGHT(tree-&gt;left) &gt; HEIGHT(tree-&gt;right))</div><div class="line">            &#123;</div><div class="line">                // 如果tree的左子树比右子树高；</div><div class="line">                // 则(01)找出tree的左子树中的最大节点</div><div class="line">                //   (02)将该最大节点的值赋值给tree。</div><div class="line">                //   (03)删除该最大节点。</div><div class="line">                // 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；</div><div class="line">                // 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。</div><div class="line">                Node *max = avltree_maximum(tree-&gt;left);</div><div class="line">                tree-&gt;key = max-&gt;key;</div><div class="line">                tree-&gt;left = delete_node(tree-&gt;left, max);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                // 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</div><div class="line">                // 则(01)找出tree的右子树中的最小节点</div><div class="line">                //   (02)将该最小节点的值赋值给tree。</div><div class="line">                //   (03)删除该最小节点。</div><div class="line">                // 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；</div><div class="line">                // 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。</div><div class="line">                Node *min = avltree_maximum(tree-&gt;right);</div><div class="line">                tree-&gt;key = min-&gt;key;</div><div class="line">                tree-&gt;right = delete_node(tree-&gt;right, min);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            Node *tmp = tree;</div><div class="line">            tree = tree-&gt;left ? tree-&gt;left : tree-&gt;right;</div><div class="line">            free(tmp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return tree;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* </div><div class="line"> * 删除结点(key是节点值)，返回根节点</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     tree AVL树的根结点</div><div class="line"> *     key 待删除的结点的键值</div><div class="line"> * 返回值：</div><div class="line"> *     根节点</div><div class="line"> */</div><div class="line">Node* avltree_delete(AVLTree tree, Type key)</div><div class="line">&#123;</div><div class="line">    Node *z; </div><div class="line"></div><div class="line">    if ((z = avltree_search(tree, key)) != NULL)</div><div class="line">        tree = delete_node(tree, z);</div><div class="line">    return tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/skywang12345/p/3576969.html" target="_blank" rel="external">AVL树(一)之 图文解析 和 C语言的实现</a></p>
<p>ps.上面有AVL的c语言API实现</p>
<p><a href="http://www.cnblogs.com/huangxincheng/archive/2012/07/22/2603956.html" target="_blank" rel="external">6天通吃树结构—— 第二天 平衡二叉树</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一步一步学习红黑树-1]]></title>
      <url>http://blog.acbingo.cn/2016/08/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>之前只是听说过红黑树，但是从来没用过，也没接触过。今天好好系统的学习一番红黑树。</p>
<p>这篇文章先熟悉下二叉树搜索树的构建，查找，添加与删除节点的操作。<br><a id="more"></a></p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="二叉搜索树的查找算法"><a href="#二叉搜索树的查找算法" class="headerlink" title="二叉搜索树的查找算法"></a>二叉搜索树的查找算法</h2><p>在二叉搜索树b中查找x的过程为：</p>
<ol>
<li>若b是空树，则搜索失败，否则：</li>
<li>若x等于b的根节点的数据域之值，则查找成功；否则：</li>
<li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li>
<li>查找右子树。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Status SearchBST(BiTree T, KeyType key, BiTree f, BiTree &amp;p)&#123;</div><div class="line">  //在根指针T所指二元查找樹中递归地查找其關键字等於key的數據元素，若查找成功，</div><div class="line">  //則指针p指向該數據元素節點，并返回TRUE，否則指针指向查找路徑上訪問的最後</div><div class="line">  //一個節點并返回FALSE，指针f指向T的雙親，其初始调用值為NULL</div><div class="line">  if(!T) &#123; //查找不成功</div><div class="line">    p=f;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  else if (key == T-&gt;data.key) &#123; //查找成功</div><div class="line">    p=T;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  else if (key &lt; T-&gt;data.key) //在左子樹中繼續查找</div><div class="line">    return SearchBST(T-&gt;lchild, key, T, p);</div><div class="line">  else //在右子樹中繼續查找</div><div class="line">    return SearchBST(T-&gt;rchild, key, T, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在二叉搜索树插入节点的算法"><a href="#在二叉搜索树插入节点的算法" class="headerlink" title="在二叉搜索树插入节点的算法"></a>在二叉搜索树插入节点的算法</h2><p>向一个二叉搜索树b中插入一个节点s的算法，过程为：</p>
<ol>
<li>若b是空树，则将s所指结点作为根节点插入，否则：</li>
<li>若s-&gt;data等于b的根节点的数据域之值，则返回，否则：</li>
<li>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li>
<li>把s所指节点插入到右子树中。（新插入节点总是叶子节点）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Status InsertBST(BiTree *T, ElemType e)&#123;  </div><div class="line">      if(!T)  </div><div class="line">        &#123;	    </div><div class="line">            s = new BiTNode;</div><div class="line">            s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = NULL;</div><div class="line">            T=s;	//被插節点*s为新的根结点</div><div class="line">        &#125;</div><div class="line">      else if(e.key == p-&gt;data.key)</div><div class="line">        return false;//关键字等于e.key的数据元素，返回錯誤</div><div class="line">      if (e.key &lt; p-&gt;data.key)</div><div class="line">	InsertBST(p-&gt;lchild, e);	//將e插入左子樹</div><div class="line">      else </div><div class="line">	InsertBST(p-&gt;rchild, e);	//將e插入右子樹</div><div class="line">      return true;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="在二叉查找树删除结点的算法"><a href="#在二叉查找树删除结点的算法" class="headerlink" title="在二叉查找树删除结点的算法"></a>在二叉查找树删除结点的算法</h2><p>对于二叉查找树的删除操作（这里根据值删除，而非结点）分三种情况：</p>
<p>不过在此之前，我们应该确保根据给定的值找到了要删除的结点，如若没找到该结点不会执行删除操作！</p>
<p>下面三种情况假设已经找到了要删除的结点。</p>
<ol>
<li><p>如果结点为叶子结点（没有左、右子树），此时删除该结点不会玻化树的结构直接删除即可，并修改其父结点指向它的引用为null.如下图:<br><img src="http://img.blog.csdn.net/20130506115644277" alt=""></p>
</li>
<li><p>如果结点p只包含左子树，或者右子树的话，此时直接删除该结点p，并将其左子树或者右子树设置为其父结点的左子树或者右子树即可（若节点p是父节点的左子树，那么节点p的子树就是父节点的左子树。右子树同理），此操作不会破坏树结构。</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20130506115712159" alt=""></p>
<ol>
<li>当结点的左右子树都不空的时候，一般的删除策略是用其右子树的最小数据（利用中序遍历容易找到）代替要删除的结点数据并递归删除该结点（此时为null），因为右子树的最小结点不可能有左孩子，所以第二次删除较为容易。z的左子树和右子树均不空。找到z的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替z的值.如图：<blockquote>
<p>图中想要删除节点5，根据中序遍历，5的下一个节点是6，显然6也符合要求（无左子树），保存节点6的data信息（子树都设为空）并按照情况2从树中删除节点6，然后将6覆盖节点5。</p>
</blockquote>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20130506120027521" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">Status DeleteBST(BiTree *T, KeyType key)&#123;</div><div class="line">  //若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回</div><div class="line">  //TRUE；否则返回FALSE</div><div class="line">  if(!T) </div><div class="line">    return false;	//不存在关键字等于key的数据元素</div><div class="line">  else&#123;</div><div class="line">    if(key == T-&gt;data.key) &#123; 	//  找到关键字等于key的数据元素</div><div class="line">      return Delete(T);</div><div class="line">    &#125;</div><div class="line">    else if(key &lt; T-&gt;data.key)</div><div class="line">      return DeleteBST(T-&gt;lchild, key);</div><div class="line">    else</div><div class="line">      return DeleteBST(T-&gt;rchild, key);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Delete(BiTree *p)&#123;</div><div class="line">  //该节点为叶子节点，直接删除</div><div class="line">  BiTree *q, *s;</div><div class="line">  if (!p-&gt;rchild &amp;&amp; !p-&gt;lchild)</div><div class="line">  &#123;</div><div class="line">      delete p;</div><div class="line">      p = NULL;</div><div class="line">  &#125;</div><div class="line">  else if(!p-&gt;rchild)&#123;	//右子树空则只需重接它的左子树</div><div class="line">    q=p-&gt;lchild;</div><div class="line">    p-&gt;data = p-&gt;lchild-&gt;data;</div><div class="line">    p-&gt;lchild=p-&gt;lchild-&gt;lchild;</div><div class="line">    p-&gt;rchild=p-&gt;lchild-&gt;rchild;</div><div class="line"></div><div class="line">    delete q;</div><div class="line">  &#125;</div><div class="line">  else if(!p-&gt;lchild)&#123;	//左子树空只需重接它的右子树</div><div class="line">    q=p-&gt;rchild;</div><div class="line">    p-&gt;data = p-&gt;rchild-&gt;data;</div><div class="line">    p-&gt;lchild=p-&gt;rchild-&gt;lchild;</div><div class="line">    p-&gt;rchild=p-&gt;rchild-&gt;rchild;</div><div class="line"></div><div class="line">    delete q;  &#125;</div><div class="line">  else&#123;	//左右子树均不空</div><div class="line">//-----Flag-----</div><div class="line">    q=p; </div><div class="line">    s=p-&gt;lchild;</div><div class="line">    while(s-&gt;rchild)&#123; </div><div class="line">      q=s; </div><div class="line">      s=s-&gt;rchild;</div><div class="line">    &#125;	//转左，然后向右到尽头</div><div class="line">    p-&gt;data = s-&gt;data;	//s指向被删结点的“前驱”</div><div class="line">    if(q!=p)	</div><div class="line">      q-&gt;rchild = s-&gt;lchild;	//重接*q的右子树</div><div class="line">    else </div><div class="line">      q-&gt;lchild = s-&gt;lchild;	//重接*q的左子树</div><div class="line">    delete s;</div><div class="line">//-----Flag Off-----</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上述Flag标记间的代码：<br>这段代码是针对第三种情况wikipadia上给出的代码，然而他并没有按照中序遍历去找下一个节点，而是去节点p的左子树中找第一个没有右子树的节点，将该节点的值替换给p节点。如图所示：若删除节点5，那么将3替换上来；若删除节点12，则将10替换上来。</p>
<p>若是采用我所说的删除方法来，Flag间的代码应该替换成下面部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = FindMin(p-&gt;right);	//根据二叉树的中序号遍历，找到”右子树“的最小节点</div><div class="line">p-&gt;data = s-&gt;data;</div><div class="line">Delete(s);</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">wikipedia</a><br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/07/21/2602375.html" target="_blank" rel="external">6天通吃树结构</a><br><a href="http://blog.csdn.net/lcore/article/details/8889176" target="_blank" rel="external">二叉查找树–查找、删除、插入（Java实现）</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回文解码]]></title>
      <url>http://blog.acbingo.cn/2016/08/03/%E5%9B%9E%E6%96%87%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今日头条的一个编程题。学习到了string的两个函数</p>
<pre><code>reverse(string.begin(), string.end());
</code></pre><p>昨天编程的时候还琢磨string怎么没有个翻转函数什么的，原来用这个啊。</p>
<p>他是algorithm中的一个函数。<br>看样子需要花时间好好了解下algorithm里都有啥好用的东西啊。</p>
<a id="more"></a>
<p>现在有一个字符串，你要对这个字符串进行 n 次操作，每次操作给出两个数字：(p, l) 表示当前字符串中从下标为 p 的字符开始的长度为 l 的一个子串。你要将这个子串左右翻转后插在这个子串原来位置的正后方，求最后得到的字符串是什么。字符串的下标是从 0 开始的，你可以从样例中得到更多信息。</p>
<blockquote>
<p>每组测试用例仅包含一组数据，每组数据第一行为原字符串，长度不超过 10 ，仅包含大小写字符与数字。接下来会有一个数字 n 表示有 n 个操作，再接下来有 n 行，每行两个整数，表示每次操作的(p , l)。<br>保证输入的操作一定合法，最后得到的字符串长度不超过 1000。</p>
<p>ab<br>2<br>0 2<br>1 3</p>
<p>abbaabb</p>
</blockquote>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string st;</div><div class="line">    while (cin &gt;&gt; st)</div><div class="line">    &#123;</div><div class="line">        int n;</div><div class="line">        cin &gt;&gt; n;</div><div class="line">        while (n--)</div><div class="line">        &#123;</div><div class="line">            int beg, len, index;</div><div class="line">            cin &gt;&gt; beg &gt;&gt; len;</div><div class="line">            string temp = st.substr(beg, len);</div><div class="line">            index = beg + len;</div><div class="line">            reverse(temp.begin(), temp.end());</div><div class="line">            st.insert(index, temp);</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; st &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="C-Reverse-函数的用法"><a href="#C-Reverse-函数的用法" class="headerlink" title="C++ Reverse()函数的用法"></a>C++ Reverse()函数的用法</h1><blockquote>
<p>翻转c++数组或STL容器指定范围内的值</p>
</blockquote>
<p>头文件</p>
<pre><code>#include &lt;algorithm&gt;
</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>翻转普通数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int a[10] = &#123;&#125;;</div><div class="line">    for(int i=0;i&lt;10;i++)</div><div class="line">    &#123;</div><div class="line">        a[i]=i;</div><div class="line">    &#125;</div><div class="line">    //转换0～5下标的元素</div><div class="line">    std::reverse(a,a+5);</div><div class="line">    for(int i=0;i&lt;10;i++)</div><div class="line">    &#123;</div><div class="line">        std::cout&lt;&lt;a[i]&lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>翻转stl容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::vector&lt;int&gt; a;</div><div class="line">    std::vector&lt;int&gt;::iterator itr;</div><div class="line">    for(int i=0;i&lt;10;i++)</div><div class="line">    &#123;</div><div class="line">        a.push_back(i);</div><div class="line">    &#125;</div><div class="line">    //首尾翻转</div><div class="line">    std::reverse(a.begin(),a.end());</div><div class="line">    for(itr=a.begin();itr!=a.end();itr++)</div><div class="line">    &#123;</div><div class="line">        std::cout&lt;&lt;*itr&lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++中虚析构函数的作用]]></title>
      <url>http://blog.acbingo.cn/2016/08/03/C++%E4%B8%AD%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>我们知道，用C++开发的时候，用来做基类的类的析构函数一般都是虚函数。可是，为什么要这样做呢？<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class ClxBase</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ClxBase() &#123;&#125;;</div><div class="line">    virtual ~ClxBase() &#123;&#125;;</div><div class="line"></div><div class="line">    virtual void DoSomething() &#123; cout &lt;&lt; &quot;Do something in class ClxBase!&quot; &lt;&lt; endl; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class ClxDerived : public ClxBase</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ClxDerived() &#123;&#125;;</div><div class="line">    ~ClxDerived() &#123; cout &lt;&lt; &quot;Output from the destructor of class ClxDerived!&quot; &lt;&lt; endl; &#125;; </div><div class="line"></div><div class="line">    void DoSomething() &#123; cout &lt;&lt; &quot;Do something in class ClxDerived!&quot; &lt;&lt; endl; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 调用</div><div class="line">ClxBase *pTest = new ClxDerived;</div><div class="line">pTest-&gt;DoSomething();</div><div class="line">delete pTest;</div></pre></td></tr></table></figure>
<p>输出结果是：</p>
<pre><code>Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
</code></pre><p>这个很简单，非常好理解。<br>但是，如果把类ClxBase析构函数前的virtual去掉，那输出结果就是下面的样子了：</p>
<pre><code>Do something in class ClxDerived!
</code></pre><p>也就是说，类ClxDerived的析构函数根本没有被调用！一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。我想所有的C++程序员都知道这样的危险性。当然，如果在析构函数中做了其他工作的话，那你的所有努力也都是白费力气。<br>所以，文章开头的那个问题的答案就是－－这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。<br>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。</p>
<p><a href="http://blog.csdn.net/starlee/article/details/619827" target="_blank" rel="external">转载自</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const]]></title>
      <url>http://blog.acbingo.cn/2016/08/03/const/</url>
      <content type="html"><![CDATA[<p>const的用法与与define的区别<br><a id="more"></a></p>
<h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="http://blog.csdn.net/eric_jo/article/details/4138548" target="_blank" rel="external">关于C++ const 的全面总结</a></p>
<h1 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h1><h2 id="可以定义const常量"><a href="#可以定义const常量" class="headerlink" title="可以定义const常量"></a>可以定义const常量</h2><p>注意是const常量，与普通常量是有区别的。</p>
<h2 id="便于进行类型检查"><a href="#便于进行类型检查" class="headerlink" title="便于进行类型检查"></a>便于进行类型检查</h2><p>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void f(const int i) &#123; .........&#125;</div><div class="line">      //对传入的参数进行类型检查，不匹配进行提示</div></pre></td></tr></table></figure>
<p>这个作用没怎么看懂- -</p>
<h2 id="可以保护被修饰的东西"><a href="#可以保护被修饰的东西" class="headerlink" title="可以保护被修饰的东西"></a>可以保护被修饰的东西</h2><p>防止意外的修改，增强程序的健壮性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void f(const int i) &#123; i=10;//error! &#125;</div><div class="line">      //如果在函数体内修改了i，编译器就会报错</div></pre></td></tr></table></figure></p>
<h2 id="可以很方便地进行参数的调整和修改"><a href="#可以很方便地进行参数的调整和修改" class="headerlink" title="可以很方便地进行参数的调整和修改"></a>可以很方便地进行参数的调整和修改</h2><p>可以很方便地进行参数的调整和修改</p>
<h2 id="为函数重载提供了一个参考"><a href="#为函数重载提供了一个参考" class="headerlink" title="为函数重载提供了一个参考"></a>为函数重载提供了一个参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">           ......</div><div class="line">  void f(int i)       &#123;......&#125; //一个函数</div><div class="line">  void f(int i) const &#123;......&#125; //上一个函数的重载</div><div class="line">           ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="可以节省空间，避免不必要的内存分配"><a href="#可以节省空间，避免不必要的内存分配" class="headerlink" title="可以节省空间，避免不必要的内存分配"></a>可以节省空间，避免不必要的内存分配</h2><p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝<br><strong>这也是主要区别之一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define PI 3.14159         //常量宏</div><div class="line">const doulbe  Pi=3.14159;  //此时并未将Pi放入ROM中</div><div class="line">              ......</div><div class="line">double i=Pi;   //此时为Pi分配内存，以后不再分配！</div><div class="line">double I=PI;  //编译期间进行宏替换，分配内存</div><div class="line">double j=Pi;  //没有内存分配</div><div class="line">double J=PI;  //再进行宏替换，又一次分配内存！</div></pre></td></tr></table></figure></p>
<h2 id="提高了效率"><a href="#提高了效率" class="headerlink" title="提高了效率"></a>提高了效率</h2><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p>
<h1 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。</p>
<pre><code>TYPE const ValueName = value; 
const TYPE ValueName = value;
</code></pre><p>(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.</p>
<pre><code>extend const int ValueName = value;
</code></pre><h2 id="指针使用CONST"><a href="#指针使用CONST" class="headerlink" title="指针使用CONST"></a>指针使用CONST</h2><p>(1)指针本身是常量不可变</p>
<pre><code>char* const pContent;
</code></pre><p>(2)指针所指向的内容是常量不可变</p>
<pre><code>const char *pContent; 
</code></pre><p>(3)两者都不可变</p>
<pre><code>const char* const pContent; 
</code></pre><h2 id="函数中使用CONST"><a href="#函数中使用CONST" class="headerlink" title="函数中使用CONST"></a>函数中使用CONST</h2><p>(1)const修饰函数参数<br>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p>
<pre><code>void function(const int Var);
</code></pre><p>b.参数指针所指内容为常量不可变</p>
<pre><code>void function(const char* Var);
</code></pre><p>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p>
<pre><code>void function(char* const Var);
</code></pre><p>d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：</p>
<pre><code>void function(const Class&amp; Var); //引用参数在函数内不可以改变

void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变
</code></pre><p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.</p>
<p>(2)const 修饰函数返回值<br>    const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p>
<pre><code>a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。
b. const int * fun2() //调用时 const int *pValue = fun2(); 
                      //我们可以把fun2()看作成一个变量，即指针内容不可变。
c.int* const fun3()   //调用时 int * const pValue = fun2(); 
                      //我们可以把fun2()看作成一个变量，即指针本身不可变。
</code></pre><p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
<h2 id="类相关CONST"><a href="#类相关CONST" class="headerlink" title="类相关CONST"></a>类相关CONST</h2><p>(1)const修饰成员变量<br>const修饰类的成员函数，表示成员常量，不能被修改，<strong>同时它只能在初始化列表中赋值。</strong></p>
<pre><code>class A
{ 
    …
    const int nValue;         //成员常量不能被修改
    …
    A(int x): nValue(x) { } ; //只能在初始化列表中赋值
 } 
</code></pre><p>(2)const修饰成员函数<br>const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。</p>
<pre><code>class A
{ 
    …
   void function()const; //常成员函数, 它不改变对象的成员变量.                        
//也不能调用类中任何非const成员函数。
}
</code></pre><p>对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。</p>
<p>a. const成员函数不被允许修改它所在对象的任何一个数据成员。</p>
<p>b. const成员函数能够访问对象的const成员，而其他成员函数不可以。</p>
<p>(3)const修饰类对象/对象指针/对象引用</p>
<p>·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。</p>
<p>·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class AAA</div><div class="line">&#123; </div><div class="line">    void func1(); </div><div class="line">void func2() const; </div><div class="line">&#125; </div><div class="line">const AAA aObj; </div><div class="line">aObj.func1(); ×</div><div class="line">aObj.func2(); 正确</div><div class="line"></div><div class="line">const AAA* aObj = new AAA(); </div><div class="line">aObj-&gt; func1(); ×</div><div class="line">aObj-&gt; func2(); 正确</div></pre></td></tr></table></figure></p>
<h1 id="将Const类型转化为非Const类型的方法"><a href="#将Const类型转化为非Const类型的方法" class="headerlink" title="将Const类型转化为非Const类型的方法"></a>将Const类型转化为非Const类型的方法</h1><p>用法：const_cast <type_id>  (expression)<br>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。</type_id></p>
<ul>
<li><p>常量指针被转化成非常量指针，并且仍然指向原来的对象；</p>
</li>
<li><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；</p>
</li>
<li><p>常量对象被转换成非常量对象。</p>
</li>
</ul>
<h1 id="const需要注意的地方"><a href="#const需要注意的地方" class="headerlink" title="const需要注意的地方"></a>const需要注意的地方</h1><p>const定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量，存放在静态区)，而define定义的宏常量在内存中有若干个拷贝。<br>define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。</p>
<h2 id="define宏没有类型，而const修饰的只读变量具有特定的类型"><a href="#define宏没有类型，而const修饰的只读变量具有特定的类型" class="headerlink" title="define宏没有类型，而const修饰的只读变量具有特定的类型"></a>define宏没有类型，而const修饰的只读变量具有特定的类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const int *p;   //p可变，p指向的对象不可变</div><div class="line">int const*p;  //p可变，p指向的对象不可变</div><div class="line">int *const p;  //p不可变，p指向的对象可变</div><div class="line">const int *const p;  //指针p和p指向的对象都不可变</div></pre></td></tr></table></figure>
<hr>
<p>总的来说：<br>const：有数据类型，编译进行安全检查，可调试<br>define:宏，不考虑数据类型，没有安检，不能调试 </p>
<p>这里有一个记忆和理解的方法：<br>先忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。”近水楼台先得月”，离谁近就修饰谁。<br>判断时忽略括号中的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const (int) *p;   //const修饰*p，*p是指针指向的对象，不可变</div><div class="line">(int) const *p；  //const修饰*p，*p是指针指向的对象，不可变</div><div class="line">(int)*const p;   //const修饰p，p不可变，p指向的对象可变</div><div class="line">const (int) *const p;  //前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const与常成员函数]]></title>
      <url>http://blog.acbingo.cn/2016/08/03/const%E4%B8%8E%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>今天在刷选择题的时候碰到了常成员函数这一概念，比较模式，遂来学习下，顺便复习下const这个关键字。<br><a id="more"></a></p>
<h1 id="常成员函数详解"><a href="#常成员函数详解" class="headerlink" title="常成员函数详解"></a>常成员函数详解</h1><blockquote>
<p>声明：&lt;类型标志符&gt;函数名（参数表）const；<br>说明：<br>（1）const是函数类型的一部分，在实现部分也要带该关键字。<br>（2）const关键字可以用于对重载函数的区分。<br>（3）常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。</p>
</blockquote>
<p>通过例子来理解const是函数类型的一部分，在实现部分也要带该关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">private:</div><div class="line">     int w,h;</div><div class="line">public:</div><div class="line">     int getValue() const;</div><div class="line">     int getValue();</div><div class="line">     A(int x,int y)</div><div class="line">     &#123;</div><div class="line">         w=x,h=y;</div><div class="line">     &#125;</div><div class="line">     A()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">int A::getValue() const     //实现部分也带该关键字</div><div class="line">&#123;</div><div class="line">     return w*h; //？？？？</div><div class="line">&#125;</div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">     A const a(3,4);</div><div class="line">     A c(2,6);</div><div class="line">cout&lt;&lt;a.getValue()&lt;&lt;c.getValue()&lt;&lt;&quot;cctwlTest&quot;;</div><div class="line">system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过例子来理解const关键字的重载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">private:</div><div class="line">     int w,h;</div><div class="line">public:</div><div class="line">int getValue() const</div><div class="line">&#123;</div><div class="line">         return w*h;</div><div class="line">     &#125;</div><div class="line">     int getValue()&#123;</div><div class="line">         return w+h;</div><div class="line">     &#125;</div><div class="line">     A(int x,int y)</div><div class="line">     &#123;</div><div class="line">         w=x,h=y;</div><div class="line">     &#125;</div><div class="line">     A()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">void main()</div><div class="line">&#123;   </div><div class="line">     A const a(3,4);</div><div class="line">     A c(2,6);</div><div class="line">     cout&lt;&lt;a.getValue()&lt;&lt;c.getValue()&lt;&lt;&quot;cctwlTest&quot;; //输出12和8</div><div class="line">     system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过例子来理解常成员函数不能更新任何数据成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">private:</div><div class="line">     int w,h;</div><div class="line">public:</div><div class="line">     int getValue() const;</div><div class="line">     int getValue();</div><div class="line">     A(int x,int y)</div><div class="line">     &#123;</div><div class="line">         w=x,h=y;</div><div class="line">     &#125;</div><div class="line">     A()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">int A::getValue() const</div><div class="line">&#123;</div><div class="line">    w=10,h=10;//错误，因为常成员函数不能更新任何数据成员</div><div class="line">     return w*h;</div><div class="line">&#125;</div><div class="line">int A::getValue()</div><div class="line">&#123;</div><div class="line">     w=10,h=10;//可以更新数据成员</div><div class="line">     return w+h;</div><div class="line">&#125;</div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">      A const a(3,4);</div><div class="line">     A c(2,6);</div><div class="line">     cout&lt;&lt;a.getValue()&lt;&lt;endl&lt;&lt;c.getValue()&lt;&lt;&quot;cctwlTest&quot;;         </div><div class="line">　system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过例子来理解<br>1、常成员函数可以被其他成员函数调用。<br>2、但是不能调用其他非常成员函数。<br>3、可以调用其他常成员函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">private:</div><div class="line">     int w,h;</div><div class="line">public:</div><div class="line">     int getValue() const</div><div class="line">&#123;</div><div class="line">   return w*h + getValue2();//错误的不能调用其他非常成员函数。</div><div class="line">&#125;</div><div class="line">   int getValue2()</div><div class="line">     &#123;</div><div class="line">        </div><div class="line">         return w+h+getValue();//正确可以调用常成员函数</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     A(int x,int y)</div><div class="line">     &#123;</div><div class="line">         w=x,h=y;</div><div class="line">     &#125;</div><div class="line">     A()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">     A const a(3,4);</div><div class="line">     A        c(2,6);</div><div class="line">cout&lt;&lt;a.getValue()&lt;&lt;endl&lt;&lt;c.getValue2()&lt;&lt;&quot;cctwlTest&quot;;         </div><div class="line">system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常成员函数的用法就这几个，想了半天，除了能增加程序的可读性外，貌似并没有想到其它<strong>非用不可</strong>的实际用途。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[虚拟继承]]></title>
      <url>http://blog.acbingo.cn/2016/07/31/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>剑指offer一书的面试题48：《不能被继承的类》一题提到了虚拟继承这一概念。</p>
<p>之前只了解过利用虚函数实现多态。今天还是头一次看到虚拟继承这个名词，遂来学习下。</p>
<a id="more"></a>
<blockquote>
<p>虚继承 是面向对象编程中的一种技术，是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。</p>
<p>举例来说：假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符）。但是如果类A与B各自虚继承了类X，那么C的对象就只包含一套类X的实例数据。</p>
<p>这一特性在多重继承应用中非常有用，可以使得虚基类对于由它直接或间接派生的类来说，拥有一个共同的基类对象实例。避免由于带有歧义的组合而产生的问题（如“菱形继承问题”）。其原理是，间接派生类（C）穿透了其父类（上面例子中的A与B），实质上直接继承了虚基类X。</p>
<p>这一概念一般用于“继承”在表现为一个整体，而非几个部分的组合时。在C++中，基类可以通过使用关键字virtual来声明虚继承关系。</p>
</blockquote>
<p>看了这句话，我就明白课本上讲的了。当Try继承SealedClass2时，由于SealedClass2是虚继承的MakeSealed，所以Try会直接调用MakeSealed的构造函数，而MakSealed的构造函数是private的，且Try不是MakeSealed的友元，所以就会导致编译出错。</p>
<p>实际上，关于虚继承的用法与好处，我觉得wikipedia上讲个很清楚，我就不搬运了，直接扔个传送门:</p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E7%BB%A7%E6%89%BF" target="_blank" rel="external">虚继承-维基百科，自由的百科全书</a></p>
<p>值得一提的是,wikipedia上也提到了这个题的解法:</p>
<h2 id="虚继承的应用：不可派生的finally类"><a href="#虚继承的应用：不可派生的finally类" class="headerlink" title="虚继承的应用：不可派生的finally类"></a>虚继承的应用：不可派生的finally类</h2><p>一个类如果不希望被继承，类似于Java中的具有finally性质的类，这在C++中可以用虚继承来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt; class MakeFinally&#123;</div><div class="line">   private:</div><div class="line">       MakeFinally()&#123;&#125;;//只有MakeFinally的友类才可以构造MakeFinally</div><div class="line">       ~MakeFinally()&#123;&#125;;</div><div class="line">   friend T;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class MyClass:public virtual  MakeFinally&lt;MyClass&gt;&#123;&#125;;//MyClass是不可派生类</div><div class="line"></div><div class="line">//由于虚继承，所以D要直接负责构造MakeFinally类，从而导致编译报错，所以D作为派生类是不合法的。</div><div class="line">class D: public MyClass&#123;&#125;;</div><div class="line">//另外，如果D类没有实例化对象，即没有被使用，实际上D类是被编译器忽略掉而不报错</div><div class="line"></div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">MyClass var1;</div><div class="line">// D var2;  //这一行编译将导致错误，因为D类的默认构造函数不合法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数指针]]></title>
      <url>http://blog.acbingo.cn/2016/07/31/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>剑指offer上提到了函数指针这一概念，之前接触过，但是一直了解的不是很清晰。</p>
<blockquote>
<p>数组名就是指向数组第一个元素的常量指针。同理，对于一个函数而言，函数名也是指向函数第一条指令的常量指针。而编译器要做的就是在程序编译之后，为每个函数分配一个首地址，即该函数第一条指令的地址。一般情况下，我们可以用一个指针来保存这个地址，而这个指针就是函数指针，该指针可以看作是它指向函数的别名，所以我们可以用该指针来调用这个函数。</p>
</blockquote>
<a id="more"></a>
<h1 id="函数指针的声明方法"><a href="#函数指针的声明方法" class="headerlink" title="函数指针的声明方法"></a>函数指针的声明方法</h1><pre><code>type (*func)(type ,type )
</code></pre><p>该语句声明了一个指针func，它指向了一个函数，这个函数带有了2个type型参数并返回一个type的值。</p>
<p>p.s. type类型可以被看成是int啊或者是floast等C++的类型。    </p>
<ol>
<li>一个指向函数的指针必须确保该函数被定义且分配了内存，否则它将指向一个空地址.</li>
<li>特别注意第一个括号的位置。如果我们不写括号</li>
</ol>
<pre><code>type *func(type ,type)
</code></pre><p>这就不是一个指向函数的指针了，而是声明了一个函数，该函数返回一个type类型的指针　</p>
<ol>
<li>声明函数指针时，其返回值，参数个数，参数类型应该与需要它指向的函数保持一致；否则，编译器会报错，无法从“<strong><em>”转换到“</em></strong>”；</li>
<li>利用函数指针只想某个函数的时候，我们只用，也只能给出该函数的函数名，不能把参数一并给出了。因为<strong>函数名也是指向函数第一条指令的常量指针</strong>。因为函数指针就是指向其函数的地址的，那么我们就应该利用函数指针来指向函数名就可以了。</li>
</ol>
<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><p>形式1：返回类型(*函数名)(参数表)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">char (*pFun)(int);   </div><div class="line">char glFun(int a)&#123; return;&#125;   </div><div class="line">void main()   </div><div class="line">&#123;   </div><div class="line">    pFun = glFun;   </div><div class="line">    (*pFun)(2);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一行定义了一个指针变量pFun。首先我们根据前面提到的“形式1”认识到它是一个指向某种函数的指针，这种函数参数是一个int型，返回值是char类型。只有第一句我们还无法使用这个指针，因为我们还未对它进行赋值。<br>第二行定义了一个函数glFun()。该函数正好是一个以int为参数返回char的函数。我们要从指针的层次上理解函数——函数的函数名实际上就是一个指针，函数名指向该函数的代码在内存中的首地址<br>然后就是main()函数了，它的第一句您应该看得懂了——它将函数glFun的地址赋值给变量pFun。main()函数的第二句中“*pFun”显然是取pFun所指向地址的内容，当然也就是取出了函数glFun()的内容，然后给定参数为2。</p>
<h2 id="使用typedef更直观更方便"><a href="#使用typedef更直观更方便" class="headerlink" title="使用typedef更直观更方便"></a>使用typedef更直观更方便</h2><p>形式1：typedef  返回类型(*新类型)(参数表)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef char (*PTRFUN)(int);   </div><div class="line">PTRFUN pFun;   </div><div class="line">char glFun(int a)&#123; return;&#125;   </div><div class="line">void main()   </div><div class="line">&#123;   </div><div class="line">    pFun = glFun;   </div><div class="line">    (*pFun)(2);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>typedef的功能是定义新的类型。第一句就是定义了一种PTRFUN的类型，并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了。<br>第二行的代码便使用这个新类型定义了变量pFun，此时就可以像使用形式1一样使用这个变量了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;assert.h&gt;  </div><div class="line">  </div><div class="line">typedef int (*FP_CALC)(int,int);//定义一个函数指针类型  </div><div class="line">  </div><div class="line">int add(int a, int b)  </div><div class="line">&#123;  </div><div class="line">    return a + b;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int sub(int a, int b)  </div><div class="line">&#123;  </div><div class="line">    return a - b;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int mul(int a, int b)  </div><div class="line">&#123;  </div><div class="line">    return a * b;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int div(int a, int b)  </div><div class="line">&#123;  </div><div class="line">    return b ? a/b : -1;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">//定义一个函数，参数为op，返回一个指针,该指针类型为拥有两个int参数、  </div><div class="line">//返回类型为int的函数指针。它的作用是根据操作符返回相应函数的地址  </div><div class="line">FP_CALC calc_func(char op)  </div><div class="line">&#123;  </div><div class="line">    switch( op )  </div><div class="line">    &#123;  </div><div class="line">    case &apos;+&apos;:  </div><div class="line">        return add;  </div><div class="line">    case &apos;-&apos;:  </div><div class="line">        return sub;  </div><div class="line">    case &apos;*&apos;:  </div><div class="line">        return mul;  </div><div class="line">    case &apos;/&apos;:  </div><div class="line">        return div;  </div><div class="line">    default:  </div><div class="line">        return NULL;  </div><div class="line">    &#125;  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">//最终用户直接调用的函数，该函数接收两个int整数，  </div><div class="line">//和一个算术运算符，返回两数的运算结果  </div><div class="line">int calc(int a, int b, char op)  </div><div class="line">&#123;  </div><div class="line">    FP_CALC fp = calc_func(op);  </div><div class="line">    if(fp)  </div><div class="line">        return fp(a,b);  </div><div class="line">    else  </div><div class="line">        return -1;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void main()  </div><div class="line">&#123;  </div><div class="line">    int a = 100, b = 20;  </div><div class="line">  </div><div class="line">    printf(&quot;calc(%d, %d, %c) = %d\n&quot;, a, b, &apos;+&apos;, calc(a, b, &apos;+&apos;));  </div><div class="line">    printf(&quot;calc(%d, %d, %c) = %d\n&quot;, a, b, &apos;-&apos;, calc(a, b, &apos;-&apos;));     </div><div class="line">    printf(&quot;calc(%d, %d, %c) = %d\n&quot;, a, b, &apos;*&apos;, calc(a, b, &apos;*&apos;));     </div><div class="line">    printf(&quot;calc(%d, %d, %c) = %d\n&quot;, a, b, &apos;/&apos;, calc(a, b, &apos;/&apos;));   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/uniqueliu/archive/2011/07/27/2118619.html" target="_blank" rel="external">函数指针及其的运用（上）——何为函数指针</a><br><a href="http://blog.csdn.net/qll125596718/article/details/6891881/" target="_blank" rel="external">typedef函数指针用法</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记事本]]></title>
      <url>http://blog.acbingo.cn/2016/07/28/%E8%AE%B0%E4%BA%8B%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>一块符合material design的安卓app—记事本。</p>
<p>其实是我花了一下午时间做出来的，功能有点简单。哈哈哈哈，剩下的一上午+九天时间小学期时间我都跑去玩了~<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>值得一说的就是这次顺便了解了Android的一款轻量级ORM框架ActiveAndroid。<br>说白了就是操作数据库的，非常的好用啊</p>
<h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><p>功能比较单一，没啥可说的，直接上几张图片吧</p>
<p>空界面<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f69xazuclnj30dr0l4wes.jpg" alt=""></p>
<p>编辑界面<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f69xb9bzyij30dn0k3t8t.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f69xbgp1rzj30dn0kuq3g.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f69xbp4jb7j30dt0l73zc.jpg" alt=""></p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/ACBingo/notepad" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[StarFiles]]></title>
      <url>http://blog.acbingo.cn/2016/07/28/StarFiles/</url>
      <content type="html"><![CDATA[<p>一款跨平台，支持多设备多文件同时传输的安卓App<br><a href="http://v.youku.com/v_show/id_XMTY1NDczODIyOA==.html" target="_blank" rel="external">项目视频介绍</a><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f6anwqfz2oj306i06imxa.jpg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年4月在北京参加腾讯的实习生招聘，都走到最后一天了被挂了，面试官嫌我没有项目经验<br>T T 55555555</p>
<p>被挂了后无比的伤心，其它投的公司通知去面试一个没去（虽然现在后悔了- -）。总之回来的路上就横下心，不去找实习了，好好搞个项目！</p>
<p>回来后正好中国软件杯开始，拉上两个小伙伴开干！最终选了文件传输这个课题。</p>
<p>报名前我对Android一点都不了解，甚至都不知道如何new project</p>
<p>不过最终经过两个月的奋斗，做出了这么个app。</p>
<h1 id="在这个项目中我负责什么？"><a href="#在这个项目中我负责什么？" class="headerlink" title="在这个项目中我负责什么？"></a>在这个项目中我负责什么？</h1><p>我在团队中负责项目整体架构的规划，项目规范以及代码接口的制定以及整个项目大部分代码的编写与测试。</p>
<h1 id="有什么亮点"><a href="#有什么亮点" class="headerlink" title="有什么亮点"></a>有什么亮点</h1><ol>
<li>采用<strong>声波</strong>进行握手通信，自动搭建热点并可以自动连接。使得设备间建立连接一键傻瓜式搞定~</li>
<li><strong>任何时间任何地点</strong>都可以进行文件传输。近距离情况下，设备会通过搭建热点进行局域网传输。远距离情况下（需要设备连接网络），可以将文件上传到StarFiles服务器进行中转传输。</li>
<li>不仅支持多文件同时传输，还支持<strong>多个设备同时传输</strong>！发送端可以将多份文件同时发送个N个设备，当然，接收端可以自行选择接受哪些文件哦，为了保证传输速度，发送端会根据文件的大小和接收端的接收情况进行<strong>多线程</strong>传输</li>
<li>支持pc安卓端的文件传输，后期准备加入ios端。</li>
<li>友好的界面设计</li>
<li>支持蓝牙传输</li>
<li>灵感来源于starwars，当然会有starwars的彩蛋啦。</li>
</ol>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/ACBingo/StarFiles" target="_blank" rel="external">github</a></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当然，我们之所以能做出来除了感谢队友们的辛勤劳动外，还有感谢github这个平台以及好多被我用到的开源项目~<br>开发软件原来比练ACM容易多了= =</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[酒店管理系统]]></title>
      <url>http://blog.acbingo.cn/2016/07/28/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>软件工程的项目实践。由于界面比较多，了解到C#的WPF做界面比较方便，所以简单自学下C#的WPF，最终开发出一套这样的简单软件.<br><a id="more"></a></p>
<h1 id="项目说明书"><a href="#项目说明书" class="headerlink" title="项目说明书:"></a>项目说明书:</h1><p><a href="http://wenku.baidu.com/view/19a3e684ed3a87c24028915f804d2b160b4e86e1" target="_blank" rel="external">百度文库</a></p>
<h1 id="界面截图"><a href="#界面截图" class="headerlink" title="界面截图"></a>界面截图</h1><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f6ann9joloj30go0b4754.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f6anoei9e3j30mb0dzmyt.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f6anoqa99vj30ls0dmgmg.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f6anouqqkhj30lr0dpn01.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞机大战]]></title>
      <url>http://blog.acbingo.cn/2016/07/28/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
      <content type="html"><![CDATA[<p>大二的时候用cocos2dx开发的一款可以在安卓/win平台同步运行的游戏<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做这个项目距离现在已经有一年了，最近准备写简历，所以打算把这个项目整理一下，但是需要配置cocos2dx开发环境。记得当时开发的时候cocos刚到3.0版本，刚才我去国内官网一看，已经发展到3.12了，好快呀。跟NodeJs似的。</p>
<p>费了一上午的时间下载NDK也没下载下来，学习速度太慢啊55555，导致安卓版无法编译成功。</p>
<p>啊啊啊啊，win版怎么也配不起来了啊，版本迭代导致api不一样了啊，好多编译错误，改的要死了555555</p>
<hr>
<p>放弃了:) 已经过去一个多小时，木有意义不改了。</p>
<h1 id="为什么用cocos2dx开发"><a href="#为什么用cocos2dx开发" class="headerlink" title="为什么用cocos2dx开发"></a>为什么用cocos2dx开发</h1><p>其实这是学校的项目实践课程。小学期两个周的时间，由老师带着同学们用MFC开发出一款飞机大战的游戏。</p>
<p>什么？？都什么年代了还用MFC？？<br>我就不爱用！小学期就听完了第一节课，了解项目需求后就没再去过。自己跑另一个没有人的小机房里，打算换种其它比较“现代”的语言开发。<br>最开始打算使用c#，尝试了一天后发现光界面处理就好麻烦啊。然后又决定试一下unity吧。</p>
<p>在搜unity的过程中发现了cocos2dx，令我欢喜的是cocos2dx支持c++，可以使用vs进行开发。于是最终决定用cocos2dx来实现我的飞机大战.</p>
<h1 id="我的飞机大战有哪些亮点"><a href="#我的飞机大战有哪些亮点" class="headerlink" title="我的飞机大战有哪些亮点?"></a>我的飞机大战有哪些亮点?</h1><p>由于比较久远了，中途硬盘坏过一次，也没留下已经编译好的exe文件- -。现在想截几个界面图还得重新配置环境，api的迭代更新导致我需要更改大量的代码，时间关系我还是选择放弃吧。</p>
<ol>
<li>支持鼠标以及键盘两种操作方式。（安卓版支持触控）</li>
<li>一共有5张关卡。每张关卡有不同的游戏内容，以及不同的最终BOSS。随着关卡的进行，游戏难度相应提高，敌人的子弹伤害，生命值，移动速度也会提高。</li>
<li>战机有4种战斗形态。升级方式通过获得游戏中的掉落道具所得。</li>
<li>敌机一共有15种。第一关会随机出现3种敌人，第二关会出现6种，以此类推，每升一关会多出3种敌人。</li>
<li>每一关最后会出现BOSS敌机，有独特的攻击方式以及丰厚的血量。</li>
<li>战机的导弹有5种形态。每种形态有不同的视觉效果以及攻击能力。导弹升级通过获得游戏中的掉落道具所得。</li>
<li>核弹系统。使用后清除全屏的敌机（Boss则会掉一定血量）。游戏开始会自带三发核弹。核弹可以通过游戏中吃取掉落道具所得。</li>
<li>血量系统。屏幕下方有飞机的血量显示。随着飞机的升级总血量值也会得到提升。同时可以通过吃取游戏中的掉落道具获得血量。</li>
<li><strong>敌机的运动规律不是单调的，会做平滑的曲线运动。每一种敌机的运动范围与运动速度也不相同，有自己的移动方式</strong></li>
<li>6种掉落道具。击杀敌机后有一定概率出现。</li>
</ol>
<h1 id="值得一提的技术"><a href="#值得一提的技术" class="headerlink" title="值得一提的技术"></a>值得一提的技术</h1><p>这里简述几点值得一提的技术以及知识点。<br>敌机运动轨迹产生技术。<br>为了使敌机的运动轨迹能做出来无规律的曲线运动，同时使得运动曲线平滑不突兀。我编写了随机贝塞尔曲线生成器。给出敌机的出现位置以及消失位置，以及随机出两个制约点，即可得到一条符合要求的贝塞尔曲线，使得敌机沿着该曲线运动。<br>图层技术。<br>引入了图片处理软件常用的图层概念。方便进行碰撞检测<br>背景图位于图层0。战绩敌机子弹掉落的道具等位于图层1.云彩位于图层2.而分数显示等文字信息位于最上方的图层。<br>这样，不同图层的物体不会互相访问到，高图层的物体会在视觉效果上遮挡住低图层的物体。<br>敌人产生器。<br>通过敌人产生器，可以根据当前的战机状态，游戏关卡等随机产生一个符合要求的敌人。不同的敌机属性，视觉效果，飞行速率，飞行曲线，伤害值，血量等等都是通过其产生的。<br>道具掉落系统。<br>游戏中一共会出现7种道具:<br>1． 血包。掉落概率10% 获得后增加当前战机血量百分之十的生命值。<br>2． 伤害增加。掉落概率为5%，增加当前子弹1点伤害值。伤害值每达到5（为了方便演示，已修改为1）的倍数，子弹的视觉效果得到升级。最高20点。<br>3． 战机升级。掉落概率为0.5%，战机获得升级！最高5级。升级后，战机获得全新的视觉外观，更多的生命值，更多的子弹以及更快的子弹发射频率。<br>4． 子弹速率加快。掉落概率为5%。增加当前子弹一定的发射速率。最高为每秒5发。（为了方便演示，默认5发每秒）<br>5． 获得一枚核弹。掉落概率为4% 战机最高可存储9发核弹。<br>6． 获得三枚核弹。掉落概率为1%<br>7． 子弹移动速度加快。掉落概率为5%<br>内存释放技术<br>为了保证游戏流畅度，所有元素均采用内存动态释放技术（由各自统一的管理类）。当一个资源（物品，子弹或者敌机等）不再在屏幕上显示而且判断出以后也不会显示后，会调用该技术释放掉其所占用内存。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码放到了github上吧<br><a href="https://github.com/ACBingo/plane" target="_blank" rel="external">plane</a></p>
<h1 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h1><p>算是边学边用吧，一共花了两个周的时间，虽然最后还有好多想实现的功能没来的急实现。最后老师给出了全系前3的口头评价~也算满足了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[仿函数/函数对象]]></title>
      <url>http://blog.acbingo.cn/2016/07/27/%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一直以来，对函数对象这个点很模糊。今天终于可以系统的学习下。</p>
<blockquote>
<p>提到C++ STL，首先被人想到的是它的三大组件：Containers, Iterators, Algorithms，即容器，迭代器和算法。容器为用户提供了常用的数据结构，算法大多是独立于容器的常用的基本算法，迭代器是由容器提供的一种接口，算法通过迭代器来操控容器。接下来要介绍的是另外的一种组件，函数对象（Function Object，JJHou译作Functor仿函数）。</p>
</blockquote>
<a id="more"></a>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>由于本篇绝大部分内容参考自某一博客，所以这里先给出参考地址:<br><a href="http://www.cnblogs.com/weiqubo/archive/2011/02/16/1956552.html" target="_blank" rel="external">函数对象/仿函数</a></p>
<p>感谢原作者把函数对象讲的如此系统详细</p>
<h1 id="什么是函数对象"><a href="#什么是函数对象" class="headerlink" title="什么是函数对象"></a>什么是函数对象</h1><p>顾名思义，函数对象首先是一个对象，即某个类的实例。其次，函数对象的行为和函数一致，即是说可以像调用函数一样来使用函数对象，如参数传递、返回值等。这种行为是通过重载类的()操作符来实现的，举例说明之，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Print</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void operator()(int n)</div><div class="line">    &#123;</div><div class="line">        std::cout&lt;&lt;n&lt;&lt;std::endl;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">int</div><div class="line">main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    Print print;</div><div class="line">    print(372);</div><div class="line">    print.operator()(372); //~ 显式调用</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　其实我们早就开始使用函数对象了，当你写下sort(v.begin(), v.end())时(假定v是vector<int>)，其实调用的是sort(v.begin(), v.end(), less<int>())，这样sort就会将v从小至大排序。若要逆向排序，你就需要显式地为sort指定一个排序规则，即函数对象greater<int>(). less<t>和greater<t>是STL中的两个模板类，它们使用类型T的&lt;和&gt;操作符。less<t>的一个典型实现可能是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class less</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    bool operator()(const T&amp;l, const T&amp;r)const</div><div class="line">    &#123;</div><div class="line">        return l &lt; r;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></t></t></t></int></int></int></p>
<h1 id="函数对象的分类"><a href="#函数对象的分类" class="headerlink" title="函数对象的分类"></a>函数对象的分类</h1><p>根据用途和参数特征，STL中的函数对象通常分为以下几类：Predicates, Arithmetic Function Objects, Binders, Negaters, Member Function Adapters, Pointer to Function Adapters。下面逐一介绍一下，之前得先介绍两个基类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">template&lt;class Arg, class Res&gt;</div><div class="line">struct unary_function //~ 一元函数对象基类</div><div class="line">&#123;</div><div class="line">   typedef Arg argument_type;</div><div class="line">   typedef Res result_type;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;class Arg1, class Arg2, class Res&gt;</div><div class="line">struct binary_function //~ 二元函数对象基类</div><div class="line">&#123;</div><div class="line">   typedef Arg1 first_argument_type;</div><div class="line">   typedef Arg2 second_argument_type;</div><div class="line">   typedef Res  result_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用这两个基类，首先需要包含头文件。</p>
<h2 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h2><p>Predicate是一种函数对象，返回值（应该是operator()的返回值）为布尔型，接受一个或者两个参数。通常用来判断对象的有效性（一个参数时）或者对两个对象进行比较（如less）。你可以根据自己的需要定义自己的Predicate，但STL已经定义了一些Predicate，你可以直接使用。</p>
<table>
<thead>
<tr>
<th>Predicate</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>equal_to()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用==判等</td>
</tr>
<tr>
<td>not_equal_to()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用!=判等</td>
</tr>
<tr>
<td>less()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用&lt;</td>
</tr>
<tr>
<td>greater()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用&gt;</td>
</tr>
<tr>
<td>less_equal()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用&lt;=</td>
</tr>
<tr>
<td>greater_equal()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用&gt;=</td>
</tr>
<tr>
<td>logical_not()</td>
<td style="text-align:center">Unary</td>
<td style="text-align:right">使用!逻辑取反</td>
</tr>
<tr>
<td>logical_and()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用&amp;&amp;逻辑与</td>
</tr>
<tr>
<td>logical_or()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用</td>
<td></td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
<h2 id="算术运算函数对象"><a href="#算术运算函数对象" class="headerlink" title="算术运算函数对象"></a>算术运算函数对象</h2><p>进行简单的算术运算，这类函数对象我用的很少，通常是自己定义。</p>
<table>
<thead>
<tr>
<th>函数对象</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>negate()</td>
<td style="text-align:center">Unary</td>
<td style="text-align:right">使用-求负</td>
</tr>
<tr>
<td>plus()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用+加法</td>
</tr>
<tr>
<td>minus()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用-减法</td>
</tr>
<tr>
<td>multiplies()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用*乘法</td>
</tr>
<tr>
<td>divides()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用/除法</td>
</tr>
<tr>
<td>modulus()</td>
<td style="text-align:center">Binary</td>
<td style="text-align:right">使用%求余</td>
</tr>
</tbody>
</table>
<h2 id="绑定Binders"><a href="#绑定Binders" class="headerlink" title="绑定Binders"></a>绑定Binders</h2><p>有两种绑定bind1st和bind2nd，它们可以将一个二元函数对象的其中一个参数绑定为某个已知的对象，从而得到一个一元函数对象。例如要在vector<int> v中查找等于372的值的位置，我可以将372绑定到equal_to<int>()的第一个或者第二个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; v;</div><div class="line">    for(int i = 0; i &lt; 1000; ++i)</div><div class="line">    &#123;</div><div class="line">        v.push_back(i);</div><div class="line">    &#125;</div><div class="line">    vector&lt;int&gt;::iterator it;</div><div class="line">    it = find_if(v.begin(), v.end(), bind1st(equal_to&lt;int&gt;(), 372));</div><div class="line">    std::cout&lt;&lt;*it&lt;&lt;std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></int></int></p>
<blockquote>
<p>其实到下面就开始看不懂了.应该是对函数模板理解不深的原因.看来我不聪明呀= =</p>
</blockquote>
<p>其实，这里的bind1st和bind2nd并不是函数对象，只是模板函数而已。这两个函数分别返回类型为binder1st和binder2nd的函数对象。下面的代码，聪明的你肯定一看就懂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// bind1st</div><div class="line">template&lt;class Op&gt; </div><div class="line">class binder1st : public unary_function</div><div class="line">                  &lt;typename Op::second_argument_type,</div><div class="line">                   typename Op::result_type&gt;</div><div class="line">&#123;</div><div class="line">   Op op_;</div><div class="line">   typename Op::first_argument_type first_arg_;</div><div class="line"> </div><div class="line">   public:</div><div class="line">      binder1st(const Op&amp; op,</div><div class="line">                const typename Op::first_argument_type&amp;</div><div class="line">                first_arg) : op_(op),</div><div class="line">               first_arg_(first_arg) &#123;&#125;</div><div class="line"> </div><div class="line">   typename Op::result_type operator()</div><div class="line">      (const typename Op::second_argument_type&amp; arg) const</div><div class="line">   &#123;</div><div class="line">      return op_(first_arg_, arg);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;class Op, class Arg&gt;</div><div class="line">inline binder1st&lt;Op&gt; bind1st(const Op&amp; op,</div><div class="line">                             const Arg&amp; arg)</div><div class="line">&#123;</div><div class="line">   return binder1st&lt;Op&gt;(op, arg);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// bind2nd</div><div class="line">template&lt;class Op&gt;</div><div class="line">class binder2nd : public unary_function</div><div class="line">   &lt;typename Op::first_argument_type,</div><div class="line">    typename Op::result_type&gt;</div><div class="line">&#123;</div><div class="line">   Op op_;</div><div class="line">   typename Op::second_argument_type second_arg_;</div><div class="line"> </div><div class="line">   public:</div><div class="line">      binder2nd(const Op&amp; op,</div><div class="line">                const typename Op::second_argument_type&amp;</div><div class="line">                                   second_arg) : op_(op),</div><div class="line">                                   second_arg_(second_arg) &#123;&#125;</div><div class="line"> </div><div class="line">   typename Op::result_type operator()(const typename</div><div class="line">      Op::argument_type&amp; arg) const</div><div class="line">   &#123;</div><div class="line">      return op_(arg, second_arg_);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;class Op, class Arg&gt;</div><div class="line">inline binder2nd&lt;Op&gt; bind2nd(const Op&amp; op,</div><div class="line">                             const Arg&amp; arg)</div><div class="line">&#123;</div><div class="line">   return binder2nd&lt;Op&gt;(op, arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Negaters"><a href="#Negaters" class="headerlink" title="Negaters"></a>Negaters</h2><p>Negater是针对Predicate设计的，它简单的将Predicate的返回值取反。有两个Negater，not1和not2，分别对一元和二元Predicate取反。</p>
<h2 id="Member-Function-Adapters"><a href="#Member-Function-Adapters" class="headerlink" title="Member Function Adapters"></a>Member Function Adapters</h2><p>有时候，你可能想让算法调用容器元素的成员函数，而不是外部函数。因为外部无法改变对象内的状态，且内部函数通常具有更高的效率。例如swap(string, string)总是没有string.swap(string)快速。又比如sort无法对list进行排序，这时候只能使用list.sort()来给链表排序。这时候就需要使用一定的方法将对象内部的函数“变成”函数对象，这样的函数对象叫做成员函数适配器，其实前面的binder也是一种适配器。看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">int</div><div class="line">main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    vector&lt;list&lt;int&gt; &gt; v;</div><div class="line">    v.push_back(list&lt;int&gt;());</div><div class="line">    vector&lt;list&lt;int&gt; &gt;::iterator it;</div><div class="line">    for(it = v.begin(); it != v.end(); ++it)</div><div class="line">    &#123;</div><div class="line">        for(int i = 0; i &lt; 20; ++i)</div><div class="line">        &#123;</div><div class="line">            (*it).insert((*it).begin(), i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for_each(v.begin(), v.end(), std::mem_fun_ref(&amp;list&lt;int&gt;::sort));</div><div class="line">    for(it = v.begin(); it != v.end(); ++it)</div><div class="line">    &#123;</div><div class="line">        for(list&lt;int&gt;::iterator lt; lt != (*it).end(); ++lt)</div><div class="line">        &#123;</div><div class="line">            std::cout&lt;&lt;*lt&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子中，遍历vector<list<int> &gt;并对链表进行排序。其中使用的是成员函数适配器mem_fun_ref，它返回的函数对象会以list<int>对象的引用为参数。另外一个mem_fun则是以指向list<int>对象的指针为参数。</int></int></list<int></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二叉树中和为某一值的路径]]></title>
      <url>http://blog.acbingo.cn/2016/07/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>剑指offer上第25题:<br>输入一颗二叉树和一个整数,打印出二叉树中节点值的和为输入整数的所有路径.<br>题目比较绕，下面给个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     10</div><div class="line">    /  \</div><div class="line">   5   12    </div><div class="line"> /  \</div><div class="line">4   7</div></pre></td></tr></table></figure></p>
<p>可见此二叉树和为22的路径有两条:<br>10,5,7 和 10,12</p>
<p>书上给出的代码看着就心烦，哪用这么麻烦呀.<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>就一个普通回溯水题.= =越来越感觉这本书上的题都好简单啊，比ACM简单太多了</p>
<p>采用前序遍历遍历整条树,用一个全局变量和一个stack记录遍历到该节点路径和，然后回溯的时候再删掉就行了。<br>但是，输出的时候要倒序输出介个栈呀，stack是个适配器，没有iterator.所以我们这个里采用deque实现。(其实stack,是通过简单地修饰线性类deque的接口而获得的另一种“容器类”，往往被归结为配接器（adapter）而不是容器（container），同理，queue也是)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">struct BinaryTreeNode &#123;</div><div class="line">	int m_value;</div><div class="line">	BinaryTreeNode* m_left;</div><div class="line">	BinaryTreeNode* m_right;</div><div class="line">	BinaryTreeNode(int t, BinaryTreeNode* l, BinaryTreeNode* r) :m_value(t), m_left(l), m_right(r) &#123;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">int cnt=0; int target=22;</div><div class="line">deque&lt;int&gt; s;</div><div class="line">void print() &#123;</div><div class="line">	deque&lt;int&gt;::iterator it;</div><div class="line">	it = s.end() - 1;</div><div class="line">	while (it != s.begin()) &#123;</div><div class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</div><div class="line">		it--;</div><div class="line">	&#125;</div><div class="line">	cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</div><div class="line">	cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">void findPath(BinaryTreeNode* nowNode) &#123;</div><div class="line">	if (nowNode == NULL) return;</div><div class="line">	if (cnt == target) &#123;</div><div class="line">		print();</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	if (nowNode-&gt;m_left) &#123;</div><div class="line">		cnt += nowNode-&gt;m_left-&gt;m_value;</div><div class="line">		s.push_front(nowNode-&gt;m_left-&gt;m_value);</div><div class="line">		findPath(nowNode-&gt;m_left);</div><div class="line">		cnt -= nowNode-&gt;m_left-&gt;m_value;</div><div class="line">		s.pop_front();</div><div class="line">	&#125;</div><div class="line">	if (nowNode-&gt;m_right) &#123;</div><div class="line">		cnt += nowNode-&gt;m_right-&gt;m_value;</div><div class="line">		s.push_front(nowNode-&gt;m_right-&gt;m_value);</div><div class="line">		findPath(nowNode-&gt;m_right);</div><div class="line">		cnt -= nowNode-&gt;m_right-&gt;m_value;</div><div class="line">		s.pop_front();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	BinaryTreeNode* p5 = new BinaryTreeNode(7, NULL, NULL);</div><div class="line">	BinaryTreeNode* p4 = new BinaryTreeNode(4, NULL, NULL);</div><div class="line">	BinaryTreeNode* p3 = new BinaryTreeNode(12, NULL, NULL);</div><div class="line">	BinaryTreeNode* p2 = new BinaryTreeNode(5, p4, p5);</div><div class="line">	BinaryTreeNode* p1 = new BinaryTreeNode(10, p2, p3);</div><div class="line"></div><div class="line">	s.push_front(p1-&gt;m_value);</div><div class="line">	cnt += p1-&gt;m_value;</div><div class="line">	findPath(p1);</div><div class="line"></div><div class="line">	cout &lt;&lt; endl;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[递归实现反转链表]]></title>
      <url>http://blog.acbingo.cn/2016/07/26/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>剑指offer反转链表一题，课本上给出了循环的答案，课后扩展提出可否用递归实现一下。闲着没事就敲了一下<br><a id="more"></a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>没什么可说的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">struct ListNode &#123;</div><div class="line">	int m_nkey;</div><div class="line">	ListNode* m_pNext;</div><div class="line">	ListNode() &#123;&#125;;</div><div class="line">	ListNode(int k, ListNode* next):m_nkey(k),m_pNext(next) &#123;&#125;</div><div class="line">&#125;;</div><div class="line">ListNode* pHead = new ListNode();</div><div class="line">void ReverseListByRecursion(ListNode* now, ListNode* last) &#123;</div><div class="line">	if (now == NULL) return;</div><div class="line">	ReverseListByRecursion(now-&gt;m_pNext, now);</div><div class="line">	if (now-&gt;m_pNext == NULL) pHead = now;</div><div class="line">	now-&gt;m_pNext = last;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	ListNode* p;</div><div class="line"></div><div class="line">	ListNode* p3 = new ListNode(3, NULL);</div><div class="line">	ListNode* p2 = new ListNode(2, p3);</div><div class="line">	ListNode* p1 = new ListNode(1, p2);</div><div class="line">	ListNode* pH = new ListNode(0, p1);</div><div class="line"></div><div class="line">	cout &lt;&lt; &quot;The origin list is:&quot; &lt;&lt; endl;</div><div class="line">	p = pH;</div><div class="line">	while (p != NULL) &#123;</div><div class="line">		cout &lt;&lt; p-&gt;m_nkey &lt;&lt; &quot; &quot;;</div><div class="line">		p = p-&gt;m_pNext;</div><div class="line">	&#125;</div><div class="line">	cout &lt;&lt; endl;</div><div class="line"></div><div class="line">	ReverseListByRecursion(pH-&gt;m_pNext, pH);</div><div class="line"></div><div class="line">	pH-&gt;m_pNext = NULL;</div><div class="line"></div><div class="line">	cout &lt;&lt; &quot;The ReverserList is:&quot; &lt;&lt; endl;</div><div class="line">	p = pHead;</div><div class="line">	while (p != NULL) &#123;</div><div class="line">		cout &lt;&lt; p-&gt;m_nkey &lt;&lt; &quot; &quot;;</div><div class="line">		p = p-&gt;m_pNext;</div><div class="line">	&#125;</div><div class="line">	cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    delete pH;</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[快速幂]]></title>
      <url>http://blog.acbingo.cn/2016/07/26/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>位运算的另外一种应用，快速幂<br><a id="more"></a></p>
<blockquote>
<p>快速幂顾名思义，就是快速算某个数的多少次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。</p>
</blockquote>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>以下以求a的b次方来介绍[1]<br>把b转换成二进制数。<br>该二进制数第i位的权为<br>例如<br><img src="http://h.hiphotos.baidu.com/baike/s%3D103/sign=885b42e39c16fdfadc6cc2ee878d8cea/d0c8a786c9177f3e48bd45c571cf3bc79e3d5668.jpg" alt=""></p>
<p>11的二进制是1011<br>11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1<br>因此，我们将a¹¹转化为算<br><img src="http://d.hiphotos.baidu.com/baike/s%3D95/sign=257afe75a8773912c0268964f919a226/e850352ac65c1038803a760ab3119313b17e89b6.jpg" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int pow(int a,int b)</div><div class="line">&#123;</div><div class="line">    int r=1,base=a;</div><div class="line">    while(b!=0)</div><div class="line">    &#123;</div><div class="line">        if(b&amp;1)</div><div class="line">            r*=base;</div><div class="line">        base*=base;</div><div class="line">        b&gt;&gt;=1;</div><div class="line">    &#125;</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bitset的用法]]></title>
      <url>http://blog.acbingo.cn/2016/07/26/bitset%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>std::bitset是STL的一个模板类。用来方便地管理一系列的bit位而不用程序员自己来写代码。<br>bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。</p>
<hr>
<p>在剑指offer上看到一个题，要统计二进制1的个数，瞬间就想起来这个东西了，三行代码搞定~<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;bitset&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	while (cin &gt;&gt; n) &#123;</div><div class="line">		bitset&lt;32&gt; b(n);</div><div class="line">		cout &lt;&lt; b.count() &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这么做是不完全对的。<br>当n小于0的时候呢?<br>实际上bitset<n> b(u);  u接受的是unsigned long 类型,也就是说，你输入-1，会先隐性转换成unsigned long,那就-1就会变成2^31-1了，bitset数组就会变成一堆1了</n></p>
<p>那么，应该把代码改成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	while (cin &gt;&gt; n) &#123;</div><div class="line">		if (n &lt; 0) &#123;</div><div class="line">			n = -n;</div><div class="line">			bitset&lt;32&gt; b(n);</div><div class="line">			cout &lt;&lt; b.count()+1 &lt;&lt; endl;</div><div class="line">			b.set(b.size() - 1);</div><div class="line">			cout &lt;&lt; b &lt;&lt; endl;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			bitset&lt;32&gt; b(n);</div><div class="line">			cout &lt;&lt; b.count() &lt;&lt; endl;</div><div class="line">			cout &lt;&lt; b &lt;&lt; endl;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以用位运算统计1出现的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">while (n)</div><div class="line">&#123;</div><div class="line">    ++ count;</div><div class="line">    n = (n-1) &amp;n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>顺便记录下bitset的常用的用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">初始化bitset对象的方法</div><div class="line"></div><div class="line">bitset&lt;n&gt; b;</div><div class="line"></div><div class="line">b有n位，每位都为0</div><div class="line"></div><div class="line">bitset&lt;n&gt; b(u);</div><div class="line"></div><div class="line">b是unsigned long型u的一个副本</div><div class="line"></div><div class="line">bitset&lt;n&gt; b(s);</div><div class="line"></div><div class="line">b是string对象s中含有的位串的副本</div><div class="line"></div><div class="line">bitset&lt;n&gt; b(s, pos, n);</div><div class="line"></div><div class="line">b是s中从位置pos开始的n个位的副本</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">b.any()</div><div class="line"></div><div class="line">b中是否存在置为1的二进制位？</div><div class="line"></div><div class="line">b.none()</div><div class="line"></div><div class="line">b中不存在置为1的二进制位吗？</div><div class="line"></div><div class="line">b.count()</div><div class="line"></div><div class="line">b中置为1的二进制位的个数</div><div class="line"></div><div class="line">b.size()</div><div class="line"></div><div class="line">b中二进制位的个数</div><div class="line"></div><div class="line">b[pos]</div><div class="line"></div><div class="line">访问b中在pos处的二进制位</div><div class="line"></div><div class="line">b.test(pos)</div><div class="line"></div><div class="line">b中在pos处的二进制位是否为1？</div><div class="line"></div><div class="line">b.set()</div><div class="line"></div><div class="line">把b中所有二进制位都置为1</div><div class="line"></div><div class="line">b.set(pos)</div><div class="line"></div><div class="line">把b中在pos处的二进制位置为1</div><div class="line"></div><div class="line">b.reset()</div><div class="line"></div><div class="line">把b中所有二进制位都置为0</div><div class="line"></div><div class="line">b.reset(pos)</div><div class="line"></div><div class="line">把b中在pos处的二进制位置为0</div><div class="line"></div><div class="line">b.flip()</div><div class="line"></div><div class="line">把b中所有二进制位逐位取反</div><div class="line"></div><div class="line">b.flip(pos)</div><div class="line"></div><div class="line">把b中在pos处的二进制位取反</div><div class="line"></div><div class="line">b.to_ulong()</div><div class="line"></div><div class="line">用b中同样的二进制位返回一个unsigned long值</div><div class="line"></div><div class="line">os &lt;&lt; b</div><div class="line"></div><div class="line">把b中的位集输出到os流</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二分查找、归并排序和快速排序]]></title>
      <url>http://blog.acbingo.cn/2016/07/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>书上说这三种算法必须做到随时正确、完整的写出它们的代码.所以我来试一试<br><a id="more"></a></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T binary_search(T* a, int n,T target) &#123;//a[0..n)</div><div class="line">	int l = 0, r = n;</div><div class="line">	while (l &lt; r) &#123;</div><div class="line">		int m = (r - l) / 2 + l;</div><div class="line">		if (target == a[m])</div><div class="line">			return m;</div><div class="line">		if (target &gt; a[m]) &#123;</div><div class="line">			l = m + 1;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			r = m;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void merge(int*a, int l, int m, int r, int* tmp) &#123;</div><div class="line">	int i = l, j = m, k = 0;</div><div class="line">	while (i &lt; m&amp;&amp;j &lt; r) &#123;</div><div class="line">		if (a[i] &lt; a[j])</div><div class="line">			tmp[k++] = a[i++];</div><div class="line">		else</div><div class="line">			tmp[k++] = a[j++];</div><div class="line">	&#125;</div><div class="line">	while (i &lt; m) &#123;</div><div class="line">		tmp[k++] = a[i++];</div><div class="line">	&#125;</div><div class="line">	while (j &lt; r) &#123;</div><div class="line">		tmp[k++] = a[j++];</div><div class="line">	&#125;</div><div class="line">	for (int i = 0; i &lt; k; i++) &#123;</div><div class="line">		a[l + i] = tmp[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void mergesort(int*a,int l, int r,int* tmp) &#123;//a[l..r)</div><div class="line">	if (r - 1 == l) return;//当分成只剩一个元素的时候停止递归</div><div class="line">	int m = (r - l) / 2 + l;//避免(r+l)/2会溢出</div><div class="line">	mergesort(a, l, m, tmp);</div><div class="line">	mergesort(a, m, r, tmp);</div><div class="line">	merge(a, l, m, r, tmp);</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int* tmp = new int[n];</div><div class="line">    mergesort(a,0,n,tmp);</div><div class="line">    delete[] tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tmp数组是个辅助数组,是必须的</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">void quicksort(T* a, int l, int r) &#123;//a[l..r]</div><div class="line">	if (l &lt; r) &#123;</div><div class="line">		int key = a[l];</div><div class="line">		int low = l;</div><div class="line">		int high = r;</div><div class="line">		while (low &lt; high) &#123;</div><div class="line">			while (low&lt;high&amp;&amp;a[high]&gt;key) high--;</div><div class="line">			a[low] = a[high];</div><div class="line">			while (low &lt; high&amp;&amp;a[low] &lt; key) low++;</div><div class="line">			a[high] = a[low];</div><div class="line">		&#125;</div><div class="line">		a[low] = key;</div><div class="line">		quicksort(a, l, low - 1);</div><div class="line">		quicksort(a, low + 1, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重建二叉树]]></title>
      <url>http://blog.acbingo.cn/2016/07/25/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>给出二叉树的前序遍历和中序遍历,重建二叉树并输出后续遍历<br><a id="more"></a><br>今天看剑指offer看到的一个题,顺便来实现一下</p>
<p>考察对递归的理解吧,蛮简单的,思路就不说了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">struct BinaryTreeNode &#123;</div><div class="line">	int m_nValue;</div><div class="line">	BinaryTreeNode* m_pLeft;</div><div class="line">	BinaryTreeNode* m_pRight;</div><div class="line">	BinaryTreeNode(int tmp, BinaryTreeNode* l, BinaryTreeNode* r) &#123;</div><div class="line">		m_nValue = tmp;</div><div class="line">		m_pLeft = l;</div><div class="line">		m_pRight = r;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">string s1, s2;</div><div class="line">BinaryTreeNode* ConstructCore(int i, int j, int p, int q) &#123;</div><div class="line">	if (i &gt;= j) return NULL;</div><div class="line">	int tmp = s2.find(s1[i]);</div><div class="line">	int len = tmp - p;</div><div class="line">	int len2 = q - tmp - 1;</div><div class="line">	string ts1 = s1.substr(i, len);</div><div class="line">	string ts2 = s1.substr(p, len2);</div><div class="line">	BinaryTreeNode* root = new BinaryTreeNode(</div><div class="line">		s1[i],</div><div class="line">		ConstructCore(i + 1, i + 1 + len, p, p + len),</div><div class="line">		ConstructCore(i + len + 1, j, p + len + 1, q)</div><div class="line">		);</div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line">BinaryTreeNode* Construct() &#123;</div><div class="line">	int j = s1.size();</div><div class="line">	int p = 0;</div><div class="line">	int q = s2.size();</div><div class="line">	int i = 0;</div><div class="line">	int tmp = s2.find(s1[i]);</div><div class="line">	int len = tmp - p;</div><div class="line">	int len2 = q - tmp - 1;</div><div class="line">	BinaryTreeNode* root = new BinaryTreeNode(</div><div class="line">		s1[i],</div><div class="line">		root-&gt;m_pLeft = ConstructCore(i + 1, i + 1 + len, p, p + len),</div><div class="line">    	root-&gt;m_pRight = ConstructCore(i + len + 1, j, p + len + 1, q)</div><div class="line">		);</div><div class="line"></div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line">void print(BinaryTreeNode* root) &#123;</div><div class="line">	if (root == NULL) return;</div><div class="line">	printPre(root-&gt;m_pLeft);</div><div class="line">	printPre(root-&gt;m_pRight);</div><div class="line">    cout &lt;&lt; (char)root-&gt;m_nValue;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	s1 = &quot;12473568&quot;;</div><div class="line">	s2 = &quot;47215386&quot;;</div><div class="line"></div><div class="line">	BinaryTreeNode *head = Construct();</div><div class="line"></div><div class="line">	print(head);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode_5:Longest Palindromic Substring]]></title>
      <url>http://blog.acbingo.cn/2016/07/25/leetcode_5/</url>
      <content type="html"><![CDATA[<p>find the longest palindromic substring in S.<br>讨论了O(n2)的朴素算法,O(nlogn)的kmp扩展算法,O(n)的Manacher算法<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="external">Longest Palindromic Substring</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>例外的，这篇文章先给出参考，leetcode某位国外大神写的两篇很详细的文章,质量相当的高啊(比国内博客好的不是一点半点= =):<br><a href="http://articles.leetcode.com/longest-palindromic-substring-part-i" target="_blank" rel="external">Longest Palindromic Substring Part I</a><br><a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii" target="_blank" rel="external">Longest Palindromic Substring Part II</a></p>
<p>文章比较长，但是强烈建议仔细读一下.</p>
<h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><p>O(n3)<br>暴力找，我就不想再多说了= =</p>
<h1 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h1><p>枚举中点，然后向两边扩展，时间复杂度是O(n2)</p>
<p>但是有一点需要注意的是，回文的情况可能是 a b a，也可能是 a b b a。<br>还得分奇偶性分别判断,恶心死了</p>
<p>可以通过在两个字符之间插入一个#，然后让整个字符串变为奇数。<br>即:aba  -&gt;  #a#b#a#<br>   abba -&gt;  #a#b#b#a#<br>这样处理起来不就统一啦,一番分析后发现,最后的真实长度就是(L-1)/2。</p>
<p>代码就不写了.</p>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>时间和空间复杂度都为O(n2)<br>定义p[i,j],若Si..Sj是回文串,为true否则为false<br>那么转移方程就是:P[ i, j ] ← ( P[ i+1, j-1 ] and Si = Sj )</p>
<p>初始值为:<br>P[ i, i ] ← true<br>P[ i, i+1 ] ← ( Si = Si+1 )</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>直接贴参考文章中的代码吧，写的挺好的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">string longestPalindromeDP(string s) &#123;</div><div class="line">  int n = s.length();</div><div class="line">  int longestBegin = 0;</div><div class="line">  int maxLen = 1;</div><div class="line">  bool table[1000][1000] = &#123;false&#125;;</div><div class="line">  for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">    table[i][i] = true;</div><div class="line">  &#125;</div><div class="line">  for (int i = 0; i &lt; n-1; i++) &#123;</div><div class="line">    if (s[i] == s[i+1]) &#123;</div><div class="line">      table[i][i+1] = true;</div><div class="line">      longestBegin = i;</div><div class="line">      maxLen = 2;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  for (int len = 3; len &lt;= n; len++) &#123;</div><div class="line">    for (int i = 0; i &lt; n-len+1; i++) &#123;</div><div class="line">      int j = i+len-1;</div><div class="line">      if (s[i] == s[j] &amp;&amp; table[i+1][j-1]) &#123;</div><div class="line">        table[i][j] = true;</div><div class="line">        longestBegin = i;</div><div class="line">        maxLen = len;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return s.substr(longestBegin, maxLen);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h1><p>时间复杂度为O(N*logN)<br>比较复杂..如果你有兴趣的话:(Longest Palindromic Substring)(<a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank" rel="external">https://en.wikipedia.org/wiki/Longest_palindromic_substring</a>)</p>
<h1 id="KMP扩展"><a href="#KMP扩展" class="headerlink" title="KMP扩展"></a>KMP扩展</h1><p>时间复杂度为O(N*logN).<br>KMP算法一直是我头疼的地方，每次都是看懂了后过段时间就忘= =，所以每次碰到字符串处理的问题我就害怕。。</p>
<p>不过求一个简简单单的回文串，还得动用KMP?下面有更优的算法</p>
<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>正如原文中所说:</p>
<blockquote>
<p>Does an O(N) solution exist? You bet! However, it is not trivial and requires some very clever observation. </p>
</blockquote>
<p>这个算法一般人真是看不出来啊= =</p>
<p>原文讲的很清楚了:<a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii" target="_blank" rel="external">Manacher算法</a>,我就不啰嗦了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">// Transform S into T.</div><div class="line">// For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.</div><div class="line">// ^ and $ signs are sentinels appended to each end to avoid bounds checking</div><div class="line">string preProcess(string s) &#123;</div><div class="line">  int n = s.length();</div><div class="line">  if (n == 0) return &quot;^$&quot;;</div><div class="line">  string ret = &quot;^&quot;;</div><div class="line">  for (int i = 0; i &lt; n; i++)</div><div class="line">    ret += &quot;#&quot; + s.substr(i, 1);</div><div class="line"></div><div class="line">  ret += &quot;#$&quot;;</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">string longestPalindrome(string s) &#123;</div><div class="line">  string T = preProcess(s);</div><div class="line">  int n = T.length();</div><div class="line">  int *P = new int[n];</div><div class="line">  int C = 0, R = 0;</div><div class="line">  for (int i = 1; i &lt; n-1; i++) &#123;</div><div class="line">    int i_mirror = 2*C-i; // equals to i&apos; = C - (i-C)</div><div class="line">    </div><div class="line">    P[i] = (R &gt; i) ? min(R-i, P[i_mirror]) : 0;</div><div class="line">    </div><div class="line">    // Attempt to expand palindrome centered at i</div><div class="line">    while (T[i + 1 + P[i]] == T[i - 1 - P[i]])</div><div class="line">      P[i]++;</div><div class="line"></div><div class="line">    // If palindrome centered at i expand past R,</div><div class="line">    // adjust center based on expanded palindrome.</div><div class="line">    if (i + P[i] &gt; R) &#123;</div><div class="line">      C = i;</div><div class="line">      R = i + P[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Find the maximum element in P.</div><div class="line">  int maxLen = 0;</div><div class="line">  int centerIndex = 0;</div><div class="line">  for (int i = 1; i &lt; n-1; i++) &#123;</div><div class="line">    if (P[i] &gt; maxLen) &#123;</div><div class="line">      maxLen = P[i];</div><div class="line">      centerIndex = i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  delete[] P;</div><div class="line">  </div><div class="line">  return s.substr((centerIndex - 1 - maxLen)/2, maxLen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode_4:Median of Two Sorted Arrays]]></title>
      <url>http://blog.acbingo.cn/2016/07/24/leetcode_4/</url>
      <content type="html"><![CDATA[<p>给出两个有序数组，找中间位置的那个数，要求O(m+n)复杂度<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">Median of Two Sorted Arrays</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始都没读懂题= =</p>
<p>利用类似于归并排序的思想可以在O(m+n)复杂度下解决.</p>
<p>既:每次数最小的一个数，直到数到第(m+n)/2个数。<br>其实时间复杂度应该是O((m+n)/2)</p>
<p>网上大部分人都在讨论该题是经典的寻找第K小的数问题。。不明觉厉，还有比这更优的算法？</p>
<p>明天去研究一下</p>
<hr>
<p>update<br>果然有O(logk)复杂度的算法</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">	double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class="line">		int n = nums1.size(); int m = nums2.size();</div><div class="line">		int i = 0, j = 0, k = 0;</div><div class="line">		int d = (m + n) % 2 == 1 ? (m + n) / 2 + 1 : (m + n) / 2;</div><div class="line">		 int x;</div><div class="line">		while (true) &#123;</div><div class="line">			if (i &gt;= n) x = nums2[j++];</div><div class="line">			else if (j &gt;= m) x = nums1[i++];</div><div class="line">			else x = nums1[i]&lt;nums2[j] ? nums1[i++] : nums2[j++];</div><div class="line">			k++;</div><div class="line">			if (d == k) break;</div><div class="line">		&#125;</div><div class="line">		if ((m + n) % 2 == 1) return x;</div><div class="line">		else &#123;</div><div class="line">			int y = x;</div><div class="line">			if (i &gt;= n) x = nums2[j++];</div><div class="line">			else if (j &gt;= m) x = nums1[i++];</div><div class="line">			else x = nums1[i]&lt;nums2[j] ? nums1[i++] : nums2[j++];</div><div class="line">			return (x + y) / 2.0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><hr>
<p>update</p>
<blockquote>
<p>接下来我们考虑有没有优化的算法。优化的思想来源于order statistics，在算法导论10.3节中提到。问题等价于求两个array的第k=(m+n)/2（假设m和n分别是两个数组的元素个数）大的数是多少。基本思路是每次通过查看两个数组的第k/2大的数(假设是A[k/2],B[k/2])，如果两个A[k/2]=B[k/2]，说明当前这个数即为两个数组剩余元素的第k大的数，如果A[k/2]&gt;B[k/2], 那么说明B的前k/2个元素都不是我们要的第k大的数，反之则排除A的前k/2个，如此每次可以排除k/2个元素，最终k=1时即为结果。总的时间复杂度为O(logk),空间复杂度也是O(logk)，即为递归栈大小。在这个题目中因为k=(m+n)/2,所以复杂度是O(log(m+n))。比起第一种解法有明显的提高，代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public double findMedianSortedArrays(int A[], int B[]) &#123;</div><div class="line">    if((A.length+B.length)%2==1)</div><div class="line">        return helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2+1);</div><div class="line">    else</div><div class="line">        return (helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2)  </div><div class="line">               +helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2+1))/2.0;</div><div class="line">&#125;</div><div class="line">private int helper(int A[], int B[], int i, int i2, int j, int j2, int k)</div><div class="line">&#123;</div><div class="line">    int m = i2-i+1;</div><div class="line">    int n = j2-j+1;</div><div class="line">    if(m&gt;n)</div><div class="line">        return helper(B,A,j,j2,i,i2,k);</div><div class="line">    if(m==0)</div><div class="line">        return B[j+k-1];</div><div class="line">    if(k==1)</div><div class="line">        return Math.min(A[i],B[j]);</div><div class="line">    int posA = Math.min(k/2,m);</div><div class="line">    int posB = k-posA;</div><div class="line">    if(A[i+posA-1]==B[j+posB-1])</div><div class="line">        return A[i+posA-1];</div><div class="line">    else if(A[i+posA-1]&lt;B[j+posB-1])</div><div class="line">        return helper(A,B,i+posA,i2,j,j+posB-1,k-posA);</div><div class="line">    else</div><div class="line">        return helper(A,B,i,i+posA-1,j+posB,j2,k-posB);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考自<a href="http://blog.csdn.net/linhuanmars/article/details/19905515" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>实现中还是有些细节要注意的，比如有时候剩下的数不足k/2个，那么就得剩下的，而另一个数组则需要多取一些数。但是由于这种情况发生的时候，不是把一个数组全部读完，就是可以切除k/2个数，所以不会影响算法的复杂度。<br>这道题的优化算法主要是由order statistics派生而来，原型应该是求topK的算法，这个问题是非常经典的问题，一般有两种解法，一种是用quick select(快速排序的subroutine),另一种是用heap。 复杂度是差不多的，有兴趣可以搜一下，网上资料很多，topK问题在海量数据处理中也是一个非常经典的问题，所以还是要重视。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode_3:Longest Substring Without Repeating Characters]]></title>
      <url>http://blog.acbingo.cn/2016/07/24/leetcode_3/</url>
      <content type="html"><![CDATA[<p>字符串处理水题，结合HashMap即可.<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>其实就是找符合条件的最长连续子串,该子串不允许有重复元素</p>
<p>O(n3)的纯暴力就不说了= =</p>
<p>O(n)才是王道：<br>设置一个标记left,left指向当前子串的最左位置,substring len 就是 now_ponit - left_point + 1.hashMap[s[i]]存的是上一个s[i]出现的坐标值<br>now_ponit每向右走一步，那么就判断当前元素s[now_ponit]是否出现在hashMap中,若出现过，要将hashMap中s[left]到s[now_ponit]<br>删除,然后更新left为hashMap[s[now_ponit]]</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">	int lengthOfLongestSubstring(string s) &#123;</div><div class="line">		unordered_map&lt;char, int&gt; hashMap;</div><div class="line">		int ans = 0;</div><div class="line">		int l = 0;</div><div class="line">		for (int i = 0; i&lt;s.size(); i++) &#123;</div><div class="line">			if (hashMap.find(s[i]) != hashMap.end())&#123;</div><div class="line">				int k = hashMap[s[i]] + 1;</div><div class="line">				for (int j = l; j&lt;k; j++)</div><div class="line">					hashMap.erase(s[j]);</div><div class="line">				l = k;</div><div class="line">			&#125;</div><div class="line">			hashMap[s[i]] = i;</div><div class="line">			ans = (i - l + 1)&gt;ans ? (i - l + 1) : ans;</div><div class="line">		&#125;</div><div class="line">		ans = (s.size() - l )&gt;ans ? (s.size() - l ) : ans;</div><div class="line">		return ans;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode_2:Add Two Numbers]]></title>
      <url>http://blog.acbingo.cn/2016/07/24/leetcode_2/</url>
      <content type="html"><![CDATA[<p>实现两个链表的相加，要处理进位。题不难，但是需要考虑到的情况比较多。<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">Add Two Numbers</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题不难，但是需要考虑的情况蛮多的。其实就是处理进位的时候恶心死了。<br>建议做之前在纸上画清楚再code</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">	ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</div><div class="line">		ListNode* theNode = new ListNode(0);</div><div class="line">		ListNode* head = theNode;</div><div class="line">		int up = 0;</div><div class="line">		while (true) &#123;</div><div class="line">			theNode-&gt;val = (l1-&gt;val + l2-&gt;val + up) % 10;</div><div class="line">			up = (l1-&gt;val + l2-&gt;val +up) / 10;</div><div class="line">			if (l1-&gt;next == NULL&amp;&amp;l2-&gt;next == NULL) &#123;</div><div class="line">				if (up) theNode-&gt;next = new ListNode(up);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (l1-&gt;next == NULL) &#123;</div><div class="line">				l2 = l2-&gt;next;</div><div class="line">				theNode-&gt;next = l2;</div><div class="line">				while (true) &#123;</div><div class="line">					int tmp = l2-&gt;val;</div><div class="line">					l2-&gt;val = (tmp + up) % 10;</div><div class="line">					up = (tmp+up) / 10;</div><div class="line">					if (l2-&gt;next == NULL) break;</div><div class="line">					l2 = l2-&gt;next;</div><div class="line">				&#125;</div><div class="line">				if (up) &#123;</div><div class="line">					l2-&gt;next = new ListNode(up);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (l2-&gt;next == NULL) &#123;</div><div class="line">				l1 = l1-&gt;next;</div><div class="line">				theNode-&gt;next = l1;</div><div class="line">				while (true) &#123;</div><div class="line">					int tmp = l1-&gt;val;</div><div class="line">					l1-&gt;val = (tmp + up) % 10;</div><div class="line">					up = (tmp + up) / 10;</div><div class="line">					if (l1-&gt;next == NULL) break;</div><div class="line">					l1 = l1-&gt;next;</div><div class="line">				&#125;</div><div class="line">				if (up) &#123;</div><div class="line">					l1-&gt;next = new ListNode(up);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			ListNode* nextNode = new ListNode(0);</div><div class="line">			theNode-&gt;next = nextNode;</div><div class="line">			l1 = l1-&gt;next;</div><div class="line">			l2 = l2-&gt;next;</div><div class="line">			theNode = theNode-&gt;next;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return head;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode_1:Two Sum]]></title>
      <url>http://blog.acbingo.cn/2016/07/24/leetcode_1_Two%20Sum/</url>
      <content type="html"><![CDATA[<p>LeetCode的第一题,采用C++11的unordered_map解决<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">Two Sum</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>也就是说，是否存在 nums[i] + nums[j] = target.<br>普通的求法就是两层for循环,O(n方)复杂度，肯定不能接受</p>
<p>观察题目中说:</p>
<blockquote>
<p>You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>也就是说，只需要找到解就可以退出循环了。<br>那么就可以用HashMap可以实现O(n)复杂度。</p>
<p>但是，需要考虑到几个细节:</p>
<ol>
<li>如果nums:[0,4,3,0] target:0,怎么区分前后两个0呢？<br>其实根据解只存在一个的特点，对于nums<a href="也就是第二个0">3</a>,我们先判断target-nums[3]是否存在于hashMap中，若存在直接return输出了。不存在则再把nums[i]加入hashMap中(其实加不加都一样，因为解只存在一个，所以对于重复的节点更新到hashMap中对最终ans没有任何影响)。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">	vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">		unordered_map&lt;int,int&gt; hashMap;</div><div class="line">		vector&lt;int&gt; v;</div><div class="line">		for (int i = 0; i&lt;nums.size(); i++) &#123;</div><div class="line">			if (hashMap.find(target-nums[i])!=hashMap.end()) &#123;</div><div class="line">				v.push_back(hashMap[target - nums[i]]);</div><div class="line">				v.push_back(i);</div><div class="line">				return v;</div><div class="line">			&#125;</div><div class="line">			hashMap[nums[i]] = i;</div><div class="line">		&#125;</div><div class="line">		return v;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>这里用到了C++11的新标准:unordered_map</p>
<blockquote>
<p>unordered_map和map的不同是它是无序的，map的顺序就是按照operator&lt; 定义的大小排序。而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。<br>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者hash_value()了。</p>
</blockquote>
<p>具体怎么重载，等下次用的时候再研究吧= =</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bingo's_Shadowsocks]]></title>
      <url>http://blog.acbingo.cn/2016/06/07/Bingo's_ShadowSocks%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a><strong>番外</strong></h1><p>因为某种你知道的原因,科学上网在国内是被禁止的。所以请在使用本服务时低调一些，并<strong>尽量</strong>做到以下几点:</p>
<ol>
<li>不要在国内公共网站、论坛、贴吧等地方公布本站ss服务地址:ss.acbingo.cn。(你公布了,我的域名、ip、和国外服务器都有可能被封的= =)</li>
<li>建议使用Chrome浏览器</li>
<li>请清除<strong>CNNIC根证书</strong>,否则会被GFW盯上。<a href="http://www.dou-bi.com/cnnic-js1/" target="_blank" rel="external">详细介绍及清除方法</a></li>
<li><strong>严禁</strong>！！！在国外发布不当言论！包括反gong心理、诋毁或散播谣言等。</li>
<li>本服务仅为你开发、学习所用，<strong>请勿用于其它不当或违法行为</strong></li>
<li>保护个人隐私信息细节,尽可能远离国内网络平台和服务.尽量不使用360某卫视、腾讯某管家、百度某套餐、金山某某某等国内杀毒以及安全卫士<a id="more"></a>
</li>
</ol>
<h1 id="什么是Shadowsocks？"><a href="#什么是Shadowsocks？" class="headerlink" title="什么是Shadowsocks？"></a>什么是Shadowsocks？</h1><p>shadowsocks实质上是一种socks5代理服务，类似于ssh代理。与vpn的全局代理不同，shadowsocks仅针对<strong>浏览器代理</strong>，不能代理应用软件，比如youtube、twitter客户端软件。如果把vpn比喻为一把屠龙刀，那么shadowsocks就是一把瑞士军刀，轻巧方便，功能却非常强大。</p>
<h1 id="喜欢上Shadowsocks的理由"><a href="#喜欢上Shadowsocks的理由" class="headerlink" title="喜欢上Shadowsocks的理由?"></a>喜欢上Shadowsocks的理由?</h1><p>很多时候，我们仅仅只是需要上一下google，收个gmail邮件，或者打开某个网站瞄一眼看看有无更新。这种情况下，vpn可以做到吗，可以，但是很麻烦，连个vpn，qq也得掉一次线，有时候还连半天连不上。而通过ss的话呢，后台运行一个小程序，然后浏览器点击切换一下SS的网络，就可以了。不用的时候，再切回来。这也就是其轻巧的地方。</p>
<h1 id="支持的客户端"><a href="#支持的客户端" class="headerlink" title="支持的客户端"></a>支持的客户端</h1><p>OS X, Windows, Linux, iOS, Android, OpenWRT 路由器等</p>
<h1 id="如何使用Bingo-Shadowsocks服务"><a href="#如何使用Bingo-Shadowsocks服务" class="headerlink" title="如何使用Bingo_Shadowsocks服务"></a>如何使用Bingo_Shadowsocks服务</h1><h2 id="购买服务"><a href="#购买服务" class="headerlink" title="购买服务"></a>购买服务</h2><p>联系acbingo本人或者在本页评论区留言:我要买买买！或者邮件至tfuty@qq.com<br>支付宝转账成功后我会提供一个激活码</p>
<h2 id="注册自己的账号"><a href="#注册自己的账号" class="headerlink" title="注册自己的账号"></a>注册自己的账号</h2><p>登陆<a href="ss.acbingo.cn">ss.acbingo.cn</a>使用得到的激活码注册自己的账号.</p>
<h2 id="下载SS客户端"><a href="#下载SS客户端" class="headerlink" title="下载SS客户端"></a>下载SS客户端</h2><p><a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="external">下载ss客户端</a></p>
<p>下载对应版本的Shadowsocks，以下简称SS。</p>
<h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><p>下面以windows版为例简述使用过程:<br>打开<a href="http://ss.acbingo.cn" target="_blank" rel="external">ss.acbingo.cn</a>,点击用户中心登陆到后台界面.获取你个人的端口密码<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f4mvllnxfqj31890eodij.jpg" alt=""><br>然后获取节点地址和加密方式<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f4mvmwsrcoj30oa0ckabr.jpg" alt=""></p>
<p>打开shadowsocks程序<img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f4mv6igfgwj301c0113y9.jpg" alt=""><br>然后在系统任务栏找到SS图标,右键选择<strong>服务器</strong>-&gt;<strong>编辑服务器</strong><br>单机添加-&gt;然后在右侧的服务器IP一项输入节点地址-&gt;端口一项输入获得的端口-&gt;输入获得的密码-&gt;选择正确的加密方式-&gt;备注无需填写-&gt;代理端口不要修改</p>
<p>最后单击确定.</p>
<p>再次右键ss图标，单击:<strong>启动系统代理</strong>,系统代理模式<strong>启用PAC模式</strong></p>
<p>最后优化下paclist:<br>右键ss图标,PAC-&gt;从GFWlist更新本地PAC<br>（若更新失败，没关系，换个时间段更新就可以了。若发现某个网站上不去，就是说明该网站不在pac列表中，你更新下pac或者手动将该网站添加到paclist中即可）</p>
<p>至此，你应该就可以上网了~打开google测试一下吧~</p>
<p><strong>虽然目前网速仍然较慢（服务器我已经优化到极限了，而且我除了限制每个人每月50G初始流量外，其它不做任何限制，所以还慢就是你个人网络问题了），但是也足够你使用了</strong>，若你想获得更快的速度，本服务器支持FS加速</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li><strong>ss软件务必不要升级到3.0</strong></li>
<li>想到了再说</li>
</ol>
<h1 id="为何我的速度没有达到你广告中的速度"><a href="#为何我的速度没有达到你广告中的速度" class="headerlink" title="为何我的速度没有达到你广告中的速度"></a>为何我的速度没有达到你广告中的速度</h1><p>我购买的服务器是1000M的带宽，每台服务器只限制20~30个用户注册，绝对不像其它奸商一样超售！！<br>我广告中的截图全为真实截图(100M教育网环境下).不使用FS加速的话在上午低峰时期能到1500kbps~5000kbps(注意是kbps哦，折算成KB要除以8),下午晚上高峰时期能到800kbps~2000kbps.（下午和晚上国内到国际线路会发生拥堵所以才会导致速度降低，不是我优化的问题，因为我也没有办法）</p>
<p>使用FS加速的话至少能跑满你的运营商带宽的50%~100%！比如我的带宽是100M(教育网你懂的= =平时也就50~60M的样子)，在youbutu上跑出来20000kbps！</p>
<p>1000M的带宽，理论上分给每个用户的带宽至少有50M。<br>所以，为何你的速度没有达到我广告中的速度，应该和你本地（个人运营商网络）有关系，我也木有办法了，我花了很长时间已经把服务器优化到极致了</p>
<p>另外，傍晚时国际上线路用的人多，导致速度会下降，这是正常现象！不是我优化的问题！</p>
<h1 id="为啥打开个网页这么慢"><a href="#为啥打开个网页这么慢" class="headerlink" title="为啥打开个网页这么慢"></a>为啥打开个网页这么慢</h1><p>亲，服务器在洛杉矶，你ping一下节点看看，平均300ms（国内的网站平均都50ms以下）,这已经很好了。打开某个网页的瞬间要建立几百个点对点通信，所以当然会慢些喽，但是建立好连接后就快了。<br>这也就是为什么打开网页前几秒比较慢。</p>
<h1 id="FS加速"><a href="#FS加速" class="headerlink" title="FS加速"></a>FS加速</h1><p>本服务器支持FS加速。</p>
<p>FinalSpeed是一个双边加速软件，经过众多科学上网使用体验，加速效果很明显，但是也有缺点，比如：没有安卓/IOS客户端、流量太大服务端可能会崩溃、速度不稳定等问题。</p>
<p>所以，大家若不是非得要上youtube看1080p视频的话，<strong>强烈</strong>不建议大家使用</p>
<h2 id="如何使用FS加速服务"><a href="#如何使用FS加速服务" class="headerlink" title="如何使用FS加速服务"></a>如何使用FS加速服务</h2><p>我的截图中的网速是使用FS后的网速。明天我会把如何使用FS更新上来，略复杂</p>
<p><strong>因为开启FS加速服务，服务器端直接跑双倍流量，但是我的前端并不会检测到双倍流量（我还是会给你统计单倍的流量，吃亏的是我呀= =）</strong></p>
<p><strong>FS仅仅会在你看视频的时候你会感受到效果，平时浏览网页用不用没有区别，所以说不看视频的话尽量不要使用</strong></p>
<p><strong>经测试，如果多个人同时使用FS会严重影响到其它用户的网速，导致大家都慢。所以，为了自己，也为了别人，在不使用FS就可以满足自己正常上网的情况下，尽量不要使用FS</strong><br>（据说是FS作者没完全开发完成就被请去喝茶了= =导致各种bug）</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>客户端必须准确设置物理带宽，最终加速的速度不会超过所设置的带宽值，如果设置值高于实际带宽会造成丢包，导致速度变慢。<br>不知道自己的物理带宽去这测一下<a href="http://wangsuceshi.51240.com/" target="_blank" rel="external">测速</a>,建议多测几遍，尽量每一次使用fs的时候都测一遍。<br>然后记录下上行带宽和下行带宽.<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f4mz77g9srj30kj07iq4d.jpg" alt=""></li>
<li>客户端选择udp协议</li>
<li>地址填入你的节点地址</li>
<li>然后点击添加-&gt;名称:ss-&gt;加速端口:(你的个人端口)-&gt;本地端口:(2000-10000任意值)</li>
<li><strong>打开ss-&gt;编译服务器-&gt;添加-&gt;</strong><br>服务器器ip:127.0.0.1  服务器端口:（填你刚才填的本地端口） 密码:你的个人端口密码  加密:aes-256-cfb 备注:fs<br>然后点击确定，保存。</li>
<li>关闭FinalSpeed，关闭SS</li>
<li>先打开FinalSpeed，然后再打开SS，右键在服务器列表中选择fs。此时你应该发现FinalSpeed软件右下角显示连接成功,以后在使用的时候记得先打开FS，再打开SS哦</li>
<li>若你不使用FS,请把SS服务器切换到你最初配置的那个服务器。</li>
</ol>
<h1 id="如何让本地程序也可以翻墙"><a href="#如何让本地程序也可以翻墙" class="headerlink" title="如何让本地程序也可以翻墙"></a>如何让本地程序也可以翻墙</h1><p>shadowsocks实质上是一种socks5代理服务，类似于ssh代理。与vpn的全局代理不同，shadowsocks仅针对<strong>浏览器代理</strong>，不能代理应用软件。</p>
<p>所以，怎么才能代理应用软件呢？<br>//Todo</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何优雅的开启wifi热点]]></title>
      <url>http://blog.acbingo.cn/2016/05/03/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E5%90%AFwifi%E7%83%AD%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>利用反射通过代码开启wifi热点，监控热点的状态并更新UI<br><a id="more"></a></p>
<h1 id="如何开启热点"><a href="#如何开启热点" class="headerlink" title="如何开启热点"></a>如何开启热点</h1><p>官方把api给hide了，所以需要用到反射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//函数名必须是这个名字：setWifiApEnabled</div><div class="line">    public boolean setWifiApEnabled(boolean enabled)&#123;</div><div class="line">        if(enabled) &#123;</div><div class="line">            wifiManager.setWifiEnabled(false);</div><div class="line">            textView.append(&quot;正在打开热点\n&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            textView.append(&quot;正在关闭热点\n&quot;);</div><div class="line">        &#125;</div><div class="line">        try&#123;</div><div class="line">            WifiConfiguration apConfig = new WifiConfiguration();</div><div class="line">            apConfig.SSID = WifiHotContent.getWifiHotSSID();</div><div class="line">            apConfig.preSharedKey = WifiHotContent.getWifiHotPassword();</div><div class="line">            apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</div><div class="line">            Method method = wifiManager.getClass().getMethod(</div><div class="line">                    &quot;setWifiApEnabled&quot;, WifiConfiguration.class, Boolean.TYPE</div><div class="line">            );</div><div class="line">            return (Boolean) method.invoke(wifiManager, apConfig, enabled);</div><div class="line">        &#125; catch (Exception e)&#123;</div><div class="line">            //Todo 创建热点失败的相关信息</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们只需要指定三个元素就可以了：SSID,password,加密模式(不指定加密模式的话会导致密码不可用).<br>调用setWifiApEnabled(true)就是开启wifi热点，setWifiApEnabled(false)就是关闭wifi热点.</p>
<h1 id="监控wifi热点的状态"><a href="#监控wifi热点的状态" class="headerlink" title="监控wifi热点的状态"></a>监控wifi热点的状态</h1><p>同开启wifi一样，wifi热点的打开也是需要时间的，从开始创建一个wifi热点到热点的创建成功，会经历以下几个状态：</p>
<blockquote>
<p>WIFI_AP_STATE_DISABLED = 11<br>WIFI_AP_STATE_ENABLING = 12<br>WIFI_AP_STATE_ENABLED = 13</p>
</blockquote>
<p>也就是说，我们要监控wifi热点的状态，只需要分别这些值即可。<br>wifi的状态变化可以通过监听广播做到(见我的上一篇博客),热点的状态变化不发送广播，应该怎么做呢？</p>
<p>可以用轮询的方式来实现。开启一个线程，每隔一段时间询问下getWifiApState()，然后利用handler将apstate发送到ui线程</p>
<p>同样，getWifiApState()也需要用反射来调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public int getWifiApState(Context mContext) &#123;</div><div class="line">        WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);</div><div class="line">        try &#123;</div><div class="line">            Method method = wifiManager.getClass().getMethod(&quot;getWifiApState&quot;);</div><div class="line">            int i = (Integer) method.invoke(wifiManager);</div><div class="line">            return i;</div><div class="line">        &#125; catch (Exception e) &#123;    </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>完整代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    WifiManager wifiManager;</div><div class="line"></div><div class="line">    public Handler handler = new Handler()&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg)&#123;</div><div class="line">            switch (msg.what)&#123;</div><div class="line">                case 13:</div><div class="line">                    Log.d(&quot;mydebug&quot;,&quot;ap已经开启&quot;);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);</div><div class="line"></div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line"></div><div class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(MainActivity.this,WifiHotCreate.class));</div><div class="line">                new Thread(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        while (true)&#123;</div><div class="line">                            Log.d(&quot;mydebug&quot;,((Object)getWifiAPState()).toString());</div><div class="line">                            try &#123;Thread.sleep(500);&#125;catch (Exception e) &#123;&#125;</div><div class="line">                            if (getWifiAPState()==13) &#123;</div><div class="line">                                Log.d(&quot;mydebug&quot;,((Object)getWifiAPState()).toString());</div><div class="line">                                handler.sendEmptyMessage(getWifiAPState());</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    private int getWifiAPState() &#123;</div><div class="line">        int state = -1;</div><div class="line">        try &#123;</div><div class="line">            Method method2 = wifiManager.getClass().getMethod(&quot;getWifiApState&quot;);</div><div class="line">            state = (Integer) method2.invoke(wifiManager);</div><div class="line">        &#125; catch (Exception e) &#123;&#125;</div><div class="line">        //Log.d(&quot;WifiAP&quot;, &quot;getWifiAPState.state &quot; + (state==-1?&quot;UNKNOWN&quot;:WIFI_STATE_TEXTSTATE[state]));</div><div class="line">        return state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>附：wifiap的其它状态</p>
<blockquote>
<p>WIFI_AP_STATE_DISABLING = 10    WIFI热点正在关闭<br>WIFI_AP_STATE_DISABLED = 11    WIFI热点不可用<br>WIFI_AP_STATE_ENABLING = 12    WIFI热点正在打开<br>WIFI_AP_STATE_ENABLED = 13    WIFI热点可用<br>WIFI_AP_STATE_FAILED = 14   WIFI热点不可用</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何优雅的连接指定wifi热点]]></title>
      <url>http://blog.acbingo.cn/2016/05/02/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%8C%87%E5%AE%9Awifi%E7%83%AD%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>网上连接指定wifi热点的文章数不胜数，为啥我要再写一遍？</p>
<ol>
<li>网上的文章大部分用了一个类wifiadmin，我想说的是，你真的会用到这个类的全部函数么<br>换句话说，这个类写的简直跟坨屎样，特别难用.</li>
<li>网上大部分人都在暴力的处理wifi的各种逻辑，导致bug一大堆。把我这种小白给坑的啊= =</li>
<li>注意，是优雅的一键连接指定wifi，看似简单，其实背后要处理的逻辑一大堆。<a id="more"></a>
请先阅读我的上一篇文章:wifi状态的研究</li>
</ol>
<p>还是先上代码吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    WifiManager wifiManager;</div><div class="line">    private NetworkConnectChangedReceiver myBroadcastReceiver;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);</div><div class="line">        myBroadcastReceiver = new NetworkConnectChangedReceiver();//wifi 状态广播</div><div class="line"></div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        Button button2 = (Button) findViewById(R.id.button2);</div><div class="line"></div><div class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                startActivity(new Intent(MainActivity.this,WifiHotCreate.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        button2.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                IntentFilter filter = new IntentFilter();</div><div class="line">                if (wifiManager.isWifiEnabled())&#123;</div><div class="line">                    //Todo 提示用户将要断开wifi了</div><div class="line">                    wifiManager.setWifiEnabled(false);//断开wifi</div><div class="line">                    Log.d(&quot;mydebug&quot;,&quot;断开wifi&quot;);</div><div class="line">                    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);</div><div class="line">                    registerReceiver(myBroadcastReceiver, filter);</div><div class="line">                &#125;</div><div class="line">                else&#123;</div><div class="line">                    myConnectWifi();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void myConnectWifi()&#123;</div><div class="line">        //进入此函数，wifi目前肯定是关闭的</div><div class="line">        //打开wifi</div><div class="line">        wifiManager.setWifiEnabled(true);</div><div class="line">        IntentFilter filter = new IntentFilter();</div><div class="line">        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);</div><div class="line">        registerReceiver(myBroadcastReceiver, filter);</div><div class="line">    &#125;</div><div class="line">    public class NetworkConnectChangedReceiver extends BroadcastReceiver &#123;</div><div class="line">        @Override</div><div class="line">        public void onReceive(Context context, Intent intent)&#123;</div><div class="line">            if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction()))&#123;</div><div class="line">                int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0);</div><div class="line">                switch (wifiState)</div><div class="line">                &#123;</div><div class="line">                    case WifiManager.WIFI_STATE_ENABLED:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_ENABLED&quot;);</div><div class="line">                        //Todo 这里应该传正确的ssid和password</div><div class="line">                        unregisterReceiver(myBroadcastReceiver);</div><div class="line">                        WifiHotConnect.toConnectWifiHot(getBaseContext(),&quot;&quot;,&quot;&quot;);</div><div class="line">                        break;</div><div class="line">                    case WifiManager.WIFI_STATE_DISABLED:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_DISABLED&quot;);</div><div class="line">                        unregisterReceiver(myBroadcastReceiver);</div><div class="line">                        myConnectWifi();</div><div class="line">                        break;</div><div class="line">                   </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>点击button2后逻辑开始:<br>如果wifi是关闭状态，直接执行connectwifi()函数<br>如果wifi正在开启状态，那么我们需要先关闭wifi。(为啥不直接切换wifi，我不会= =，google了一小会也没找到相应的文章)<br>关闭wifi是需要过程的，所以我们关闭wifi后，监听.WIFI_STATE_CHANGED_ACTION的WIFI_STATE_DISABLED状态，监听到后说明此时wifi已经关闭<br><strong>注意此时需要取消注册掉监听器</strong>,然后执行connectWifi()函数</p>
<p>进入到connectWifi后的逻辑就类似了</p>
<p>另外，给出连接指定热点部分的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static Boolean toConnectWifiHot(Context context,String _ssid,String _password)&#123;</div><div class="line"></div><div class="line">        SSID = _ssid;Password =_password;</div><div class="line"></div><div class="line">        wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);</div><div class="line">        wifiManager.setWifiEnabled(true);</div><div class="line"></div><div class="line">        WifiConfiguration wifiConfiguration = setWiiParams();</div><div class="line">        int wcgID = wifiManager.addNetwork(wifiConfiguration);</div><div class="line">        boolean flag = wifiManager.enableNetwork(wcgID,false);</div><div class="line">        return flag;</div><div class="line">    &#125;</div><div class="line">    public static WifiConfiguration setWiiParams()&#123;</div><div class="line">        WifiConfiguration apConfig = new WifiConfiguration();</div><div class="line">        apConfig.SSID=&quot;\&quot;&quot;+SSID+&quot;\&quot;&quot;;</div><div class="line">        apConfig.preSharedKey=&quot;\&quot;&quot;+Password+&quot;\&quot;&quot;;</div><div class="line">        apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</div><div class="line">        return apConfig;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实，这段代码要求你的目标ssid必须保证是可连接的，否则，android检测到不可连接的话，会自动连接一个当前可连接wifi中最优的一个。。就不连接你的ssid了。<br>所以，目前我又遇到了一个更头疼的问题= =，如何避免系统去自动连接其他wifi，而只是一直等待我指定的wifi直到扫描到并连接上呢？</p>
<p>这篇文章好像提到了解决方法<a href="http://blog.csdn.net/ljphhj/article/details/48862037?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Android代码连接Wifi时被系统切换到其他Wifi的问题</a><br>明天再研究一下.</p>
<hr>
<p>问题解决了。<br><a href="http://www.cnblogs.com/cxcco/archive/2012/02/08/2343189.html" target="_blank" rel="external">WIFI设备</a><br>还是看api管用啊，只看人家现成的代码不行。</p>
<p>注册监听:NETWORK_STATE_CHANGED_ACTION，收到广播后判断当处于CONNECTED状态后，检测当前连接wifi是不是我所希望连接的ssid，若不是，首先wifiManager.disconnect()然后再次调用myconnect()函数；若是，取消注册该监听并通知ui线程目标wifi已经成功连接。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对AndroidWifi状态广播的研究]]></title>
      <url>http://blog.acbingo.cn/2016/05/02/%E5%AF%B9AndroidWifi%E7%8A%B6%E6%80%81%E5%B9%BF%E6%92%AD%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>对AndroidWifi状态广播的研究,研究下wifi连接和断开的情况下的状态经过，已经发送的广播顺序<br><a id="more"></a><br>今天在做项目时遇到了一个比较头疼的问题.<br>我需要连接指定的wifi热点，代码中当我判断wifi不可用的时候，用代码打开wifi，然后执行后面的语句。<br>其实，wifi打开是需要时间的，wifiManager.setWifiEnabled(true)后立即getScanResults()返回的只能是一张空表.<br>所以，解决问题的最好办法是wifiManager.setWifiEnabled(true)后等上一段时间再getScanResults()，但是，这个时间要等多少呢？？</p>
<p>去网上查，没有明确说明的。。最后自己在官方的api中查到了wifimanager的这样一个广播SCAN_RESULTS_AVAILABLE_ACTION，<br>下面我们来看看这个广播怎么用<br>废话不多讲，先上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private NetworkConnectChangedReceiver myBroadcastReceiver;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        IntentFilter filter = new IntentFilter();</div><div class="line">        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);</div><div class="line">        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);</div><div class="line">        filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);</div><div class="line">        filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);</div><div class="line">        myBroadcastReceiver = new NetworkConnectChangedReceiver();</div><div class="line">        registerReceiver(myBroadcastReceiver, filter);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public class NetworkConnectChangedReceiver extends BroadcastReceiver &#123;</div><div class="line">        @Override</div><div class="line">        public void onReceive(Context context, Intent intent)&#123;</div><div class="line">            //Log.e(&quot;APActivity&quot;, &quot;SCAN_RESULTS_AVAILABLE_ACTION&quot;);</div><div class="line">            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction()))&#123;</div><div class="line">                Log.e(&quot;APActivity&quot;, &quot;SCAN_RESULTS_AVAILABLE_ACTION&quot;);</div><div class="line">            &#125;</div><div class="line">            if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction()))&#123;</div><div class="line">                int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0);</div><div class="line">                switch (wifiState)</div><div class="line">                &#123;</div><div class="line">                    case WifiManager.WIFI_STATE_ENABLED:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_ENABLED&quot;);</div><div class="line">                        break;</div><div class="line">                    case WifiManager.WIFI_STATE_ENABLING:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_ENABLING&quot;);</div><div class="line">                        break;</div><div class="line">                    case WifiManager.WIFI_STATE_DISABLED:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_DISABLED&quot;);</div><div class="line">                        break;</div><div class="line">                    case WifiManager.WIFI_STATE_DISABLING:</div><div class="line">                        Log.e(&quot;APActivity&quot;, &quot;WIFI_STATE_DISABLING&quot;);</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 这个监听wifi的连接状态即是否连上了一个有效无线路由，当上边广播的状态是WifiManager.WIFI_STATE_DISABLING，和WIFI_STATE_DISABLED的时候，根本不会接到这个广播。</div><div class="line">            // 在上边广播接到广播是WifiManager.WIFI_STATE_ENABLED状态的同时也会接到这个广播，当然刚打开wifi肯定还没有连接到有效的无线</div><div class="line">            if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction()))</div><div class="line">            &#123;</div><div class="line">                Parcelable parcelableExtra = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);</div><div class="line">                if (null != parcelableExtra)</div><div class="line">                &#123;</div><div class="line">                    NetworkInfo networkInfo = (NetworkInfo) parcelableExtra;</div><div class="line">                    switch (networkInfo.getState())</div><div class="line">                    &#123;</div><div class="line">                        case CONNECTED:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;CONNECTED&quot;);</div><div class="line">                            break;</div><div class="line">                        case CONNECTING:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;CONNECTING&quot;);</div><div class="line">                            break;</div><div class="line">                        case DISCONNECTED:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;DISCONNECTED&quot;);</div><div class="line">                            break;</div><div class="line">                        case DISCONNECTING:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;DISCONNECTING&quot;);</div><div class="line">                            break;</div><div class="line">                        case SUSPENDED:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;SUSPENDED&quot;);</div><div class="line">                            break;</div><div class="line">                        case UNKNOWN:</div><div class="line">                            Log.e(&quot;APActivity&quot;, &quot;UNKNOWN&quot;);</div><div class="line">                            break;</div><div class="line">                        default:</div><div class="line">                            break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中我对ConnectivityManager.CONNECTIVITY_ACTION、WIFI_STATE_CHANGED_ACTION、NETWORK_STATE_CHANGED_ACTION、SCAN_RESULTS_AVAILABLE_ACTION进行监听。<br>然后将各种状态log出来</p>
<p><strong>当我打开wifi时</strong>，log是这样的:</p>
<blockquote>
<p>05-02 20:52:19.404  WIFI_STATE_ENABLING<br>05-02 20:52:21.389  WIFI_STATE_ENABLED<br>05-02 20:52:22.152  SCAN_RESULTS_AVAILABLE_ACTION<br>05-02 20:52:22.980  SCAN_RESULTS_AVAILABLE_ACTION<br>05-02 20:52:23.048  CONNECTING<br>05-02 20:52:23.750  CONNECTED</p>
</blockquote>
<p>看样子wifi连接的过程是这样样子的：<br>首先，打开wifi设备(这个打开过程是需要时间的，这个时间段内广播WIFI_STATE_ENABLING)，当wifi设备准备好后，广播WIFI_STATE_ENABLED<br>当时，直到此时才可以SCAN_RESULTS。（不清楚为什么了广播了两次）<br>然后，系统应该是根据优先级自动连接了可连接的wifi热点，所以发出了后面的CONNECTING与CONNECTED广播.</p>
<p>分析到这，令我头疼的问题应该就能解决了，我们只需要监听SCAN_RESULTS_AVAILABLE_ACTION广播即可。<br>下一篇我会演示如何优雅的连接指定的wifi热点(网络上果然有的人强行sleep等wifi开启完再进行其他操作= =)(今天时间不够了，明天写)</p>
<p>附：<br>当断开wifi是,log是这样的:</p>
<blockquote>
<p>05-02 21:12:03.343  DISCONNECTED<br>05-02 21:12:03.397  WIFI_STATE_DISABLING<br>05-02 21:12:04.087  WIFI_STATE_DISABLED</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera数据结构_字符串_课后作业]]></title>
      <url>http://blog.acbingo.cn/2016/05/01/coursera%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%97%E7%AC%A6%E4%B8%B2_%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<p>课后作业几个字符串的题还蛮经典的<br><a id="more"></a></p>
<h1 id="英语数字转换器"><a href="#英语数字转换器" class="headerlink" title="英语数字转换器"></a>英语数字转换器</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在这个问题中，将用英语给你一个或多个整数。你的任务是将这些数字转换成整型表示。数字范围从-999,999,999到999,999,999.下面是你的程序必须考虑的详尽的英语单词表：<br>negative, zero, one, two, three, four,five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen,fifteen, sixteen, seventeen, eighteen, nineteen, twenty, thirty, forty, fifty,sixty, seventy, eighty, ninety, hundred, thousand, million</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入包括多个样例，注意：</p>
<p>1.负数前面有词negative</p>
<p>2.当能用thousand的时候，将不用hundred。例如1500将写为”one thousand five hundred”,而不是”fifteen hundred”.</p>
<p><strong>输入将以一个空行结束</strong></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出将是每一个单独一行，每一个后面一个换行符</p>
<h2 id="思路-amp-代码"><a href="#思路-amp-代码" class="headerlink" title="思路&amp;代码"></a>思路&amp;代码</h2><p>看着蛮简单的，其实做起来就得考虑仔细了。<br>会流操作的话字符串的处理会简单的多：<br>整行用getline读进来，然后扔到stringstream进行分割<br>分出来的词其实只有negative,hundred, thousand, million需要特殊处理下</p>
<p>分析几个数据，然后考虑到数据范围，就能发现特征所在了:<br>比如说：999999999， nine hundred ninety nine million nine hundred ninety nine thousand nine hundred ninety nine<br>就可以分成：<br>nine hundred ninety nine million<br>nine hundred ninety nine thousand<br>nine hundred ninety nine<br>三段加起来。也就是说，我们可以以thousand和million为分割（思考下为什么呢？？想明白了这个题也就解决了，几行代码的事，网上居然还有把逻辑写成几百行的= =，也不嫌累）<br>也许你看下代码思路就会更清晰了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdafx.h&quot;</div><div class="line"></div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">using namespace std;</div><div class="line">map&lt;string, long&gt; mp;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	string s;</div><div class="line">	mp[&quot;zero&quot;] = 0;</div><div class="line">	mp[&quot;one&quot;] = 1;</div><div class="line">	mp[&quot;two&quot;] = 2;</div><div class="line">	mp[&quot;three&quot;] = 3;</div><div class="line">	mp[&quot;four&quot;] = 4;</div><div class="line">	mp[&quot;five&quot;] = 5;</div><div class="line">	mp[&quot;six&quot;] = 6;</div><div class="line">	mp[&quot;seven&quot;] = 7;</div><div class="line">	mp[&quot;eight&quot;] = 8;</div><div class="line">	mp[&quot;nine&quot;] = 9;</div><div class="line">	mp[&quot;ten&quot;] = 10;</div><div class="line">	mp[&quot;eleven&quot;] = 11;</div><div class="line">	mp[&quot;twelve&quot;] = 12;</div><div class="line">	mp[&quot;thirteen&quot;] = 13;</div><div class="line">	mp[&quot;fourteen&quot;] = 14;</div><div class="line">	mp[&quot;fifteen&quot;] = 15;</div><div class="line">	mp[&quot;sixteen&quot;] = 16;</div><div class="line">	mp[&quot;seventeen&quot;] = 17;</div><div class="line">	mp[&quot;eighteen&quot;] = 18;</div><div class="line">	mp[&quot;nineteen&quot;] = 19;</div><div class="line">	mp[&quot;twenty&quot;] = 20;</div><div class="line">	mp[&quot;thirty&quot;] = 30;</div><div class="line">	mp[&quot;forty&quot;] = 40;</div><div class="line">	mp[&quot;fifty&quot;] = 50;</div><div class="line">	mp[&quot;sixty&quot;] = 60;</div><div class="line">	mp[&quot;seventy&quot;] = 70;</div><div class="line">	mp[&quot;eighty&quot;] = 80;</div><div class="line">	mp[&quot;ninety&quot;] = 90;</div><div class="line">	long ans = 0; int f = 0;</div><div class="line">	while (getline(cin, s)) &#123;</div><div class="line">		if (s == &quot;&quot;) return 0;</div><div class="line">		stringstream ss(s);</div><div class="line">		string t; ans = 0; f = 0;</div><div class="line">		ss &gt;&gt; t;</div><div class="line">		if (t == &quot;negative&quot;) &#123;</div><div class="line">			f = 1;</div><div class="line">			ss &gt;&gt; t;</div><div class="line">		&#125;</div><div class="line">		long tt=0;</div><div class="line">		do &#123;</div><div class="line">			</div><div class="line">			if (t == &quot;hundred&quot;)</div><div class="line">			&#123;</div><div class="line">				tt *= 100;</div><div class="line">			&#125;</div><div class="line">			else if (t == &quot;thousand&quot;)</div><div class="line">			&#123;</div><div class="line">				tt *= 1000;</div><div class="line">				ans += tt;</div><div class="line">				tt = 0;</div><div class="line">			&#125;</div><div class="line">			else if (t == &quot;million&quot;)</div><div class="line">			&#123;</div><div class="line">				tt *= 1000000;</div><div class="line">				ans += tt;</div><div class="line">				tt = 0;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">				tt += mp[t];</div><div class="line">		&#125; while (ss &gt;&gt; t);</div><div class="line">		ans += tt;</div><div class="line">		if (f) ans = -ans;</div><div class="line">		cout &lt;&lt; ans &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单几步在Android_Studio上实现二维码的生成与扫描]]></title>
      <url>http://blog.acbingo.cn/2016/05/01/%E7%AE%80%E5%8D%95%E5%87%A0%E6%AD%A5%E5%9C%A8Android_Studio%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E6%89%AB%E6%8F%8F/</url>
      <content type="html"><![CDATA[<p>本文使用zxing-android-embedded这个开源项目实现 二维码扫描/生成 功能<br><a id="more"></a></p>
<p>想在项目上利用二维码实现一点功能，今天研究二维码研究了一整天。。<br>下面分享下我的经验，免得大家像我一样走弯路</p>
<h1 id="寻找第三方成熟技术"><a href="#寻找第三方成熟技术" class="headerlink" title="寻找第三方成熟技术"></a>寻找第三方成熟技术</h1><p>从头开始实现二维码技术自己短时间内肯定是不行，所以最好的方法就是使用目前比较成熟的第三方库。<br>目前网络上大部分人都在使用:<a href="https://github.com/zxing/zxing" target="_blank" rel="external">ZXing</a><br>研究半天，使用起来比较复杂。还好有人做了一个针对Android开发的专门的库:<a href="https://github.com/journeyapps/zxing-android-embedded" target="_blank" rel="external">zxing-android-embedded</a></p>
<h1 id="我的开发平台"><a href="#我的开发平台" class="headerlink" title="我的开发平台"></a>我的开发平台</h1><p>Android_Studio 2.1<br>Java 1.8</p>
<h1 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h1><ol>
<li>使用Android Studio新建一个项目。</li>
<li><p>将下面的这段代码加入 build.gradle 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    jcenter()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.journeyapps:zxing-android-embedded:3.2.0@aar&apos;</div><div class="line">    compile &apos;com.google.zxing:core:3.2.1&apos;</div><div class="line">    compile &apos;com.android.support:appcompat-v7:23.1.0&apos;   // Version 23+ is required</div><div class="line">&#125;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    buildToolsVersion &apos;23.0.2&apos; // Older versions may give compile errors</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后你的Gradle会自动编译代码并且导入到app中。若没有gradle没有动静，有可能gradle开离线模式了，设置：File-&gt;Setting-&gt;Build.Execution,Deployment-&gt;Build Tools-&gt;Gradle,将最下面的Offline work关闭即可。然后run一下项目，你就会发现可以gradle正在帮你下载一些文件</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>在 MainActivity 的 onCreate 方法中写入下述代码。运行时如果可以出现扫码窗口，则为导入成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new IntentIntegrator(this).initiateScan();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以调整参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IntentIntegrator integrator = new IntentIntegrator(this);</div><div class="line">integrator.setPrompt(&quot;请扫描&quot;); //底部的提示文字，设为&quot;&quot;可以置空</div><div class="line">integrator.setCameraId(0); //前置或者后置摄像头</div><div class="line">integrator.setBeepEnabled(false); //扫描成功的「哔哔」声，默认开启</div><div class="line">integrator.initiateScan();</div></pre></td></tr></table></figure></p>
<p>默认是横屏的，如果要调整成竖屏，新建一个 Empty Activity（我命名为 ScanActivity），内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import com.journeyapps.barcodescanner.CaptureActivity;</div><div class="line">public class ScanActivity extends CaptureActivity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打开AndroidManifest.xml文件，编辑 ScanActivity 属性如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity </div><div class="line">android:name=&quot;.ScanActivity&quot;</div><div class="line">android:screenOrientation=&quot;portrait&quot;</div><div class="line">android:stateNotNeeded=&quot;true&quot;</div><div class="line">android:theme=&quot;@style/zxing_CaptureTheme&quot;</div><div class="line">android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;</div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>在前述调整参数的代码段中添加一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">intentIntegrator.setCaptureActivity(ScanActivity.class);</div></pre></td></tr></table></figure></p>
<h1 id="获得扫描结果"><a href="#获得扫描结果" class="headerlink" title="获得扫描结果"></a>获得扫描结果</h1><p>通过重载onActivityResult接收返回的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onActivityResult(int requestCode, int resultCode, Intent intent) &#123;</div><div class="line">    IntentResult result = IntentIntegrator.parseActivityResult(requestCode, resultCode, intent);</div><div class="line">    if(result != null) &#123;</div><div class="line">        if(result.getContents() == null) &#123;</div><div class="line">            Log.d(TAG, &quot;Cancelled&quot;);</div><div class="line">            Toast.makeText(this, &quot;Cancelled&quot;, Toast.LENGTH_LONG).show();</div><div class="line">        &#125; else &#123;</div><div class="line">            Log.d(TAG, &quot;Scanned: &quot; + result.getContents());</div><div class="line">            Toast.makeText(this, &quot;Scanned: &quot; + result.getContents(), Toast.LENGTH_LONG).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="如何生成一张二维码"><a href="#如何生成一张二维码" class="headerlink" title="如何生成一张二维码"></a>如何生成一张二维码</h1><p>通过调用generateQRCode(String yourtext)，返回一张Bitmap图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private Bitmap generateQRCode(String qrCodeString)&#123;</div><div class="line">    Bitmap bmp = null;    //二维码图片</div><div class="line">    QRCodeWriter writer = new QRCodeWriter();</div><div class="line">    try &#123;</div><div class="line">        BitMatrix bitMatrix = writer.encode(qrCodeString, BarcodeFormat.QR_CODE, 512, 512); //参数分别表示为: 条码文本内容，条码格式，宽，高</div><div class="line">        int width = bitMatrix.getWidth();</div><div class="line">        int height = bitMatrix.getHeight();</div><div class="line">        bmp = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);</div><div class="line">         </div><div class="line">        //绘制每个像素</div><div class="line">        for (int x = 0; x &lt; width; x++) &#123;</div><div class="line">            for (int y = 0; y &lt; height; y++) &#123;</div><div class="line">                bmp.setPixel(x, y, bitMatrix.get(x, y) ? Color.BLACK : Color.WHITE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    &#125; catch (WriterException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    return bmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_算法课后习题]]></title>
      <url>http://blog.acbingo.cn/2016/04/25/coursera_%E7%AE%97%E6%B3%95%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>这里是程序设计与算法中——算法基础一门课的动态规划一章的课后习题<br><a id="more"></a></p>
<h1 id="编程题＃1：集合加法"><a href="#编程题＃1：集合加法" class="headerlink" title="编程题＃1：集合加法"></a>编程题＃1：集合加法</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 3000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>给出2个正整数集合A = {pi | 1 &lt;= i &lt;= a}，B = {qj | 1 &lt;= j &lt;= b}和一个正整数s。问题是：使得pi + qj = s的不同的(i, j)对有多少个。</p>
<p>输入</p>
<p>第1行是测试数据的组数n，后面跟着n组测试数据。</p>
<p>每组测试数据占5行，第1行是和s (1 &lt;= s &lt;= 10000)，第2行是一个正整数a (1 &lt;= a &lt;= 10000)，表示A中元素的数目。第3行是a个正整数，每个正整数不超过10000，表示A中的元素。第4行是一个正整数b (1 &lt;= b &lt;= 10000)，表示B中元素的数目。第5行是b个正整数，每个正整数不超过10000，表示B中的元素。</p>
<p>注意：这里的集合和数学书上定义的集合有一点点区别——集合内可能包含相等的正整数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>没啥可说的<br>这题。。居然。。暴力过了。。<br>先说说我能想到的解法吧。。<br>枚举第一个数组中的元素<br>比如说a[i],那么就在第二个数组中寻找是否存在s-a[i]。这样的话时间复杂度是O(n^2)<br>优化：在b[]检索的时候可以优化。<br>1.对两个数组进行排序，当在b中找到b[j]+a[i]&gt;s后，显然就不用找了。<br>2.虽然省掉了一半，但是还是得从头开始找呀。所以可以做另一个优化:将排序后的数组划分区间（比如说10个元素划分为一个区间），那么我们可以把每个区间里的首元素放到一个二叉搜索树中。<br>这样这样就能达到快速的定位了。</p>
<p>我猜测优化后时间复杂度最优能达到O(nlogn)，最差也比O(n^2)要好</p>
<p>这题既然放在了动规后面，应该有动归的解法。。但是我尝试了半天也没有抽象出来啥子问题呀。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n, s, A[10000], B[10000], aNum, bNum, num;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    while(n--)</div><div class="line">    &#123;</div><div class="line">        num = 0;</div><div class="line">        cin &gt;&gt; s &gt;&gt; aNum;</div><div class="line">        for(int i = 0; i &lt; aNum; i++)</div><div class="line">            cin &gt;&gt; A[i];</div><div class="line">        cin &gt;&gt; bNum;</div><div class="line">        for(int i = 0; i &lt; bNum; i++)</div><div class="line">            cin &gt;&gt; B[i];</div><div class="line">        for(int i = 0; i &lt; aNum; i++)</div><div class="line">        &#123;</div><div class="line">            for(int j = 0; j &lt; bNum; j++)//依次遍历(i,j)的每一种取值即可</div><div class="line">            &#123;</div><div class="line">                if(A[i] + B[j] == s)</div><div class="line">                    num++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; num &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    //system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：-滑雪"><a href="#编程题＃2：-滑雪" class="headerlink" title="编程题＃2： 滑雪"></a>编程题＃2： 滑雪</h1><p>描述</p>
<p>Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子</p>
<p>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p>
<p>输入</p>
<p>输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</p>
<p>输出</p>
<p>输出最长区域的长度。</p>
<p>样例输入</p>
<p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br>样例输出</p>
<p>25</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>记忆化搜索。。。<br>动归的主要判断依据是是否可以抽象出子问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"></div><div class="line">#define N 100</div><div class="line"></div><div class="line">int map[N][N],len[N][N]; //map存放点高度信息，len存放对于点可以滑的最大长度</div><div class="line">int n=0,m=0; //n表示图行数，m表示图的列数</div><div class="line">int MAX=0; //整个图的最大长度</div><div class="line"></div><div class="line">//获得 map[a,b] 点的最大长度，顺带算出目前整个图中最大长度</div><div class="line">int search(int a,int b);</div><div class="line">// 动态规划+贪心算法</div><div class="line">int main()&#123;</div><div class="line">    int i,j;</div><div class="line">    //map</div><div class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))&#123;</div><div class="line">        for(i=0;i&lt;n;i++)</div><div class="line">            for(j=0;j&lt;m;j++)&#123;</div><div class="line">                scanf(&quot;%d&quot;,&amp;map[i][j]);</div><div class="line">            &#125;</div><div class="line">        memset(len,0,sizeof(len)); //初始化各个点的最大长度</div><div class="line">        for(i=0;i&lt;n;i++)</div><div class="line">            for(j=0;j&lt;m;j++)&#123;</div><div class="line">                search(i,j);</div><div class="line">            &#125;</div><div class="line">        printf(&quot;%d\n&quot;,MAX);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int search(int a,int b)&#123;</div><div class="line">    if(len[a][b] != 0) return len[a][b];//记忆化搜索</div><div class="line">    int max = 0;</div><div class="line">    // 上</div><div class="line">    if(a-1&gt;=0&amp;&amp;map[a][b] &gt; map[a-1][b])&#123;</div><div class="line">        if(max &lt; search(a-1,b)) max = search(a-1,b);</div><div class="line">    &#125;</div><div class="line">    // 左</div><div class="line">    if(b-1&gt;=0&amp;&amp;map[a][b] &gt; map[a][b-1])&#123;</div><div class="line">        if(max &lt; search(a,b-1)) max = search(a,b-1);</div><div class="line">    &#125;</div><div class="line">    // 右</div><div class="line">    if(b+1&lt;m&amp;&amp;map[a][b] &gt; map[a][b+1])&#123;</div><div class="line">        if(max &lt; search(a,b+1)) max = search(a,b+1);</div><div class="line">    &#125;</div><div class="line">    // 下</div><div class="line">    if(a+1&lt;n&amp;&amp;map[a][b] &gt; map[a+1][b])&#123;</div><div class="line">        if(max &lt; search(a+1,b)) max = search(a+1,b);</div><div class="line">    &#125;</div><div class="line">    len[a][b] = max+1;</div><div class="line">    if(MAX &lt; len[a][b])</div><div class="line">        MAX = len[a][b];</div><div class="line">    return len[a][b];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_计算机组成学习笔记]]></title>
      <url>http://blog.acbingo.cn/2016/04/25/coursera_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>纯属闲得蛋疼再刷一遍公开课。。。不知道我能不能坚持下去<br><a id="more"></a><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f399trl9ocj30r20fjn1y.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cocos2dx-飞机大战]]></title>
      <url>http://blog.acbingo.cn/2016/04/20/cocos2dx-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
      <content type="html"><![CDATA[<p>之前用cocos引擎做的一个小游戏，面试官想要看一下。。。记不起之前有没有挂在博客上。。<br>面试结束后快马加鞭跑回来一看果然没有。。现在赶紧加上</p>
<p>面试中提问的我一个题我走后才想到可能是红黑树…<br>5555555555555，感觉答的好差劲啊，要挂了</p>
<a id="more"></a>
<h2 id="游戏运行界面"><a href="#游戏运行界面" class="headerlink" title="游戏运行界面"></a>游戏运行界面</h2><p>//Todo<br>只找到之前的代码和之前的交的报告。。。没有游戏截图，由于换过系统了，所以待会配置好环境跑起来代码再来改一下博客T T</p>
<p>//14：12<br>万万没想到，cocos配置方式改了啊= =,官方不支持用vs开发了？？。。。而且，宾馆这网速。。ndk晚上前下载完看样子不太可能了T T</p>
<p>//16:46<br>。。之前的工程文件现在不兼容了。。怎么都打不开。。重新配一个发现好多api都更新了，代码需要改很多，算了，回学校再弄吧，实在受不了这网速。。午饭还没吃找同学吃饭去。。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>第一次参加面试，就能走到三面，感觉挺幸运了。。。<br>可是。。。我最最想去的腾讯啊…好不容易离这么近啊。。哎，都是泪<br>晚上的阿里和明天的百度的笔试不想做了，今天暑假接着留校学习吧，需要自己学习的东西还有很多。。。明天回去接着做软件杯。。</p>
<h2 id="我实现的游戏内容主要有以下几个特点："><a href="#我实现的游戏内容主要有以下几个特点：" class="headerlink" title="我实现的游戏内容主要有以下几个特点："></a>我实现的游戏内容主要有以下几个特点：</h2><ol>
<li>支持鼠标以及键盘两种操作方式。</li>
<li>一共有5张关卡。每张关卡有不同的游戏内容。随着关卡的提示，游戏难度相应提高，敌人的子弹伤害，生命值，移动速度也会提高。</li>
<li>战机有4种战斗形态。升级方式通过获得游戏中的掉落道具所得。</li>
<li>敌机一共有15种。第一关会随机出现3种敌人，第二关会出现6种，以此类推，每升一关会多出3种敌人。</li>
<li>每一关最后会出现BOSS敌机，有独特的攻击方式以及丰厚的血量。</li>
<li>战机的导弹有5种形态。每种形态有不同的视觉效果以及攻击能力。导弹升级通过获得游戏中的掉落道具所得。</li>
<li>核弹系统。使用后清除全屏的敌机（Boss则会掉一定血量）。游戏开始会自带三发核弹。核弹可以通过游戏中吃取掉落道具所得。</li>
<li>血量系统。屏幕下方有飞机的血量显示。随着飞机的升级总血量值也会得到提升。同时可以通过吃取游戏中的掉落道具获得血量。</li>
<li>敌机的运动规律不是单调的。会随机的做平滑的曲线运动。每一种敌机的运动范围与运动速度也不相同。</li>
<li>6种掉落道具。击杀敌机后有一定概率出现。</li>
</ol>
<h2 id="值得一提的技术"><a href="#值得一提的技术" class="headerlink" title="值得一提的技术"></a>值得一提的技术</h2><p>这里简述几点值得一提的技术以及知识点。</p>
<ol>
<li>敌机运动轨迹产生技术。<br>为了使敌机的运动轨迹能做出来无规律的曲线运动，同时使得运动曲线平滑不突兀。我编写了随机贝塞尔曲线生成器。给出敌机的出现位置以及消失位置，以及随机出两个制约点，即可得到一条符合要求的贝塞尔曲线，使得敌机沿着该曲线运动。</li>
<li>图层技术。<br>引入了图片处理软件常用的图层概念。方便进行碰撞检测<br>背景图位于图层0。战绩敌机子弹掉落的道具等位于图层1.云彩位于图层2.而分数显示等文字信息位于最上方的图层。<br>这样，不同图层的物体不会互相访问到，高图层的物体会在视觉效果上遮挡住低图层的物体。</li>
<li>敌人产生器。<br>通过敌人产生器，可以根据当前的战机状态，游戏关卡等随机产生一个符合要求的敌人。不同的敌机属性，视觉效果，飞行速率，飞行曲线，伤害值，血量等等都是通过其产生的。</li>
<li>道具掉落系统。<br>游戏中一共会出现7种道具:<br>1．       血包。掉落概率10% 获得后增加当前战机血量百分之十的生命值。<br>2．       伤害增加。掉落概率为5%，增加当前子弹1点伤害值。伤害值每达到5（为了方便演示，已修改为1）的倍数，子弹的视觉效果得到升级。最高20点。<br>3．      战机升级。掉落概率为0.5%，战机获得升级！最高5级。升级后，战机获得全新的视觉外观，更多的生命值，更多的子弹以及更快的子弹发射频率。<br>4．      子弹速率加快。掉落概率为5%。增加当前子弹一定的发射速率。最高为每秒5发。（为了方便演示，默认5发每秒）<br>5．      获得一枚核弹。掉落概率为4% 战机最高可存储9发核弹。<br>6．     获得三枚核弹。掉落概率为1%<br>7．     子弹移动速度加快。掉落概率为5%</li>
<li>内存释放技术<br>为了保证游戏流畅度，所有元素均采用内存动态释放技术。当一个资源（物品，子弹或者敌机等）不再在屏幕上显示而且判断出以后也不会显示后，会调用该技术释放掉其所占用内存。</li>
</ol>
<h2 id="游戏类图"><a href="#游戏类图" class="headerlink" title="游戏类图"></a>游戏类图</h2><p><img src="http://ww3.sinaimg.cn/large/005BpcqWgw1f334abk04cj30dy0kwjsc.jpg" alt=""></p>
<p>MainScene：<br>    游戏入口界面。有3个菜单选项:进入游戏，最高分，关于。<br>HighScore：<br>    读取由SaveData保存到本地的游戏信息，显示10条历史最高分记录。<br>About：<br>    关于。<br>GameScene：<br>    游戏界面。负责 </p>
<ol>
<li>游戏界面的产生，关卡的升级，以及背景图的移动。</li>
<li>物品的碰撞检测</li>
<li>游戏的运行逻辑<br>Control：<br>控制层。主要负责游戏中元素的移动与子弹的发射，游戏的暂停与开始，声音的关闭与开启。<br>Plane：<br>战机。主要负责战机的产生，升级以及各项属性的控制与管理等。<br>EnemyBase：<br>敌机。主要负责敌机各项属性的控制与管理等。<br>EnemyManage：<br>敌机控制层。主要负责敌机的产生，销毁，以及移动的控制。<br>Bullet：<br>子弹。主要负责敌机与战机子弹的产生，逻辑，以及子弹的升级。<br>ItemeDrop：<br>物品掉落。主要负责掉落物品产生，以及各类物品的效果实现。<br>SaveData：<br>数据保存。主要负责将游戏信息保存到本地（xml格式），方便以后再使用。<br>GaveOver：<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1>//Todo<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div></pre></td><td class="code"><pre><div class="line">//MainScene.h:</div><div class="line">#ifndef __MainScene_SCENE_H__</div><div class="line">#define __MainScene_SCENE_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;SimpleAudioEngine.h&quot;</div><div class="line">class MainScene : public cocos2d::Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	static cocos2d::Scene* createScene();</div><div class="line">	void myupdate(float f);</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(MainScene);</div><div class="line"></div><div class="line">	void menuCallback(cocos2d::Ref* pSender);//菜单回调函数</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//GameScene.h:</div><div class="line">#pragma once</div><div class="line">#ifndef GAME_SCENE</div><div class="line">#define GAME_SCENE</div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;MainScene.h&quot;</div><div class="line">#include &quot;Plane.h&quot;</div><div class="line">#include &quot;EnemyManager.h&quot;</div><div class="line">#include &quot;Bullet.h&quot;</div><div class="line">#include &quot;ItemDrop.h&quot;</div><div class="line">#include &quot;Controller.h&quot;</div><div class="line"></div><div class="line">using namespace cocos2d;</div><div class="line">class GameScene :Layer &#123;</div><div class="line">private:</div><div class="line">	int level;</div><div class="line">	int status;         //游戏状态  1为正常、2为暂停、3为结束</div><div class="line">	int score;</div><div class="line">public:</div><div class="line">	GameScene();</div><div class="line">	~GameScene();</div><div class="line"></div><div class="line">	bool init();</div><div class="line">	CREATE_FUNC(GameScene);</div><div class="line"></div><div class="line">	static Scene * createScene();</div><div class="line">	static GameScene * instanceGameScene;//gamescene实例</div><div class="line">	void moveBackground(float t);//背景移动</div><div class="line"></div><div class="line">	void setBackGround();</div><div class="line">	void levelUp();//关卡升级</div><div class="line">	int getLevel();</div><div class="line"></div><div class="line">	void gameUpdate(float dt);     // 碰撞检测</div><div class="line">	bool bulletCollisionEnemy(Sprite* pBullet);   // 子弹和敌机碰撞</div><div class="line">	void enemyCollisionPlane();    // 我机和敌机、敌机子弹碰撞</div><div class="line">	bool ItemCollisionPlane(Sprite* pItem);//物体碰撞</div><div class="line">	void toGameOver(float dt);</div><div class="line">	</div><div class="line"></div><div class="line">	MyPlane *planeLayer;</div><div class="line">	Bullet *bulletLayer;</div><div class="line">	EnemyManager *enemyLayer;</div><div class="line">	Controller *controlLayer;</div><div class="line">	ItemDrop *itemLayer;</div><div class="line"></div><div class="line">	//int clearBoom;//清屏导弹</div><div class="line">	void clearAllEnemy();//清除所有敌人和子弹</div><div class="line">	void removeBoom(Node * pSender);</div><div class="line">	void creatClearBoom();//</div><div class="line">	void setBoomNum();//导弹</div><div class="line">	void addBoomNum(int t);</div><div class="line">	void setBoomPic();</div><div class="line">	void particleAct();</div><div class="line">	int boomNum;//</div><div class="line">	void boomAction();</div><div class="line">&#125;;</div><div class="line">#endif</div><div class="line"></div><div class="line">//Bullet.h:</div><div class="line">#pragma once</div><div class="line">#ifndef __Bullet_H__</div><div class="line">#define __Bullet_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line"></div><div class="line">#include &quot;Plane.h&quot;</div><div class="line">#include &quot;EnemyManager.h&quot;</div><div class="line">#include &quot;SimpleAudioEngine.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC; // 命名空间</div><div class="line"></div><div class="line">class Bullet : public Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Bullet();</div><div class="line">	~Bullet();</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(Bullet);</div><div class="line"></div><div class="line">public:</div><div class="line">	void bindEnemyManager(EnemyManager* enemyManager);//分数更新</div><div class="line">	void BeginBulletShoot(float dt = 0.0f);	// 开启子弹射击</div><div class="line">	void StopBulletShoot();					// 停止子弹射击</div><div class="line">	void addBullet(float dt);				// 添加子弹</div><div class="line">	void removeBullet(Node* pNode);			// 移除子弹</div><div class="line">	void addEnemyBullet(float dt);				// 添加敌机子弹</div><div class="line">	void removeEnemyBullet(Node* pNode);			// 移除敌机子弹</div><div class="line">	void setDamage(int t);</div><div class="line">	void addDamage(int t);</div><div class="line">	int getDamage();</div><div class="line">	Sprite * setBulletType(); </div><div class="line">	void setBulletPosition(Sprite* bullet, int t);</div><div class="line">	void addOneBullet(int ix);</div><div class="line">	void setAutoBullet();</div><div class="line">	void addKeyBullet();</div><div class="line">	bool autoBullet;</div><div class="line">public:</div><div class="line">	Vector&lt;Sprite*&gt; vecBullet;</div><div class="line">	Vector&lt;Sprite*&gt; vecEnemyBullet;</div><div class="line">	EnemyManager* m_enemyManager;</div><div class="line">	int damage;//攻击力</div><div class="line">	static Bullet* instanceBullet;	//子弹实体</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//Controller.h</div><div class="line">#pragma once</div><div class="line">#ifndef __Controller_H__</div><div class="line">#define __Controller_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;SaveData.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line"></div><div class="line">class Controller : public Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Controller();</div><div class="line">	~Controller();</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(Controller);</div><div class="line"></div><div class="line">	//对玩家分数的操作</div><div class="line">	CC_SYNTHESIZE_READONLY(SaveData *, m_saveData, SaveData);</div><div class="line">	void update(float tm);</div><div class="line"></div><div class="line">	//游戏暂停与恢复</div><div class="line">	void menuPauseCallback(cocos2d::Ref* pSender);</div><div class="line"></div><div class="line">	//声音控制</div><div class="line">	void menuMusicCallback(cocos2d::Ref* pSender);</div><div class="line"></div><div class="line">public:</div><div class="line">	MenuItemSprite* pPauseItem;</div><div class="line">	MenuItemSprite* pMusicItem;</div><div class="line">	Label * m_score;</div><div class="line">	Label * score_label;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//EnemyBase.h</div><div class="line">#pragma once</div><div class="line">#ifndef __EnemyBase_H__</div><div class="line">#define __EnemyBase_H__</div><div class="line"></div><div class="line">#define HardCode 1</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line"></div><div class="line"></div><div class="line">// 敌机生命值</div><div class="line">const int ENEMY1_1 = 1 * HardCode;</div><div class="line">const int ENEMY1_2 = 2 * HardCode;</div><div class="line">const int ENEMY1_3 = 2 * HardCode;</div><div class="line">const int ENEMY2_1 = 8 * HardCode;</div><div class="line">const int ENEMY2_2 = 10 * HardCode;</div><div class="line">const int ENEMY2_3 = 12 * HardCode;</div><div class="line">const int ENEMY3_1 = 8*3 * HardCode;</div><div class="line">const int ENEMY3_2 = 9*3 * HardCode;</div><div class="line">const int ENEMY3_3 = 10*3 * HardCode;</div><div class="line">const int ENEMY4_1 = 16*4 * HardCode;</div><div class="line">const int ENEMY4_2 = 17*4 * HardCode;</div><div class="line">const int ENEMY4_3 = 18*4 * HardCode;</div><div class="line">const int ENEMY5_1 = 32*5 * HardCode;</div><div class="line">const int ENEMY5_2 = 35*5 * HardCode;</div><div class="line">const int ENEMY5_3 = 40*5 * HardCode;</div><div class="line">const int ENEMYBOSS1 = 25 * HardCode;</div><div class="line">const int ENEMYBOSS2 = 50 * HardCode;</div><div class="line">const int ENEMYBOSS3 = 100 * HardCode;</div><div class="line">const int ENEMYBOSS4 = 200 * HardCode;</div><div class="line">const int ENEMYBOSS5 = 400 * HardCode;</div><div class="line">const int ENEMYBOSS6 = 800 * HardCode;</div><div class="line"></div><div class="line">class EnemyBase : public Node</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	EnemyBase();</div><div class="line">	~EnemyBase();</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(EnemyBase);</div><div class="line"></div><div class="line">public:</div><div class="line">	std::map&lt;std::string, int&gt; enemyHP;//飞机的HP(不能在头文件中定义全局变量，否则会产生多重定义)</div><div class="line">	void setEnemyByType(std::string enType);//飞机产生</div><div class="line">	Sprite* getSprite();//获得该实例</div><div class="line"></div><div class="line">	int getScore();</div><div class="line">	int getLife();</div><div class="line">	bool loseLife(int t);</div><div class="line">	Rect getBoundingBox();</div><div class="line"></div><div class="line">private:</div><div class="line">	Sprite *pEnemySprite;//实例</div><div class="line">	int nLife;</div><div class="line">	int nScore;</div><div class="line">&#125;;</div><div class="line">#endif</div><div class="line"></div><div class="line">//EnemyManager.h</div><div class="line">#pragma once</div><div class="line">#ifndef __EnemyManager_H__</div><div class="line">#define __EnemyManager_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;EnemyBase.h&quot;</div><div class="line">#include &quot;Controller.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line"></div><div class="line">class EnemyManager : public Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	EnemyManager();</div><div class="line">	~EnemyManager();</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(EnemyManager);</div><div class="line">public:</div><div class="line">	//绑定控制器(更新分数，敌机的移动)</div><div class="line">	void bindController(Controller* controller);</div><div class="line"></div><div class="line">	//根据分数决定添加敌机速度</div><div class="line">	//void addSpeed(float dt);</div><div class="line"></div><div class="line">	// 添加敌机</div><div class="line">	void addEnemy(float dt);</div><div class="line"></div><div class="line">	// 敌机爆炸</div><div class="line">	void blowupEnemy(EnemyBase* pEnemySprite);</div><div class="line"></div><div class="line">	// 移除敌机pNode</div><div class="line">	void removeEnemy(Node *pNode);</div><div class="line"></div><div class="line">	//爆炸动画</div><div class="line">	Animate* boomAnimate();</div><div class="line">	</div><div class="line">	//运动轨迹产生器</div><div class="line">	Sequence* EnemyManager::MovingTrack();</div><div class="line"></div><div class="line">	void removeAct(Node * pSender);</div><div class="line"></div><div class="line">	void checkCanLevel(int score);</div><div class="line">public:</div><div class="line">	//Vector&lt;Sprite*&gt; vecItem;//掉落物品</div><div class="line">	Vector&lt;EnemyBase*&gt; vecEnemy;// 敌机容器，用于遍历碰撞问题</div><div class="line">	Controller* m_controlLayer;	//控制器</div><div class="line">	float m_fCreatSpeed=1;	//添加敌机速度</div><div class="line">	float m_fEnemy;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//GameOver.h</div><div class="line"></div><div class="line">#ifndef __GameOver_H__</div><div class="line">#define __GameOver_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;MainScene.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line"></div><div class="line">class GameOver : public cocos2d::Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	// there&apos;s no &apos;id&apos; in cpp, so we recommend returning the class instance pointer</div><div class="line">	static cocos2d::Scene* createScene();</div><div class="line"></div><div class="line">	// Here&apos;s a difference. Method &apos;init&apos; in cocos2d-x returns bool, instead of returning &apos;id&apos; in cocos2d-iphone</div><div class="line">	virtual bool init();</div><div class="line"></div><div class="line">	// 退出游戏</div><div class="line">	void menuCloseCallback(cocos2d::Ref* pSender);</div><div class="line"></div><div class="line">	// 返回主界面</div><div class="line">	void menuMainCallback(cocos2d::Ref* pSender);</div><div class="line"></div><div class="line">	// implement the &quot;static create()&quot; method manually</div><div class="line">	CREATE_FUNC(GameOver);</div><div class="line"></div><div class="line">public:</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//ItemDrop.h</div><div class="line">#pragma once</div><div class="line">#ifndef __ItemDrop_H__</div><div class="line">#define __ItemDrop_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line">#include &quot;SimpleAudioEngine.h&quot;</div><div class="line">USING_NS_CC; </div><div class="line"></div><div class="line">class ItemDrop : public Layer </div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	ItemDrop();</div><div class="line">	~ItemDrop();</div><div class="line">	virtual bool init();</div><div class="line">	CREATE_FUNC(ItemDrop);</div><div class="line"></div><div class="line">	//随机产生一个物品</div><div class="line">	void createItem(Point p);</div><div class="line"></div><div class="line">	//</div><div class="line">	void removeItem(Node *pNode);</div><div class="line">public:</div><div class="line">	Vector&lt;Sprite*&gt; vecItem;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//Plane.h</div><div class="line">#ifndef __MyPlane_H__</div><div class="line">#define __MyPlane_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line">#define SCENE_WIDTH   512 //视野宽度</div><div class="line">#define SCENE_HEIGHT   768  //视野高度</div><div class="line">enum</div><div class="line">&#123;</div><div class="line">	AIRTAG = 1,</div><div class="line">	AIRPLANE2,</div><div class="line">	AIRPLANE3,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class MyPlane : public Layer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	MyPlane();</div><div class="line">	~MyPlane();</div><div class="line"></div><div class="line">	static MyPlane* create();</div><div class="line"></div><div class="line">	virtual bool init();</div><div class="line">	int AIRLEVEL = 1;//飞机等级</div><div class="line">	int AIRBASEHP = 20;</div><div class="line">	int AIRHP = 20;//飞机的生命总数</div><div class="line">public:</div><div class="line">	//飞机移动</div><div class="line">	virtual bool onTouchBegan(Touch *pTouch, Event *pEvent);//触摸回调，开始</div><div class="line">	virtual void onTouchMoved(Touch *pTouch, Event *pEvent);//触摸回调，移动</div><div class="line">	void keyPressed(cocos2d::EventKeyboard::KeyCode keyCode, cocos2d::Event *event);//键盘回调</div><div class="line">	//飞机动画</div><div class="line">	//Animate* planeFly();</div><div class="line">	</div><div class="line">	//边界检测</div><div class="line">	//void borderCheck(float dt);</div><div class="line">	//飞机爆炸</div><div class="line">	Animate* boomAnimate();</div><div class="line">	void blowUp();</div><div class="line"></div><div class="line">	//移除飞机</div><div class="line">	void removePlane();</div><div class="line"></div><div class="line">	//获取生命值</div><div class="line">	int getHP();</div><div class="line"></div><div class="line">	//增加生命值</div><div class="line">	void addHP(int t);</div><div class="line"></div><div class="line">	//血条更新</div><div class="line">	void setBloodbar();</div><div class="line"></div><div class="line">	// 减少生命值,return false：飞机死亡</div><div class="line">	bool loseHP(int t);</div><div class="line"></div><div class="line">	// 获取等级</div><div class="line">	int getAirLevel();</div><div class="line"></div><div class="line">	//升级</div><div class="line">	void airLevelUp();</div><div class="line"></div><div class="line">public:</div><div class="line">	static MyPlane* instancePlane;	//飞机实体</div><div class="line">	CCProgressTimer *pBloodProGress; //血条</div><div class="line"></div><div class="line">private:</div><div class="line">	int m_hp;</div><div class="line">	Label* hpItem1;</div><div class="line">	Label* hpItem2;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">//SaveData.h</div><div class="line">#pragma once</div><div class="line">#ifndef __SaveData_H__</div><div class="line">#define __SaveData_H__</div><div class="line"></div><div class="line">#include &quot;cocos2d.h&quot;</div><div class="line"></div><div class="line">USING_NS_CC;</div><div class="line"></div><div class="line">class SaveData : public Ref</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	SaveData();</div><div class="line">	~SaveData();</div><div class="line">public:</div><div class="line">	bool init();</div><div class="line">	CREATE_FUNC(SaveData);</div><div class="line">private:</div><div class="line">	//用户数据操作的成员变量</div><div class="line">	UserDefault * m_userDefault;</div><div class="line">	//该集合中保存的是分数的记录，因为分数是基本数据类型，放到Vector中的内容必须是Ref的子类，所以要用Value</div><div class="line">	//封装一下，但封装完毕却不是使用vector来存放，而是用ValueVector</div><div class="line">	ValueVector m_vector;</div><div class="line">	//记录玩家的当前分数</div><div class="line">	CC_SYNTHESIZE(int, m_score, Score);</div><div class="line">public:</div><div class="line">	void save();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android_ping不通电脑]]></title>
      <url>http://blog.acbingo.cn/2016/04/14/android_ping%E4%B8%8D%E9%80%9A%E7%94%B5%E8%84%91/</url>
      <content type="html"><![CDATA[<p>今天在测试的时候发现Android ping不通我的win10，而win10可以ping通android设备。下面是解决方法。</p>
<a id="more"></a>
<p>我们安装完Win10之后却发现在其他电脑上根本没有办法ping通你自己的Win10这台电脑的IP地址；</p>
<p>当然如果你把Win10的防火墙关闭之后也可以ping通的；</p>
<p>但是我们今天要在开启防火墙的情况让其他电脑能ping我们的Win10电脑</p>
<p><a href="http://jingyan.baidu.com/article/72ee561ab11933e16138dfc9.html" target="_blank" rel="external">http://jingyan.baidu.com/article/72ee561ab11933e16138dfc9.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android创建与连接热点]]></title>
      <url>http://blog.acbingo.cn/2016/04/14/android%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%9E%E6%8E%A5%E7%83%AD%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>//Todo<br>这是我正在做的。当我做完整个软件后，会回来再进行整理<br><a id="more"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_算法_递归]]></title>
      <url>http://blog.acbingo.cn/2016/04/01/coursera_%E7%AE%97%E6%B3%95_%E9%80%92%E5%BD%92/</url>
      <content type="html"><![CDATA[<p>coursera上北大mooc算法课递归一章的课后习题<br><a id="more"></a></p>
<h1 id="编程题＃1：-完美覆盖"><a href="#编程题＃1：-完美覆盖" class="headerlink" title="编程题＃1： 完美覆盖"></a>编程题＃1： 完美覆盖</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>一张普通的国际象棋棋盘，它被分成 8 乘 8 (8 行 8 列) 的 64 个方格。设有形状一样的多米诺牌，每张牌恰好覆盖棋盘上相邻的两个方格，即一张多米诺牌是一张 1 行 2 列或者 2 行 1 列的牌。那么，是否能够把 32 张多米诺牌摆放到棋盘上，使得任何两张多米诺牌均不重叠，每张多米诺牌覆盖两个方格，并且棋盘上所有的方格都被覆盖住？我们把这样一种排列称为棋盘被多米诺牌完美覆盖。这是一个简单的排列问题，同学们能够很快构造出许多不同的完美覆盖。但是，计算不同的完美覆盖的总数就不是一件容易的事情了。不过，同学们 发挥自己的聪明才智，还是有可能做到的。</p>
<p>现在我们通过计算机编程对 3 乘 n 棋盘的不同的完美覆盖的总数进行计算。</p>
<p>任务</p>
<p>对 3 乘 n 棋盘的不同的完美覆盖的总数进行计算。</p>
<p>输入</p>
<p>一次输入可能包含多行，每一行分别给出不同的 n 值 ( 即 3 乘 n 棋盘的列数 )。当输入 -1 的时候结束。</p>
<p>n 的值最大不超过 30.</p>
<p>输出</p>
<p>针对每一行的 n 值，输出 3 乘 n 棋盘的不同的完美覆盖的总数。</p>
<p>样例输入</p>
<p>2<br>8<br>12<br>-1<br>样例输出</p>
<p>3<br>153<br>2131</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>想了很久也没想出来。<br>最后参考的这里:<a href="http://www.cnblogs.com/drizzlecrj/archive/2008/12/23/1360670.html" target="_blank" rel="external">b牌棋盘完美覆盖数</a><br>得到结论：<br>n=3的时候可以推倒出递推式</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/drizzlecrj/3_m_formula.jpg" alt=""></p>
<p>以及边界条件</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/drizzlecrj/3_m_boundary.jpg" alt=""></p>
<p>其中am代表在左上角将第一块骨牌横着放的总方案数，bm代表在左上角竖着放第一块骨牌的方案数。</p>
<p>不难得出am的表达式，继而使用矩阵幂求出大数据求模的解。周源在WC08的讲稿中给出了am和bm的生成函数：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/drizzlecrj/3_m_generate.jpg" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>有了公式，代码就很好写了。尝试用java类似的封装结构来写一次<br>比较坑的是，n==0的时候答案是1，（一直认为是0，导致我wa好几次都没找到错误）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int a[50];</div><div class="line">int b[50];</div><div class="line">class Fischer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Fischer()</div><div class="line">	&#123;</div><div class="line">		a[0] = 1; a[1] = 0;</div><div class="line">		b[0] = 0; b[1] = 1;</div><div class="line">		for (int i = 2; i &lt; 50; i++) &#123;</div><div class="line">			a[i] = -1;</div><div class="line">			b[i] = -1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int Cala(int m) &#123;</div><div class="line">		if (a[m] == -1)</div><div class="line">			a[m] = 2 * Calb(m - 1) + Cala(m - 2);</div><div class="line">		return a[m];</div><div class="line">	&#125;</div><div class="line">	int Calb(int m) &#123;</div><div class="line">		if (b[m] == -1)</div><div class="line">			b[m] = Cala(m - 1) + Calb(m - 2);</div><div class="line">		return b[m];</div><div class="line">	&#125;</div><div class="line">	int Cal(int m) &#123;</div><div class="line">		return Cala(m) + Calb(m);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	//cin &gt;&gt; n;</div><div class="line">	Fischer ans;</div><div class="line">	while (cin &gt;&gt; n&amp;&amp;n &gt;= 0) &#123;</div><div class="line">		if (n%2==1) cout &lt;&lt; 0 &lt;&lt; endl;</div><div class="line">		else cout &lt;&lt; ans.Cal(n) &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：-文件结构“图”"><a href="#编程题＃2：-文件结构“图”" class="headerlink" title="编程题＃2： 文件结构“图”"></a>编程题＃2： 文件结构“图”</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>在计算机上看到文件系统的结构通常很有用。Microsoft Windows上面的”explorer”程序就是这样的一个例子。但是在有图形界面之前，没有图形化的表示方法的，那时候最好的方式是把目录和文件的结构显示成一个”图”的样子，而且使用缩排的形式来表示目录的结构。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ROOT</div><div class="line">|         dir1</div><div class="line">|         |         file1</div><div class="line">|         |         file2</div><div class="line">|         |         file3</div><div class="line">|         dir2</div><div class="line">|         dir3</div><div class="line">|         |         file1</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>这个图说明：ROOT目录包括两个文件和三个子目录。第一个子目录包含3个文件，第二个子目录是空的，第三个子目录包含一个文件。</p>
<p>输入</p>
<p>你的任务是写一个程序读取一些测试数据。每组测试数据表示一个计算机的文件结构。每组测试数据以’*’结尾，而所有合理的输入数据以’#’结尾。一组测试数据包括一些文件和目录的名字（虽然在输入中我们没有给出，但是我们总假设ROOT目录是最外层的目录）。在输入中,以’]’表示一个目录的内容的结束。目录名字的第一个字母是’d’，文件名字的第一个字母是’f’。文件名可能有扩展名也可能没有（比如fmyfile.dat和fmyfile）。文件和目录的名字中都不包括空格。</p>
<p>输出</p>
<p>在显示一个目录中内容的时候，先显示其中的子目录（如果有的话），然后再显示文件（如果有的话）。文件要求按照名字的字母表的顺序显示（目录不用按照名字的字母表顺序显示，只需要按照目录出现的先后显示）。对每一组测试数据，我们要先输出”DATA SET x:”，这里x是测试数据的编号（从1开始）。在两组测试数据之间要输出一个空行来隔开。</p>
<p>你需要注意的是，我们使用一个’|’和5个空格来表示出缩排的层次。</p>
<p>样例输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">file1</div><div class="line">file2</div><div class="line">dir3</div><div class="line">dir2</div><div class="line">file1</div><div class="line">file2</div><div class="line">]</div><div class="line">]</div><div class="line">file4</div><div class="line">dir1</div><div class="line">]</div><div class="line">file3</div><div class="line">*</div><div class="line">file2</div><div class="line">file1</div><div class="line">*</div><div class="line">#</div></pre></td></tr></table></figure></p>
<p>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">DATA SET 1:</div><div class="line">ROOT</div><div class="line">|        dir3</div><div class="line">|        |        dir2</div><div class="line">|        |        file1</div><div class="line">|        |        file2</div><div class="line">|        dir1</div><div class="line">file1</div><div class="line">file2</div><div class="line">file3</div><div class="line">file4</div><div class="line"></div><div class="line">DATA SET 2:</div><div class="line">ROOT</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>提示</p>
<p>一个目录和它的子目录处于不同的层次</p>
<p>一个目录和它的里面的文件处于同一层次</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>显而易见，考你递归的。没什么可说的。<br>不过这里复习了一下c++的比较函数，来实现优先队列的自定义排序<br>参考：<a href="http://www.cnblogs.com/lengbingshy/p/3491192.html" target="_blank" rel="external">C++中定义比较函数的三种方法</a></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">struct cmp</div><div class="line">&#123;</div><div class="line">	bool operator()(string a, string b)</div><div class="line">	&#123;</div><div class="line">		return a &gt; b;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">void print_blank() &#123;</div><div class="line">	printf(&quot;|     &quot;);</div><div class="line">&#125;</div><div class="line">void print(int deep, string s) &#123;</div><div class="line">	for (int i = 0; i &lt; deep; i++)</div><div class="line">		print_blank();</div><div class="line">	printf(&quot;%s\n&quot;, s.c_str());</div><div class="line">&#125;</div><div class="line">int fun(int deep,string s) &#123;</div><div class="line">	priority_queue&lt;string, vector&lt;string&gt;, cmp&gt;  q;</div><div class="line">	if (deep == 0) &#123;</div><div class="line">		printf(&quot;ROOT\n&quot;);</div><div class="line">		if (s[0] == &apos;f&apos;) q.push(s);</div><div class="line">		if (s[0] == &apos;d&apos;) fun(deep + 1, s);</div><div class="line">		if (s[0] == &apos;]&apos; || s[0] == &apos;*&apos;) &#123;</div><div class="line">			while (!q.empty()) &#123;</div><div class="line">				print(deep, q.top());</div><div class="line">				q.pop();</div><div class="line">			&#125;</div><div class="line">			return 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else print(deep, s);</div><div class="line">	while (cin &gt;&gt; s) &#123;</div><div class="line">		if (s[0] == &apos;f&apos;) q.push(s);</div><div class="line">		if (s[0] == &apos;d&apos;) fun(deep + 1, s);</div><div class="line">		if (s[0] == &apos;]&apos; || s[0] == &apos;*&apos;) &#123;</div><div class="line">			while (!q.empty()) &#123;</div><div class="line">				print(deep, q.top());</div><div class="line">				q.pop();</div><div class="line">			&#125;</div><div class="line">			return 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int main() &#123;</div><div class="line">	int t = 0;</div><div class="line">	while (1) &#123;</div><div class="line">		t++;</div><div class="line">		string s;</div><div class="line">		cin &gt;&gt; s;</div><div class="line">		if (s[0] == &apos;#&apos;)return 0;</div><div class="line">		if (t &gt; 1) printf(&quot;\n&quot;);</div><div class="line">		printf(&quot;DATA SET %d:\n&quot;, t);</div><div class="line">		</div><div class="line">		if(!fun(0,s)) return 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_操作系统学习笔记_计算机操作系统概述]]></title>
      <url>http://blog.acbingo.cn/2016/03/30/coursera_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p>
<p>在操作系统中，并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<ol>
<li>程序与计算不再一一对应，一个程序副本可以有多个计算</li>
<li>并发程序之间有相互制约关系，直接制约体现为一个程序需要另一个程序的计算结果，间接制约体现为多个程序竞争某一资源，如处理机、缓冲区等。</li>
<li>并发程序在执行中是走走停停，断续推进的。</li>
</ol>
<p>在网络服务器上，并发是指同一时刻能处理的连接数，比如，服务器能建立1000个TCP连接，即服务器同时维护了1000个socket，这个服务器的并发量就是1000，但是服务器可能只有单核或者8核，16核等，总之对这1000个socket连接的处理也是分时来做的。每个socket服务器处理的时间如果是1s，那么该服务器1s内可以处理完1000个请求，如果每个socket处理100ms的话，那么该服务器1s内可以处理10000个请求。</p>
<p>在这里我们先抛出一些概念，如果这些概念都弄清楚了，并发和并行基本就清楚了。</p>
<p>会话：在我们用电脑工作时，打开的一个窗口或一个Web页面，我们可以把它叫做一个“会话”，扩展到web服务器上，要维护很多个用户的web页面访问，我们可以认为服务器管理了多个“会话”。</p>
<p>并发连接数：网站有时候报错：“HTTP Error 503. The service is unavailable”。但刷一两下又正常，估计很可能是超过网站的最大并发连接数了。并发连接指网络流量管理设备或代理服务器对其业务信息流的处理能力，是能够同时处理的点对点连接的最大数目，它反映出设备对多个连接的访问控制能力和连接状态跟踪能力，这个参数的大小直接影响到设备所能支持的最大信息点数。</p>
<p>并发可以理解为服务器最多维护多少个会话数，并行则不一样，它关系的是有多少个会话是在同时进行，假如有两台服务器（进程），可能并行的数量是2，而并发的数量是1000。我们还可以对比下吞吐量和带宽的概念。</p>
<p>吞吐量与带宽的区分：吞吐量和带宽是很容易搞混的一个词，两者的单位都是Mbps。先来看两者对应的英语，吞吐量：throughput；带宽：Max net bitrate。当讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码在计算机网络中又称为线速。可以说以太网的带宽是10Mbps。但是需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。通常更倾向于用“吞吐量”一词来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p>
<p>带宽可以理解成是并行，即同时可以有10M 个bit（0，1）在线路中传输。而吞吐量类似并发，指主机每秒可以处理2M个bit。比喻有些不是很恰当，但仔细体会下，有些类似之处。</p>
<h1 id="管态和目态"><a href="#管态和目态" class="headerlink" title="管态和目态"></a>管态和目态</h1><p>目态：<br>目态又称为用户态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。<br>管态：<br>管态又称系统态，核心态或特权状态。<br>CPU有两个状态，分别是管态和目态，当CPU处理系统程序的时候，CPU会转为管态，CPU在管态下可以执行指令系统的全集。（包括特权指令与非特权指令）<br>自：百度百科</p>
<p>CPU状态分为管态和目态，管态又称为特权态，系统态或核心态。CPU在管态下可以执行指令系统的全集。通常，操作系统在管态下运行。<br>  目态又称为常态或用户态。机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行，如果用户程序在目态下执行特权指令，硬件将发生中断，由操作系统获得控制，特权指令执行被禁止，这样可以防止用户程序有意或无意地破坏系统。<br>  从目态转换为管态的唯一途径是中断;从管态到目态可以通过修改程序状态字来实现，这将伴随这由操作系统程序到用户程序的转换。<br>  硬件资源不可由用户程序在目态下直接驱动，I/O指令是特权指令，只能由系统程序在管态进行控制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编译原理_中科大公开课_第一单元编译器介绍作业]]></title>
      <url>http://blog.acbingo.cn/2016/03/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86_%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%85%AC%E5%BC%80%E8%AF%BE_%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<p>第一节课就让实现一个小的编译器。。。。。<br><a id="more"></a></p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>在课程中，我们讨论一个小型的从表达式语言Sum到栈计算机Stack的编译器，<br>在附件中，你能找到对该编译器的一个C语言实现，但这个实现是不完整的，请你<br>把缺少的代码补充完整（不超过10行代码）。<br>加分题：实现常量折叠优化。</p>
</blockquote>
<h1 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define TODO()                                  \</div><div class="line">  do&#123;                                                           \</div><div class="line">    printf (&quot;\nAdd your code here: file \&quot;%s\&quot;, line %d\n&quot;,     \</div><div class="line">            __FILE__, __LINE__);                                \</div><div class="line">  &#125;while(0)</div><div class="line"></div><div class="line">///////////////////////////////////////////////</div><div class="line">// Data structures for the Sum language.</div><div class="line">enum Exp_Kind_t &#123;EXP_INT, EXP_SUM&#125;;</div><div class="line">struct Exp_t</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Exp_Int</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">  int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Exp_Sum</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">  struct Exp_t *left;</div><div class="line">  struct Exp_t *right;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// &quot;constructors&quot;</div><div class="line">struct Exp_t *Exp_Int_new (int i)</div><div class="line">&#123;</div><div class="line">  struct Exp_Int *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = EXP_INT;</div><div class="line">  p-&gt;i = i;</div><div class="line">  return (struct Exp_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Exp_t *Exp_Sum_new (struct Exp_t *left, struct Exp_t *right)</div><div class="line">&#123;</div><div class="line">  struct Exp_Sum *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = EXP_SUM;</div><div class="line">  p-&gt;left = left;</div><div class="line">  p-&gt;right = right;</div><div class="line">  return (struct Exp_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &quot;printer&quot;</div><div class="line">void Exp_print (struct Exp_t *exp)</div><div class="line">&#123;</div><div class="line">  switch (exp-&gt;kind)&#123;</div><div class="line">  case EXP_INT:&#123;</div><div class="line">    struct Exp_Int *p = (struct Exp_Int *)exp;</div><div class="line">    printf (&quot;%d&quot;, p-&gt;i);</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  case EXP_SUM:&#123;</div><div class="line">    struct Exp_Sum *p = (struct Exp_Sum *)exp;</div><div class="line">    Exp_print (p-&gt;left);</div><div class="line">    printf (&quot;+&quot;);</div><div class="line">    Exp_print (p-&gt;right);</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  default:</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//////////////////////////////////////////////</div><div class="line">// Data structures for the Stack language.</div><div class="line">enum Stack_Kind_t &#123;STACK_ADD, STACK_PUSH&#125;;</div><div class="line">struct Stack_t</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Stack_Add</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Stack_Push</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">  int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// &quot;constructors&quot;</div><div class="line">struct Stack_t *Stack_Add_new ()</div><div class="line">&#123;</div><div class="line">  struct Stack_Add *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = STACK_ADD;</div><div class="line">  return (struct Stack_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Stack_t *Stack_Push_new (int i)</div><div class="line">&#123;</div><div class="line">  struct Stack_Push *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = STACK_PUSH;</div><div class="line">  p-&gt;i = i;</div><div class="line">  return (struct Stack_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// instruction list</div><div class="line">struct List_t</div><div class="line">&#123;</div><div class="line">  struct Stack_t *instr;</div><div class="line">  struct List_t *next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct List_t *List_new (struct Stack_t *instr, struct List_t *next)</div><div class="line">&#123;</div><div class="line">  struct List_t *p = malloc (sizeof (*p));</div><div class="line">  p-&gt;instr = instr;</div><div class="line">  p-&gt;next = next;</div><div class="line">  return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &quot;printer&quot;</div><div class="line">void List_reverse_print (struct List_t *list)</div><div class="line">&#123;</div><div class="line">  TODO();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//////////////////////////////////////////////////</div><div class="line">// a compiler from Sum to Stack</div><div class="line">struct List_t *all = 0;</div><div class="line"></div><div class="line">void emit (struct Stack_t *instr)</div><div class="line">&#123;</div><div class="line">  all = List_new (instr, all);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void compile (struct Exp_t *exp)</div><div class="line">&#123;</div><div class="line">  switch (exp-&gt;kind)&#123;</div><div class="line">  case EXP_INT:&#123;</div><div class="line">    struct Exp_Int *p = (struct Exp_Int *)exp;</div><div class="line">    emit (Stack_Push_new (p-&gt;i));</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  case EXP_SUM:&#123;</div><div class="line">    TODO();</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  default:</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//////////////////////////////////////////////////</div><div class="line">// program entry</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  printf(&quot;Compile starting\n&quot;);</div><div class="line">  // build an expression tree:</div><div class="line">  //            +</div><div class="line">  //           / \</div><div class="line">  //          +   4</div><div class="line">  //         / \</div><div class="line">  //        2   3</div><div class="line">  struct Exp_t *exp = Exp_Sum_new (Exp_Sum_new(Exp_Int_new (2)</div><div class="line">                                               , Exp_Int_new (3))</div><div class="line">                                   , Exp_Int_new (4));</div><div class="line">  // print out this tree:</div><div class="line">  printf (&quot;the expression is:\n&quot;);</div><div class="line">  Exp_print (exp);</div><div class="line">  // compile this tree to Stack machine instructions</div><div class="line">  compile (exp);</div><div class="line"></div><div class="line">  // print out the generated Stack instructons:</div><div class="line">  List_reverse_print (all);</div><div class="line">  </div><div class="line">  printf(&quot;\nCompile finished\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>要想做题，必须理解老师给出的代码的运行原理啊<br><strong>注意，代码中用到了共用体的知识点</strong><br>学了共用体后第一次在应用中见到，原来蛮好用的嘛</p>
<p>编译器分为前端和后端，前端负责将输入语言进行分析，并保存下来一颗语法树;后端依据这个语法树将其翻译成目标语言。<br>如果你之前接触过面向对象那这段代码就好理解了。<br>Exp_t可以理解成Exp_Int和Exp_Sum的父类，Exp_Int_new()生成一个叶子节点，Exp_Sum_new()将两个节点（子树）合并，Exp_print()后续遍历这颗二叉树。<br>同理，Stack_t理解为Stack_Add和Stack_Push的父类。Stack_Add_new()生成一个add语句，Stack_Push_new()生成一个push语句。<br>最后将生成的语句用链表链接来(List_t 和List_new()结合emit()函数)。<br>显然，List_reverse_print是让你反向输出这条链表。下面是代码：</p>
<h2 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (list == NULL) return ;</div><div class="line">List_reverse_print(list-&gt;next);</div><div class="line">switch (list-&gt;instr-&gt;kind)</div><div class="line">&#123;</div><div class="line">case STACK_PUSH:</div><div class="line">    printf(&quot;\npush %d&quot;, ((struct Stack_Push *)list-&gt;instr)-&gt;i);</div><div class="line">    break;</div><div class="line">case STACK_ADD:</div><div class="line">    printf(&quot;\nadd&quot;);</div><div class="line">    break;</div><div class="line">default:</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>compile()当然就是最后的后端啦，执行翻译工作。<br>同样需要递归的遍历这课树进行翻译，下面是第二段代码</p>
<h2 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct Exp_Sum *p = (struct Exp_Sum *)exp;</div><div class="line">if(p-&gt;left != NULL) compile(p-&gt;left);</div><div class="line">if(p-&gt;right != NULL) compile(p-&gt;right);</div><div class="line">emit(Stack_Add_new());</div><div class="line">break;</div></pre></td></tr></table></figure>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>实现常量折叠优化。也就是对那个二叉树进行优化。<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//            +</div><div class="line">//           / \</div><div class="line">//          +   4</div><div class="line">//         / \</div><div class="line">//        2   3</div></pre></td></tr></table></figure></p>
<p>一次优化成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//            +</div><div class="line">//           / \</div><div class="line">//          5   4</div></pre></td></tr></table></figure></p>
<p>最终优化成一个数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//           9</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>(题目没有给出要求，但是我认为应该注意到的地方)</p>
<ol>
<li>子树含有变量的情况下显然不能优化</li>
<li>注意避免内存泄漏<h2 id="优化函数"><a href="#优化函数" class="headerlink" title="优化函数"></a>优化函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">struct Exp_t* optimize(struct Exp_t* exp) &#123;</div><div class="line">	switch (exp-&gt;kind)</div><div class="line">	&#123;</div><div class="line">	case EXP_INT:</div><div class="line">		return exp;</div><div class="line">		break;</div><div class="line">	case EXP_SUM:</div><div class="line">	&#123;</div><div class="line">		struct Exp_Sum *k = (struct Exp_Sum *)exp;</div><div class="line">		if ((k)-&gt;left-&gt;kind == EXP_SUM) &#123;</div><div class="line">			struct Exp_t* p = optimize((struct Exp_t*)(k)-&gt;left);</div><div class="line">			k-&gt;left = p;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if ((k)-&gt;right-&gt;kind == EXP_SUM) &#123;</div><div class="line">			struct Exp_t* p = optimize((struct Exp_t*)(k)-&gt;right);</div><div class="line">			k-&gt;right = p;</div><div class="line">		&#125;</div><div class="line">		if (k-&gt;left-&gt;kind==EXP_INT&amp;&amp;k-&gt;right-&gt;kind==EXP_INT)&#123;//可以优化的情况下</div><div class="line">			struct Exp_Int* p = malloc(sizeof(*p));</div><div class="line">			p-&gt;i = ((struct Exp_Int *)((k)-&gt;left))-&gt;i + ((struct Exp_Int *)((k)-&gt;right))-&gt;i;</div><div class="line">			free(k-&gt;left);</div><div class="line">			free(k-&gt;right);</div><div class="line">			free(k);//释放内存</div><div class="line">			p-&gt;kind = EXP_INT;</div><div class="line">			return (struct Exp_t*)p;</div><div class="line">		&#125;</div><div class="line">		//有变量的情况下</div><div class="line">		return exp;</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">	default:</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="最终代码-含优化-："><a href="#最终代码-含优化-：" class="headerlink" title="最终代码(含优化)："></a>最终代码(含优化)：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define TODO()                                  \</div><div class="line">  do&#123;                                                           \</div><div class="line">    printf (&quot;\nAdd your code here: file \&quot;%s\&quot;, line %d\n&quot;,     \</div><div class="line">            __FILE__, __LINE__);                                \</div><div class="line">  &#125;while(0)</div><div class="line"></div><div class="line">///////////////////////////////////////////////</div><div class="line">// Data structures for the Sum language.</div><div class="line">enum Exp_Kind_t &#123;EXP_INT, EXP_SUM&#125;;</div><div class="line">struct Exp_t</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Exp_Int</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">  int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Exp_Sum</div><div class="line">&#123;</div><div class="line">  enum Exp_Kind_t kind;</div><div class="line">  struct Exp_t *left;</div><div class="line">  struct Exp_t *right;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// &quot;constructors&quot;</div><div class="line">struct Exp_t *Exp_Int_new (int i)</div><div class="line">&#123;</div><div class="line">  struct Exp_Int *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = EXP_INT;</div><div class="line">  p-&gt;i = i;</div><div class="line">  return (struct Exp_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Exp_t *Exp_Sum_new (struct Exp_t *left, struct Exp_t *right)</div><div class="line">&#123;</div><div class="line">  struct Exp_Sum *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = EXP_SUM;</div><div class="line">  p-&gt;left = left;</div><div class="line">  p-&gt;right = right;</div><div class="line">  return (struct Exp_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &quot;printer&quot;</div><div class="line">void Exp_print (struct Exp_t *exp)</div><div class="line">&#123;</div><div class="line">  switch (exp-&gt;kind)&#123;</div><div class="line">  case EXP_INT:&#123;</div><div class="line">    struct Exp_Int *p = (struct Exp_Int *)exp;</div><div class="line">    printf (&quot;%d&quot;, p-&gt;i);</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  case EXP_SUM:&#123;</div><div class="line">    struct Exp_Sum *p = (struct Exp_Sum *)exp;</div><div class="line">    Exp_print (p-&gt;left);</div><div class="line">    printf (&quot;+&quot;);</div><div class="line">    Exp_print (p-&gt;right);</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  default:</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//////////////////////////////////////////////</div><div class="line">// Data structures for the Stack language.</div><div class="line">enum Stack_Kind_t &#123;STACK_ADD, STACK_PUSH&#125;;</div><div class="line">struct Stack_t</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Stack_Add</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Stack_Push</div><div class="line">&#123;</div><div class="line">  enum Stack_Kind_t kind;</div><div class="line">  int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// &quot;constructors&quot;</div><div class="line">struct Stack_t *Stack_Add_new ()</div><div class="line">&#123;</div><div class="line">  struct Stack_Add *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = STACK_ADD;</div><div class="line">  return (struct Stack_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Stack_t *Stack_Push_new (int i)</div><div class="line">&#123;</div><div class="line">  struct Stack_Push *p = malloc (sizeof(*p));</div><div class="line">  p-&gt;kind = STACK_PUSH;</div><div class="line">  p-&gt;i = i;</div><div class="line">  return (struct Stack_t *)p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// instruction list</div><div class="line">struct List_t</div><div class="line">&#123;</div><div class="line">  struct Stack_t *instr;</div><div class="line">  struct List_t *next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct List_t *List_new (struct Stack_t *instr, struct List_t *next)</div><div class="line">&#123;</div><div class="line">  struct List_t *p = malloc (sizeof (*p));</div><div class="line">  p-&gt;instr = instr;</div><div class="line">  p-&gt;next = next;</div><div class="line">  return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &quot;printer&quot;</div><div class="line">void List_reverse_print (struct List_t *list)</div><div class="line">&#123;</div><div class="line">  //TODO();</div><div class="line">    if (list == NULL) return ;</div><div class="line">    List_reverse_print(list-&gt;next);</div><div class="line">    switch (list-&gt;instr-&gt;kind)</div><div class="line">    &#123;</div><div class="line">    case STACK_PUSH:</div><div class="line">        printf(&quot;\npush %d&quot;, ((struct Stack_Push *)list-&gt;instr)-&gt;i);</div><div class="line">        break;</div><div class="line">    case STACK_ADD:</div><div class="line">        printf(&quot;\nadd&quot;);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//////////////////////////////////////////////////</div><div class="line">// a compiler from Sum to Stack</div><div class="line">struct List_t *all = 0;</div><div class="line"></div><div class="line">void emit (struct Stack_t *instr)</div><div class="line">&#123;</div><div class="line">  all = List_new (instr, all);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void compile (struct Exp_t *exp)</div><div class="line">&#123;</div><div class="line">  switch (exp-&gt;kind)&#123;</div><div class="line">  case EXP_INT:&#123;</div><div class="line">    struct Exp_Int *p = (struct Exp_Int *)exp;</div><div class="line">    emit (Stack_Push_new (p-&gt;i));</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  case EXP_SUM:&#123;</div><div class="line">    //TODO();</div><div class="line">    struct Exp_Sum *p = (struct Exp_Sum *)exp;</div><div class="line">    if(p-&gt;left != NULL) compile(p-&gt;left);</div><div class="line">    if(p-&gt;right != NULL) compile(p-&gt;right);</div><div class="line">    emit(Stack_Add_new());</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">  default:</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Exp_t* optimize(struct Exp_t* exp) &#123;</div><div class="line">	switch (exp-&gt;kind)</div><div class="line">	&#123;</div><div class="line">	case EXP_INT:</div><div class="line">		return exp;</div><div class="line">		break;</div><div class="line">	case EXP_SUM:</div><div class="line">	&#123;</div><div class="line">		struct Exp_Sum *k = (struct Exp_Sum *)exp;</div><div class="line">		if ((k)-&gt;left-&gt;kind == EXP_SUM) &#123;</div><div class="line">			struct Exp_t* p = optimize((struct Exp_t*)(k)-&gt;left);</div><div class="line">			k-&gt;left = p;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if ((k)-&gt;right-&gt;kind == EXP_SUM) &#123;</div><div class="line">			struct Exp_t* p = optimize((struct Exp_t*)(k)-&gt;right);</div><div class="line">			k-&gt;right = p;</div><div class="line">		&#125;</div><div class="line">		if (k-&gt;left-&gt;kind==EXP_INT&amp;&amp;k-&gt;right-&gt;kind==EXP_INT)&#123;//可以优化的情况下</div><div class="line">			struct Exp_Int* p = malloc(sizeof(*p));</div><div class="line">			p-&gt;i = ((struct Exp_Int *)((k)-&gt;left))-&gt;i + ((struct Exp_Int *)((k)-&gt;right))-&gt;i;</div><div class="line">			free(k-&gt;left);</div><div class="line">			free(k-&gt;right);</div><div class="line">			free(k);//释放内存</div><div class="line">			p-&gt;kind = EXP_INT;</div><div class="line">			return (struct Exp_t*)p;</div><div class="line">		&#125;</div><div class="line">		//有变量的情况下</div><div class="line">		return exp;</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">	default:</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//////////////////////////////////////////////////</div><div class="line">// program entry</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  printf(&quot;Compile starting\n&quot;);</div><div class="line">  // build an expression tree:</div><div class="line">  //            +</div><div class="line">  //           / \</div><div class="line">  //          +   4</div><div class="line">  //         / \</div><div class="line">  //        2   3</div><div class="line">  struct Exp_t *exp = Exp_Sum_new (Exp_Sum_new(Exp_Int_new (2)</div><div class="line">                                               , Exp_Int_new (3))</div><div class="line">                                   , Exp_Int_new (4));</div><div class="line">  // print out this tree:</div><div class="line">  printf (&quot;the expression is:\n&quot;);</div><div class="line">  Exp_print (exp);</div><div class="line"></div><div class="line">  //优化</div><div class="line">  exp=optimize(exp);</div><div class="line">  // compile this tree to Stack machine instructions</div><div class="line">  compile (exp);</div><div class="line"></div><div class="line">  // print out the generated Stack instructons:</div><div class="line">  List_reverse_print (all);</div><div class="line"></div><div class="line">  printf(&quot;\nCompile finished\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从做题到写完论文花了两个小时时间~<br>编译原理确实还蛮有意思的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于Inflater与findViewById()的思考]]></title>
      <url>http://blog.acbingo.cn/2016/03/25/%E5%85%B3%E4%BA%8EInflater%E4%B8%8EfindViewById()%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>学习Android的时候关于Inflater与findViewById()的思考<br><a id="more"></a></p>
<h1 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h1><p>官网的docs是这么描述的</p>
<blockquote>
<p>Instantiates a layout XML file into its corresponding View objects. It is never used directly. Instead, use getLayoutInflater() or getSystemService(Class) to retrieve a standard LayoutInflater instance that is already hooked up to the current context and correctly configured for the device you are running on. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LayoutInflater inflater = (LayoutInflater)context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>retrieve的意思是收回、取回的意思。也就是说LayoutInflater的作用是，把一个View的对象与XML布局文件关联。R会根据你的布局文件自动创建相应的类并实例化出来一个，注意，是一个。<br>可以用上面那个函数获取这个实例。</p>
<p>通常会用到这个函数来set layout，并实例化一个new view。<br>inflater.inflate()</p>
<blockquote>
<p>View    inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</p>
</blockquote>
<p>parser传入自定义的布局文件，root传入container,attachToRoot一般传入false<br>一般在自定义框架里这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123;</div><div class="line">    view = inflater.inflate(R.layout.news_content_frag, container, false);</div><div class="line">    return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过重载父类Fragment的onCreateView函数</p>
<h1 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h1><p>findViewById则类似于LayoutInflater，不过findViewById是根据layout中（控件）设置的id来获取其对应的实例（该实例也是R提前为你生成好的）</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>我看的《第一行代码》中3.5.3节讲到了提升 ListView 的运行效率<br>一开始理解的并不正确，以为是内存上的优化，其实是时间上的优化。省去了find的时间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_魔兽世界终结版]]></title>
      <url>http://blog.acbingo.cn/2016/03/11/coursera_%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C%E7%BB%88%E7%BB%93%E7%89%88/</url>
      <content type="html"><![CDATA[<p>五个下午的时间！！！！终于过了！！<br>有史以来做的最复杂的一个题<br><a id="more"></a><br>这是我迄今为止做的最复杂也最具有挑战的一个oj作业。虽然之前做过比这个规模一些作业项目，但是往往有简单的模块框架，模块之前的关系也只是有些简单的联系，代码量虽然多，但是并不复杂。然而，然而这个题不仅有着复杂的逻辑关系，而且是oj测试啊！！意味着你需要实现所有特性，而且不能有一丁点的错误！<br>从决定开始做这个题，到最后两个平台AC，前前后后大概花了5个下午的时间。<br>在读完题后（相信我，为了搞懂每一个细节，题目我读了整整一个小时），coding前，大概花了两个到三个小时，画图、构思程序应该有着什么样的结构，都应该有哪些类，类之前的关系是什么样的，类中应该有哪些元素。。。。等等<br>不过即使想了这么长时间，coding途中也遇到不少问题导致最后的代码封装性差、结构也不是那么美好。。<br>coding时很多地方抽象得并不合理，为了少量修改目前已经完成的代码（不想去动大结构）而作出妥协。结果越到后面越发现整个程序非常混乱，各个类耦合度过高，程序的健壮性十分差。常常是为了一个新功能的实现，要引起三四五六处修改，一不注意就会留下bug。最终调试bug的时候，对于前期没构思好结构的后加的代码修改起来相当麻烦。<br>虽然我一直在注重代码的重用性，但是到最后我还是感觉代码的重用性不高，程序的结构还能优化的更好<br>做完了这个作业，让我感觉我就好像是重新学习了c艹，c艹的继承和多态、虚函数等一些特性，从认识到了解终于可以做到了熟悉掌握。<br>我要是有精力，一定要重构一下= =。。。<br>从一开始就认认真真的画类图，把游戏角色类（建筑、武士、武器）和游戏逻辑类、单元测试类的各自特征和功能梳理得更有条理，把整条游戏流程通过写伪代码的方式弄个清晰明了后再开始coding。。<br>总之，编码前的准备是否足够充分决定了你编码时和debug时的痛苦程度啊</p>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>我认为魔兽世界终结版这题有错误！！</p>
<p>一开始我在poj上提交通过了，然后再从coursera上提交居然WA</p>
<p>我结合讨论区<a href="https://www.coursera.org/learn/cpp-chengxu-sheji/programming/lu7ei/bian-cheng-zuo-ye-duo-tai-yu-xu-han-shu/discussions/8nJlFlpDEeWVrg78i3ja5Q" target="_blank" rel="external">花雨</a>同学的留言再测试了下数据。</p>
<p>poj上提供的27组测试数据中，在case 16：</p>
<p>006:00 blue dragon 7 born</p>
<p>Its morale is 11.62</p>
<p>我的输出数据（编译器vs2015）是：</p>
<p>006:00 blue dragon 7 born</p>
<p>Its morale is 11.63</p>
<p>经调试，我发现真正的正确答案应该就是11.63。</p>
<p>有人反映是编译器的问题，我测试了gcc的输出结果，同样是11.63</p>
<p>注意！即使我的输出结果和poj提供的out.txt文件不同，我的代码仍然是Accept！只是在coursera上WA。</p>
<p>然后，我修改了我的代码，不再进行四舍五入了，改为直接截尾保留两位小数。</p>
<p>这时，我的输出与out.txt相同了，在poj提交仍然Accept！</p>
<p>在coursera上提交也通过了！！</p>
<p>所以，我认为，有两个问题：</p>
<p>1.poj的评测有问题（不然我两次不同的代码输出不同的结果都能AC啊）</p>
<p>2.两个平台的测试数据都有问题（按照题目描述的四舍五入应该是11.63才对）</p>
<p>希望助教和老师能再审查一下题目啊，毕竟愿意做这个题的人不多，花出很大心血做完后却一直不能通过得多痛心啊！</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><p>本代码在vs上能编译，若想提交到oj上，需要改动一些地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div><div class="line">978</div><div class="line">979</div><div class="line">980</div><div class="line">981</div><div class="line">982</div><div class="line">983</div><div class="line">984</div><div class="line">985</div><div class="line">986</div><div class="line">987</div><div class="line">988</div><div class="line">989</div><div class="line">990</div><div class="line">991</div><div class="line">992</div><div class="line">993</div><div class="line">994</div><div class="line">995</div><div class="line">996</div><div class="line">997</div><div class="line">998</div><div class="line">999</div><div class="line">1000</div><div class="line">1001</div><div class="line">1002</div><div class="line">1003</div><div class="line">1004</div><div class="line">1005</div><div class="line">1006</div><div class="line">1007</div><div class="line">1008</div><div class="line">1009</div><div class="line">1010</div><div class="line">1011</div><div class="line">1012</div><div class="line">1013</div><div class="line">1014</div><div class="line">1015</div><div class="line">1016</div><div class="line">1017</div><div class="line">1018</div><div class="line">1019</div><div class="line">1020</div><div class="line">1021</div><div class="line">1022</div><div class="line">1023</div><div class="line">1024</div><div class="line">1025</div><div class="line">1026</div><div class="line">1027</div><div class="line">1028</div><div class="line">1029</div><div class="line">1030</div><div class="line">1031</div><div class="line">1032</div><div class="line">1033</div><div class="line">1034</div><div class="line">1035</div><div class="line">1036</div><div class="line">1037</div><div class="line">1038</div><div class="line">1039</div><div class="line">1040</div><div class="line">1041</div><div class="line">1042</div><div class="line">1043</div><div class="line">1044</div><div class="line">1045</div><div class="line">1046</div><div class="line">1047</div><div class="line">1048</div><div class="line">1049</div><div class="line">1050</div><div class="line">1051</div><div class="line">1052</div><div class="line">1053</div><div class="line">1054</div><div class="line">1055</div><div class="line">1056</div><div class="line">1057</div><div class="line">1058</div><div class="line">1059</div><div class="line">1060</div><div class="line">1061</div><div class="line">1062</div><div class="line">1063</div><div class="line">1064</div><div class="line">1065</div><div class="line">1066</div><div class="line">1067</div><div class="line">1068</div><div class="line">1069</div><div class="line">1070</div><div class="line">1071</div><div class="line">1072</div><div class="line">1073</div><div class="line">1074</div><div class="line">1075</div><div class="line">1076</div><div class="line">1077</div><div class="line">1078</div><div class="line">1079</div><div class="line">1080</div><div class="line">1081</div><div class="line">1082</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085</div><div class="line">1086</div><div class="line">1087</div><div class="line">1088</div><div class="line">1089</div><div class="line">1090</div><div class="line">1091</div><div class="line">1092</div><div class="line">1093</div><div class="line">1094</div><div class="line">1095</div><div class="line">1096</div><div class="line">1097</div><div class="line">1098</div><div class="line">1099</div><div class="line">1100</div><div class="line">1101</div><div class="line">1102</div><div class="line">1103</div><div class="line">1104</div><div class="line">1105</div><div class="line">1106</div><div class="line">1107</div><div class="line">1108</div><div class="line">1109</div><div class="line">1110</div><div class="line">1111</div><div class="line">1112</div><div class="line">1113</div><div class="line">1114</div><div class="line">1115</div><div class="line">1116</div><div class="line">1117</div><div class="line">1118</div><div class="line">1119</div><div class="line">1120</div><div class="line">1121</div><div class="line">1122</div><div class="line">1123</div><div class="line">1124</div><div class="line">1125</div><div class="line">1126</div><div class="line">1127</div><div class="line">1128</div><div class="line">1129</div><div class="line">1130</div><div class="line">1131</div><div class="line">1132</div><div class="line">1133</div><div class="line">1134</div><div class="line">1135</div><div class="line">1136</div><div class="line">1137</div><div class="line">1138</div><div class="line">1139</div><div class="line">1140</div><div class="line">1141</div><div class="line">1142</div><div class="line">1143</div><div class="line">1144</div><div class="line">1145</div><div class="line">1146</div><div class="line">1147</div><div class="line">1148</div><div class="line">1149</div><div class="line">1150</div><div class="line">1151</div><div class="line">1152</div><div class="line">1153</div><div class="line">1154</div><div class="line">1155</div><div class="line">1156</div><div class="line">1157</div><div class="line">1158</div><div class="line">1159</div><div class="line">1160</div><div class="line">1161</div><div class="line">1162</div><div class="line">1163</div><div class="line">1164</div><div class="line">1165</div><div class="line">1166</div><div class="line">1167</div><div class="line">1168</div><div class="line">1169</div><div class="line">1170</div><div class="line">1171</div><div class="line">1172</div><div class="line">1173</div><div class="line">1174</div><div class="line">1175</div><div class="line">1176</div><div class="line">1177</div><div class="line">1178</div><div class="line">1179</div><div class="line">1180</div><div class="line">1181</div><div class="line">1182</div><div class="line">1183</div><div class="line">1184</div><div class="line">1185</div><div class="line">1186</div><div class="line">1187</div><div class="line">1188</div><div class="line">1189</div><div class="line">1190</div><div class="line">1191</div><div class="line">1192</div><div class="line">1193</div><div class="line">1194</div><div class="line">1195</div><div class="line">1196</div><div class="line">1197</div><div class="line">1198</div><div class="line">1199</div><div class="line">1200</div><div class="line">1201</div><div class="line">1202</div><div class="line">1203</div><div class="line">1204</div><div class="line">1205</div><div class="line">1206</div><div class="line">1207</div><div class="line">1208</div><div class="line">1209</div><div class="line">1210</div><div class="line">1211</div><div class="line">1212</div><div class="line">1213</div><div class="line">1214</div><div class="line">1215</div><div class="line">1216</div><div class="line">1217</div><div class="line">1218</div><div class="line">1219</div><div class="line">1220</div><div class="line">1221</div><div class="line">1222</div><div class="line">1223</div><div class="line">1224</div><div class="line">1225</div><div class="line">1226</div><div class="line">1227</div><div class="line">1228</div><div class="line">1229</div><div class="line">1230</div><div class="line">1231</div><div class="line">1232</div><div class="line">1233</div><div class="line">1234</div><div class="line">1235</div><div class="line">1236</div><div class="line">1237</div><div class="line">1238</div><div class="line">1239</div><div class="line">1240</div><div class="line">1241</div><div class="line">1242</div><div class="line">1243</div><div class="line">1244</div><div class="line">1245</div><div class="line">1246</div><div class="line">1247</div><div class="line">1248</div><div class="line">1249</div><div class="line">1250</div><div class="line">1251</div><div class="line">1252</div><div class="line">1253</div><div class="line">1254</div><div class="line">1255</div><div class="line">1256</div><div class="line">1257</div><div class="line">1258</div><div class="line">1259</div><div class="line">1260</div><div class="line">1261</div><div class="line">1262</div><div class="line">1263</div><div class="line">1264</div><div class="line">1265</div><div class="line">1266</div><div class="line">1267</div><div class="line">1268</div><div class="line">1269</div><div class="line">1270</div><div class="line">1271</div><div class="line">1272</div><div class="line">1273</div><div class="line">1274</div><div class="line">1275</div><div class="line">1276</div><div class="line">1277</div><div class="line">1278</div><div class="line">1279</div><div class="line">1280</div><div class="line">1281</div><div class="line">1282</div><div class="line">1283</div><div class="line">1284</div><div class="line">1285</div><div class="line">1286</div><div class="line">1287</div><div class="line">1288</div><div class="line">1289</div><div class="line">1290</div><div class="line">1291</div><div class="line">1292</div><div class="line">1293</div><div class="line">1294</div><div class="line">1295</div><div class="line">1296</div><div class="line">1297</div><div class="line">1298</div><div class="line">1299</div><div class="line">1300</div><div class="line">1301</div><div class="line">1302</div><div class="line">1303</div><div class="line">1304</div><div class="line">1305</div><div class="line">1306</div><div class="line">1307</div><div class="line">1308</div><div class="line">1309</div><div class="line">1310</div><div class="line">1311</div><div class="line">1312</div><div class="line">1313</div><div class="line">1314</div><div class="line">1315</div><div class="line">1316</div><div class="line">1317</div><div class="line">1318</div><div class="line">1319</div><div class="line">1320</div><div class="line">1321</div><div class="line">1322</div><div class="line">1323</div><div class="line">1324</div><div class="line">1325</div><div class="line">1326</div><div class="line">1327</div><div class="line">1328</div><div class="line">1329</div><div class="line">1330</div><div class="line">1331</div><div class="line">1332</div><div class="line">1333</div><div class="line">1334</div><div class="line">1335</div><div class="line">1336</div><div class="line">1337</div><div class="line">1338</div><div class="line">1339</div><div class="line">1340</div><div class="line">1341</div><div class="line">1342</div><div class="line">1343</div><div class="line">1344</div><div class="line">1345</div><div class="line">1346</div><div class="line">1347</div><div class="line">1348</div><div class="line">1349</div><div class="line">1350</div><div class="line">1351</div><div class="line">1352</div><div class="line">1353</div><div class="line">1354</div><div class="line">1355</div><div class="line">1356</div><div class="line">1357</div><div class="line">1358</div><div class="line">1359</div><div class="line">1360</div><div class="line">1361</div><div class="line">1362</div><div class="line">1363</div><div class="line">1364</div><div class="line">1365</div><div class="line">1366</div><div class="line">1367</div><div class="line">1368</div><div class="line">1369</div><div class="line">1370</div><div class="line">1371</div><div class="line">1372</div><div class="line">1373</div><div class="line">1374</div><div class="line">1375</div><div class="line">1376</div><div class="line">1377</div><div class="line">1378</div><div class="line">1379</div><div class="line">1380</div><div class="line">1381</div><div class="line">1382</div><div class="line">1383</div><div class="line">1384</div><div class="line">1385</div><div class="line">1386</div><div class="line">1387</div><div class="line">1388</div><div class="line">1389</div><div class="line">1390</div><div class="line">1391</div><div class="line">1392</div><div class="line">1393</div><div class="line">1394</div><div class="line">1395</div><div class="line">1396</div><div class="line">1397</div><div class="line">1398</div><div class="line">1399</div><div class="line">1400</div><div class="line">1401</div><div class="line">1402</div><div class="line">1403</div><div class="line">1404</div><div class="line">1405</div><div class="line">1406</div><div class="line">1407</div><div class="line">1408</div><div class="line">1409</div><div class="line">1410</div><div class="line">1411</div><div class="line">1412</div><div class="line">1413</div><div class="line">1414</div><div class="line">1415</div><div class="line">1416</div><div class="line">1417</div><div class="line">1418</div><div class="line">1419</div><div class="line">1420</div><div class="line">1421</div><div class="line">1422</div><div class="line">1423</div><div class="line">1424</div><div class="line">1425</div><div class="line">1426</div><div class="line">1427</div><div class="line">1428</div><div class="line">1429</div><div class="line">1430</div><div class="line">1431</div><div class="line">1432</div><div class="line">1433</div><div class="line">1434</div><div class="line">1435</div><div class="line">1436</div><div class="line">1437</div><div class="line">1438</div><div class="line">1439</div><div class="line">1440</div><div class="line">1441</div><div class="line">1442</div><div class="line">1443</div><div class="line">1444</div><div class="line">1445</div><div class="line">1446</div><div class="line">1447</div><div class="line">1448</div><div class="line">1449</div><div class="line">1450</div><div class="line">1451</div><div class="line">1452</div><div class="line">1453</div><div class="line">1454</div><div class="line">1455</div><div class="line">1456</div><div class="line">1457</div><div class="line">1458</div><div class="line">1459</div><div class="line">1460</div><div class="line">1461</div><div class="line">1462</div><div class="line">1463</div><div class="line">1464</div><div class="line">1465</div><div class="line">1466</div><div class="line">1467</div><div class="line">1468</div><div class="line">1469</div><div class="line">1470</div><div class="line">1471</div><div class="line">1472</div><div class="line">1473</div><div class="line">1474</div><div class="line">1475</div><div class="line">1476</div><div class="line">1477</div><div class="line">1478</div><div class="line">1479</div><div class="line">1480</div><div class="line">1481</div><div class="line">1482</div><div class="line">1483</div><div class="line">1484</div><div class="line">1485</div><div class="line">1486</div><div class="line">1487</div><div class="line">1488</div><div class="line">1489</div><div class="line">1490</div><div class="line">1491</div><div class="line">1492</div><div class="line">1493</div><div class="line">1494</div><div class="line">1495</div><div class="line">1496</div><div class="line">1497</div><div class="line">1498</div><div class="line">1499</div><div class="line">1500</div><div class="line">1501</div><div class="line">1502</div><div class="line">1503</div><div class="line">1504</div><div class="line">1505</div><div class="line">1506</div><div class="line">1507</div><div class="line">1508</div><div class="line">1509</div><div class="line">1510</div><div class="line">1511</div><div class="line">1512</div><div class="line">1513</div><div class="line">1514</div><div class="line">1515</div><div class="line">1516</div><div class="line">1517</div><div class="line">1518</div><div class="line">1519</div><div class="line">1520</div><div class="line">1521</div><div class="line">1522</div><div class="line">1523</div><div class="line">1524</div><div class="line">1525</div><div class="line">1526</div><div class="line">1527</div><div class="line">1528</div><div class="line">1529</div><div class="line">1530</div><div class="line">1531</div><div class="line">1532</div><div class="line">1533</div><div class="line">1534</div><div class="line">1535</div><div class="line">1536</div><div class="line">1537</div><div class="line">1538</div><div class="line">1539</div><div class="line">1540</div><div class="line">1541</div><div class="line">1542</div><div class="line">1543</div><div class="line">1544</div><div class="line">1545</div><div class="line">1546</div><div class="line">1547</div><div class="line">1548</div><div class="line">1549</div><div class="line">1550</div><div class="line">1551</div><div class="line">1552</div><div class="line">1553</div><div class="line">1554</div><div class="line">1555</div><div class="line">1556</div><div class="line">1557</div><div class="line">1558</div><div class="line">1559</div><div class="line">1560</div><div class="line">1561</div><div class="line">1562</div><div class="line">1563</div><div class="line">1564</div><div class="line">1565</div><div class="line">1566</div><div class="line">1567</div><div class="line">1568</div><div class="line">1569</div><div class="line">1570</div><div class="line">1571</div><div class="line">1572</div><div class="line">1573</div><div class="line">1574</div><div class="line">1575</div><div class="line">1576</div><div class="line">1577</div><div class="line">1578</div><div class="line">1579</div><div class="line">1580</div><div class="line">1581</div><div class="line">1582</div><div class="line">1583</div><div class="line">1584</div><div class="line">1585</div><div class="line">1586</div><div class="line">1587</div><div class="line">1588</div><div class="line">1589</div><div class="line">1590</div><div class="line">1591</div><div class="line">1592</div><div class="line">1593</div><div class="line">1594</div><div class="line">1595</div><div class="line">1596</div><div class="line">1597</div><div class="line">1598</div><div class="line">1599</div><div class="line">1600</div><div class="line">1601</div><div class="line">1602</div><div class="line">1603</div><div class="line">1604</div><div class="line">1605</div><div class="line">1606</div><div class="line">1607</div><div class="line">1608</div><div class="line">1609</div><div class="line">1610</div><div class="line">1611</div><div class="line">1612</div><div class="line">1613</div><div class="line">1614</div><div class="line">1615</div><div class="line">1616</div><div class="line">1617</div><div class="line">1618</div><div class="line">1619</div><div class="line">1620</div><div class="line">1621</div><div class="line">1622</div><div class="line">1623</div><div class="line">1624</div><div class="line">1625</div><div class="line">1626</div><div class="line">1627</div><div class="line">1628</div><div class="line">1629</div><div class="line">1630</div><div class="line">1631</div><div class="line">1632</div><div class="line">1633</div><div class="line">1634</div><div class="line">1635</div><div class="line">1636</div><div class="line">1637</div><div class="line">1638</div><div class="line">1639</div><div class="line">1640</div><div class="line">1641</div><div class="line">1642</div><div class="line">1643</div><div class="line">1644</div><div class="line">1645</div><div class="line">1646</div><div class="line">1647</div><div class="line">1648</div><div class="line">1649</div><div class="line">1650</div><div class="line">1651</div><div class="line">1652</div><div class="line">1653</div><div class="line">1654</div><div class="line">1655</div><div class="line">1656</div><div class="line">1657</div><div class="line">1658</div><div class="line">1659</div><div class="line">1660</div><div class="line">1661</div><div class="line">1662</div><div class="line">1663</div><div class="line">1664</div><div class="line">1665</div><div class="line">1666</div><div class="line">1667</div><div class="line">1668</div><div class="line">1669</div><div class="line">1670</div><div class="line">1671</div><div class="line">1672</div><div class="line">1673</div><div class="line">1674</div><div class="line">1675</div><div class="line">1676</div><div class="line">1677</div><div class="line">1678</div><div class="line">1679</div><div class="line">1680</div><div class="line">1681</div><div class="line">1682</div><div class="line">1683</div><div class="line">1684</div><div class="line">1685</div><div class="line">1686</div><div class="line">1687</div><div class="line">1688</div><div class="line">1689</div><div class="line">1690</div><div class="line">1691</div><div class="line">1692</div><div class="line">1693</div><div class="line">1694</div><div class="line">1695</div><div class="line">1696</div><div class="line">1697</div><div class="line">1698</div><div class="line">1699</div><div class="line">1700</div><div class="line">1701</div><div class="line">1702</div><div class="line">1703</div><div class="line">1704</div><div class="line">1705</div><div class="line">1706</div><div class="line">1707</div><div class="line">1708</div><div class="line">1709</div><div class="line">1710</div><div class="line">1711</div><div class="line">1712</div><div class="line">1713</div><div class="line">1714</div><div class="line">1715</div><div class="line">1716</div><div class="line">1717</div><div class="line">1718</div><div class="line">1719</div><div class="line">1720</div><div class="line">1721</div><div class="line">1722</div><div class="line">1723</div><div class="line">1724</div><div class="line">1725</div><div class="line">1726</div><div class="line">1727</div><div class="line">1728</div><div class="line">1729</div><div class="line">1730</div><div class="line">1731</div><div class="line">1732</div><div class="line">1733</div><div class="line">1734</div><div class="line">1735</div><div class="line">1736</div><div class="line">1737</div><div class="line">1738</div><div class="line">1739</div><div class="line">1740</div><div class="line">1741</div><div class="line">1742</div><div class="line">1743</div><div class="line">1744</div><div class="line">1745</div><div class="line">1746</div><div class="line">1747</div><div class="line">1748</div><div class="line">1749</div><div class="line">1750</div><div class="line">1751</div><div class="line">1752</div><div class="line">1753</div><div class="line">1754</div><div class="line">1755</div><div class="line">1756</div><div class="line">1757</div><div class="line">1758</div><div class="line">1759</div><div class="line">1760</div><div class="line">1761</div><div class="line">1762</div><div class="line">1763</div><div class="line">1764</div><div class="line">1765</div><div class="line">1766</div><div class="line">1767</div><div class="line">1768</div><div class="line">1769</div><div class="line">1770</div><div class="line">1771</div><div class="line">1772</div><div class="line">1773</div><div class="line">1774</div><div class="line">1775</div><div class="line">1776</div><div class="line">1777</div><div class="line">1778</div><div class="line">1779</div><div class="line">1780</div><div class="line">1781</div><div class="line">1782</div><div class="line">1783</div><div class="line">1784</div><div class="line">1785</div><div class="line">1786</div><div class="line">1787</div><div class="line">1788</div><div class="line">1789</div><div class="line">1790</div><div class="line">1791</div><div class="line">1792</div><div class="line">1793</div><div class="line">1794</div><div class="line">1795</div><div class="line">1796</div><div class="line">1797</div><div class="line">1798</div><div class="line">1799</div><div class="line">1800</div><div class="line">1801</div><div class="line">1802</div><div class="line">1803</div><div class="line">1804</div><div class="line">1805</div><div class="line">1806</div><div class="line">1807</div><div class="line">1808</div><div class="line">1809</div><div class="line">1810</div><div class="line">1811</div><div class="line">1812</div><div class="line">1813</div><div class="line">1814</div><div class="line">1815</div><div class="line">1816</div><div class="line">1817</div><div class="line">1818</div><div class="line">1819</div><div class="line">1820</div><div class="line">1821</div><div class="line">1822</div><div class="line">1823</div></pre></td><td class="code"><pre><div class="line">// World of Warcraft.cpp : 定义控制台应用程序的入口点。</div><div class="line">//</div><div class="line"></div><div class="line">#include &quot;stdafx.h&quot;</div><div class="line"></div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">#define _CRT_SECURE_NO_WARNINGS</div><div class="line">int M, N, R, K, T;//基础数据</div><div class="line">int SoldierBlood[5];</div><div class="line">int SoldierAd[5];</div><div class="line">int CurrentTime;</div><div class="line"></div><div class="line">string toString(int t)</div><div class="line">&#123;</div><div class="line">	char buf[10];</div><div class="line">	sprintf_s(buf, &quot;%d&quot;, t);</div><div class="line">	string b = buf;</div><div class="line">	return b;</div><div class="line">&#125;</div><div class="line">string printNowTime()</div><div class="line">&#123;</div><div class="line">	int t = CurrentTime;</div><div class="line">	int h = t / 60;</div><div class="line">	int m = t % 60;</div><div class="line">	string s;</div><div class="line">	s += h / 100 + &apos;0&apos;;</div><div class="line">	s += (h / 10) % 10 + &apos;0&apos;;</div><div class="line">	s += h % 10 + &apos;0&apos;;</div><div class="line">	s += &apos;:&apos;;</div><div class="line">	s += m / 10 + &apos;0&apos;;</div><div class="line">	s += m % 10 + &apos;0&apos;;</div><div class="line">	return s + &apos; &apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Weapon</div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">	int Attack;</div><div class="line">	int Belong;//存放的soldier的uid</div><div class="line">public:</div><div class="line">	int getAttack()</div><div class="line">	&#123;</div><div class="line">		return Attack;</div><div class="line">	&#125;</div><div class="line">	void setBelong(int t)</div><div class="line">	&#123;</div><div class="line">		Belong = t;</div><div class="line">	&#125;</div><div class="line">	virtual void init() = 0;</div><div class="line">	virtual int lose() = 0;//返回0的时候表示失去该武器</div><div class="line">	virtual int getType() = 0;//0 sword 1 bomb 2 arrow</div><div class="line">	virtual string getPrint() = 0;</div><div class="line">	virtual ~Weapon() &#123;&#125;;</div><div class="line">&#125;;</div><div class="line">class Sword:public Weapon</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	void init();</div><div class="line">	int lose()</div><div class="line">	&#123;</div><div class="line">		Attack *= 0.8;</div><div class="line">		return Attack;</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	void setAttack(int t)</div><div class="line">	&#123;</div><div class="line">		Attack = t*0.2;</div><div class="line">	&#125;</div><div class="line">	string getPrint()</div><div class="line">	&#123;</div><div class="line">		return &quot;sword(&quot; + toString(Attack) + &apos;)&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class Arrow :public Weapon</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	int time;</div><div class="line">	void init()</div><div class="line">	&#123;</div><div class="line">		Attack = 0;</div><div class="line">		time = 3;</div><div class="line">	&#125;</div><div class="line">	int lose()</div><div class="line">	&#123;</div><div class="line">		time--;</div><div class="line">		return time;</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">	string getPrint()</div><div class="line">	&#123;</div><div class="line">		return &quot;arrow(&quot; + toString(time) + &apos;)&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class Bomb :public Weapon</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	void init()</div><div class="line">	&#123;</div><div class="line">		Attack = 0;</div><div class="line">	&#125;</div><div class="line">	int lose()//只能用一次,只要调用了就没了</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	string getPrint()</div><div class="line">	&#123;</div><div class="line">		return &quot;bomb&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Soldier </div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">	</div><div class="line">	int Attack;</div><div class="line">	int Id;</div><div class="line">	int uId;</div><div class="line">	int Camp;//0:red,1:blue;</div><div class="line">	</div><div class="line">	</div><div class="line">public:</div><div class="line">	int Blood;//&lt;=0即为死亡</div><div class="line">	int BloodWin;//</div><div class="line">	int isLive;//0 die 1 live -1 runaway</div><div class="line">	int tArrow;//实现同时射箭的处理。先记录下中箭的数值，在战争开始时再结算中箭的伤害。</div><div class="line">	Arrow* hasArrow;//没有即为NULL</div><div class="line">	Bomb* hasBomb;//</div><div class="line">	int dieByArrow;</div><div class="line">	string getCampName()</div><div class="line">	&#123;</div><div class="line">		if (Camp == 0) return &quot;red&quot;;</div><div class="line">		return &quot;blue&quot;;</div><div class="line">	&#125;</div><div class="line">	string getPrint()//return like this &quot;red lion 2&quot;</div><div class="line">	&#123;</div><div class="line">		string s;</div><div class="line">		s += getCampName() + &apos; &apos; + getName() + &apos; &apos; +toString(Id);</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">	Soldier()</div><div class="line">	&#123;</div><div class="line">		isLive = 1;</div><div class="line">		hasArrow = NULL;</div><div class="line">		hasBomb = NULL;</div><div class="line">		tArrow = 0;</div><div class="line">		BloodWin = 0;</div><div class="line">		dieByArrow = 0;</div><div class="line">	&#125;</div><div class="line">	void attackByArrow(int t)</div><div class="line">	&#123;</div><div class="line">		tArrow += t;</div><div class="line">	&#125;</div><div class="line">	void loseByArrow()</div><div class="line">	&#123;</div><div class="line">		loseBlood(tArrow);</div><div class="line">		tArrow = 0;</div><div class="line">	&#125;</div><div class="line">	void loseBlood(int t)//降低生命值</div><div class="line">	&#123;</div><div class="line">		Blood -= t;</div><div class="line">		if (Blood &lt;= 0)</div><div class="line">		&#123;</div><div class="line">			isLive = 0;</div><div class="line">			//Todo</div><div class="line">			die();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int getBlood()</div><div class="line">	&#123;</div><div class="line">		return Blood;</div><div class="line">	&#125;</div><div class="line">	int getAttack()</div><div class="line">	&#123;</div><div class="line">		return Attack;</div><div class="line">	&#125;</div><div class="line">	void setId(int t)</div><div class="line">	&#123;</div><div class="line">		Id = t;</div><div class="line">	&#125;</div><div class="line">	int getId()</div><div class="line">	&#123;</div><div class="line">		return Id;</div><div class="line">	&#125;</div><div class="line">	void setuId(int t)</div><div class="line">	&#123;</div><div class="line">		uId = t;</div><div class="line">	&#125;</div><div class="line">	int getuId()</div><div class="line">	&#123;</div><div class="line">		return uId;</div><div class="line">	&#125;</div><div class="line">	void setCamp(int t)</div><div class="line">	&#123;</div><div class="line">		Camp = t;</div><div class="line">	&#125;</div><div class="line">	int getCamp()</div><div class="line">	&#123;</div><div class="line">		return Camp;</div><div class="line">	&#125;</div><div class="line">	virtual void init() = 0;//武士初始化，推迟到子类中实现</div><div class="line">	virtual int fight() = 0;//返回攻击的攻击力</div><div class="line">	virtual int fightback() = 0;//返回反击的攻击力</div><div class="line">	virtual int getType() = 0;//返回该武士的类型编号，0： dragon 、1：ninja、2：iceman、3：lion、4：wolf</div><div class="line">	virtual string getName() = 0;//返回该武士的类型</div><div class="line">	virtual void die() = 0;//死亡</div><div class="line">	virtual void winFight(Soldier* p,int t) = 0;//获胜</div><div class="line">	virtual void loseFight(Soldier* p,int t) = 0;//输掉</div><div class="line">	virtual void drawFight(Soldier* p,int t) = 0;//平局</div><div class="line">	virtual void loseWeapon(int t) = 0;</div><div class="line">	virtual void printWeapon() = 0;</div><div class="line">	virtual ~Soldier() &#123;&#125;//虚函数析构</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int getSwordAttack(Weapon* p)//fight时处理sword的事件，返回sword的攻击力</div><div class="line">&#123;</div><div class="line">	if (!p) return 0;</div><div class="line">	if (p-&gt;getType() != 0) return 0;//not sword,return 0</div><div class="line">	int t = p-&gt;getAttack();</div><div class="line">	//p-&gt;lose();//sword 变钝  // 对打时处理吧</div><div class="line">	//if (p-&gt;getAttack() == 0)</div><div class="line">	//&#123;</div><div class="line">	//	delete p;</div><div class="line">	//	p = NULL;</div><div class="line">	//&#125;</div><div class="line">	return t;</div><div class="line">&#125;</div><div class="line">void getWeapon(Soldier * t,Weapon* &amp;p, int code);//获得武器</div><div class="line"></div><div class="line">class Dragon :public Soldier</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	double Morale;</div><div class="line">	Weapon* mWeapon;//NULL代表没有武器</div><div class="line">	Dragon()</div><div class="line">	&#123;</div><div class="line">		Blood = SoldierBlood[0];</div><div class="line">		Attack = SoldierAd[0];</div><div class="line">		mWeapon = NULL;</div><div class="line">	&#125;</div><div class="line">	double getMorale()</div><div class="line">	&#123;</div><div class="line">		return Morale;</div><div class="line">	&#125;</div><div class="line">	int getWeaponType()//-1 no weapon,0 sword</div><div class="line">	&#123;</div><div class="line">		if (mWeapon == NULL) return -1;</div><div class="line">		return mWeapon-&gt;getType();</div><div class="line">	&#125;</div><div class="line">	void init();</div><div class="line">	</div><div class="line">	void die()</div><div class="line">	&#123;</div><div class="line">		//if (mWeapon != NULL) delete mWeapon;</div><div class="line">		isLive = 0;</div><div class="line">		Blood = 0;</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	string getName()</div><div class="line">	&#123;</div><div class="line">		return &quot;dragon&quot;;</div><div class="line">	&#125;</div><div class="line">	void yell(int t);//judge whether to yell</div><div class="line">	</div><div class="line">	void winFight(Soldier* p,int t)</div><div class="line">	&#123;</div><div class="line">		BloodWin += 8;</div><div class="line">		Morale += 0.2;</div><div class="line">		yell(t);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	void loseFight(Soldier * p,int t)</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	void drawFight(Soldier * p,int t)</div><div class="line">	&#123;</div><div class="line">		Morale -= 0.2;</div><div class="line">		yell(t);</div><div class="line">	&#125;</div><div class="line">	int fight()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack;</div><div class="line">		ad += getSwordAttack(mWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	int fightback()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack / 2;</div><div class="line">		ad += getSwordAttack(mWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	void loseWeapon(int t)//战斗后调用</div><div class="line">	&#123;</div><div class="line">		if (mWeapon&amp;&amp;mWeapon-&gt;getType()==t)</div><div class="line">		&#123;</div><div class="line">			if (mWeapon-&gt;lose() == 0)</div><div class="line">			&#123;</div><div class="line">				//delete mWeapon;</div><div class="line">				mWeapon = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	void printWeapon()</div><div class="line">	&#123;</div><div class="line">		string s = printNowTime() + getPrint() + &quot; has &quot;;</div><div class="line">		if (mWeapon == NULL)</div><div class="line">			s += &quot;no weapon&quot;;</div><div class="line">		else</div><div class="line">			s += mWeapon-&gt;getPrint();</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class Ninja :public Soldier</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	Weapon *mWeapon1, *mWeapon2;</div><div class="line">	Ninja()</div><div class="line">	&#123;</div><div class="line">		Blood = SoldierBlood[1];</div><div class="line">		Attack = SoldierAd[1];</div><div class="line">		mWeapon1 = NULL;</div><div class="line">		mWeapon2 = NULL;</div><div class="line">	&#125;</div><div class="line">	int getWeaponType1()</div><div class="line">	&#123;</div><div class="line">		if (mWeapon1 == NULL) return -1;</div><div class="line">		return mWeapon1-&gt;getType();</div><div class="line">	&#125;</div><div class="line">	int getWeaponType2()</div><div class="line">	&#123;</div><div class="line">		if (mWeapon2 == NULL) return -1;</div><div class="line">		return mWeapon2-&gt;getType();</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	string getName()</div><div class="line">	&#123;</div><div class="line">		return &quot;ninja&quot;;</div><div class="line">	&#125;</div><div class="line">	void init()</div><div class="line">	&#123;</div><div class="line">		getWeapon(this,mWeapon1, Id % 3);</div><div class="line">		if (mWeapon1) mWeapon1-&gt;setBelong(getuId());//设置属于谁的</div><div class="line">		getWeapon(this,mWeapon2, (Id+1) % 3);</div><div class="line">		if (mWeapon2) mWeapon2-&gt;setBelong(getuId());//设置属于谁的</div><div class="line">	&#125;</div><div class="line">	void die()</div><div class="line">	&#123;</div><div class="line">		//if (mWeapon1) delete mWeapon1;</div><div class="line">		//if (mWeapon2) delete mWeapon2;</div><div class="line">		isLive = 0;</div><div class="line">	&#125;</div><div class="line">	void winFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		BloodWin += 8;</div><div class="line">	&#125;</div><div class="line">	void loseFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	void drawFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	int fight()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack;</div><div class="line">		if(mWeapon1)ad += getSwordAttack(mWeapon1);</div><div class="line">		if(mWeapon2)ad += getSwordAttack(mWeapon2);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	void loseWeapon(int t)//战斗后调用</div><div class="line">	&#123;</div><div class="line">		if (mWeapon1&amp;&amp;mWeapon1-&gt;getType()==t)</div><div class="line">		&#123;</div><div class="line">			if (mWeapon1-&gt;lose()==0)</div><div class="line">			&#123;</div><div class="line">				//delete mWeapon1;</div><div class="line">				mWeapon1 = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (mWeapon2&amp;&amp;mWeapon2-&gt;getType() == t)</div><div class="line">		&#123;</div><div class="line">			if (mWeapon2-&gt;lose()==0)</div><div class="line">			&#123;</div><div class="line">				//delete mWeapon2;</div><div class="line">				mWeapon2 = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int fightback()//不反击，所以认为是0</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	void printWeapon()</div><div class="line">	&#123;</div><div class="line">		string s = printNowTime() + getPrint() + &quot; has &quot;;</div><div class="line">		if (mWeapon1 == NULL &amp;&amp; mWeapon2 == NULL)</div><div class="line">			s += &quot;no weapon&quot;;</div><div class="line">		else if (mWeapon1 == NULL)</div><div class="line">		&#123;</div><div class="line">			s += mWeapon2-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		else if (mWeapon2 == NULL)</div><div class="line">		&#123;</div><div class="line">			s += mWeapon1-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		else </div><div class="line">		&#123;</div><div class="line">			if (mWeapon1-&gt;getType() == 2)</div><div class="line">				s += mWeapon1-&gt;getPrint();</div><div class="line">			if (mWeapon2-&gt;getType() == 2)</div><div class="line">				s += mWeapon2-&gt;getPrint();</div><div class="line">			if (mWeapon1-&gt;getType() == 1)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += mWeapon1-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">			if (mWeapon2-&gt;getType() == 1)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += mWeapon2-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">			if (mWeapon1-&gt;getType() == 0)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += mWeapon1-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">			if (mWeapon2-&gt;getType() == 0)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += mWeapon2-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Iceman :public Soldier</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	Weapon *mWeapon;</div><div class="line">	int Step;</div><div class="line">	Iceman()</div><div class="line">	&#123;</div><div class="line">		Blood = SoldierBlood[2];</div><div class="line">		Attack = SoldierAd[2];</div><div class="line">		mWeapon = NULL;</div><div class="line">		Step = 0;</div><div class="line">	&#125;</div><div class="line">	int getWeaponType()</div><div class="line">	&#123;</div><div class="line">		if (mWeapon == NULL) return -1;</div><div class="line">		return mWeapon-&gt;getType();</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">	string getName()</div><div class="line">	&#123;</div><div class="line">		return &quot;iceman&quot;;</div><div class="line">	&#125;</div><div class="line">	void init()</div><div class="line">	&#123;</div><div class="line">		getWeapon(this,mWeapon, Id % 3);</div><div class="line">		if (mWeapon) mWeapon-&gt;setBelong(getuId());//设置属于谁的</div><div class="line">	&#125;</div><div class="line">	void die()</div><div class="line">	&#123;</div><div class="line">		//if (mWeapon) delete mWeapon;</div><div class="line">		isLive = 0;</div><div class="line">	&#125;</div><div class="line">	void winFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		BloodWin += 8;</div><div class="line">	&#125;</div><div class="line">	void loseFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	void drawFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	void loseWeapon(int t)//战斗后调用</div><div class="line">	&#123;</div><div class="line">		if (mWeapon&amp;&amp;mWeapon-&gt;getType() == t)</div><div class="line">		&#123;</div><div class="line">			if (mWeapon-&gt;lose()== 0)</div><div class="line">			&#123;</div><div class="line">				//delete mWeapon;</div><div class="line">				mWeapon = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	void Move()</div><div class="line">	&#123;</div><div class="line">		Step++;</div><div class="line">		if (Step == 2)</div><div class="line">		&#123;</div><div class="line">			Step = 0;</div><div class="line">			Blood -= 9;</div><div class="line">			Attack += 20;</div><div class="line">			if (Blood &lt;= 0) Blood = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int fight()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack;</div><div class="line">		ad += getSwordAttack(mWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	int fightback()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack / 2;</div><div class="line">		ad += getSwordAttack(mWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	void printWeapon()</div><div class="line">	&#123;</div><div class="line">		string s = printNowTime() + getPrint() + &quot; has &quot;;</div><div class="line">		if (mWeapon == NULL)</div><div class="line">			s += &quot;no weapon&quot;;</div><div class="line">		else</div><div class="line">			s += mWeapon-&gt;getPrint();</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class Lion :public Soldier</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	int	Loyalty;</div><div class="line">	int tBlood;//要转移的Blood</div><div class="line">public:</div><div class="line">	Lion()</div><div class="line">	&#123;</div><div class="line">		Blood = SoldierBlood[3];</div><div class="line">		Attack = SoldierAd[3];</div><div class="line">	&#125;</div><div class="line">	void moveBlood()</div><div class="line">	&#123;</div><div class="line">		tBlood = Blood-tArrow;</div><div class="line">	&#125;</div><div class="line">	void init();</div><div class="line">	void die()</div><div class="line">	&#123;</div><div class="line">		isLive = 0;</div><div class="line">	&#125;</div><div class="line">	int getLoyalty()</div><div class="line">	&#123;</div><div class="line">		return Loyalty;</div><div class="line">	&#125;</div><div class="line">	void loseLoyalty()</div><div class="line">	&#123;</div><div class="line">		Loyalty -= K;</div><div class="line">	&#125;</div><div class="line">	int fight()</div><div class="line">	&#123;</div><div class="line">		return Attack;</div><div class="line">	&#125;</div><div class="line">	int fightback()</div><div class="line">	&#123;</div><div class="line">		return Attack / 2;</div><div class="line">	&#125;</div><div class="line">	void winFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		BloodWin += 8;</div><div class="line">	&#125;</div><div class="line">	void loseFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		if(dieByArrow==0)p-&gt;Blood += tBlood;</div><div class="line">	&#125;</div><div class="line">	void drawFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		loseLoyalty();</div><div class="line">	&#125;</div><div class="line">	void loseWeapon(int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 3;</div><div class="line">	&#125;</div><div class="line">	string getName()</div><div class="line">	&#123;</div><div class="line">		return &quot;lion&quot;;</div><div class="line">	&#125;</div><div class="line">	void runAway()</div><div class="line">	&#123;</div><div class="line">		Blood = 0;</div><div class="line">		isLive = 0;//暂时先设置为0吧，逃跑了就当他死了</div><div class="line">	&#125;</div><div class="line">	void printWeapon()</div><div class="line">	&#123;</div><div class="line">		string s = printNowTime() + getPrint() + &quot; has &quot;;</div><div class="line">		s += &quot;no weapon&quot;;</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class Wolf :public Soldier</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	//Weapon* mWeapon;</div><div class="line">	Weapon* swordWeapon;</div><div class="line">	Arrow* arrowWeapon;</div><div class="line">	Bomb*  bombWeapon;</div><div class="line">	Wolf()</div><div class="line">	&#123;</div><div class="line">		Blood = SoldierBlood[4];</div><div class="line">		Attack = SoldierAd[4];</div><div class="line">	&#125;</div><div class="line">	/*int getWeaponType()</div><div class="line">	&#123;</div><div class="line">		return WeaponType;</div><div class="line">	&#125;*/</div><div class="line">	void init()</div><div class="line">	&#123;</div><div class="line">		swordWeapon = NULL;</div><div class="line">		arrowWeapon = NULL;</div><div class="line">		bombWeapon = NULL;</div><div class="line">	&#125;</div><div class="line">	void die()</div><div class="line">	&#123;</div><div class="line">		//if (swordWeapon) delete swordWeapon;</div><div class="line">		//if ()</div><div class="line">		isLive = 0;</div><div class="line">	&#125;</div><div class="line">	void winFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line">		switch (p-&gt;getType())</div><div class="line">		&#123;</div><div class="line">			case 0:</div><div class="line">			&#123;</div><div class="line">				takeWeapon(((Dragon *)p)-&gt;mWeapon);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 1:</div><div class="line">			&#123;</div><div class="line">				takeWeapon(((Ninja *)p)-&gt;mWeapon1);</div><div class="line">				takeWeapon(((Ninja *)p)-&gt;mWeapon2);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 2:</div><div class="line">			&#123;</div><div class="line">				takeWeapon(((Iceman *)p)-&gt;mWeapon);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 4:</div><div class="line">			&#123;</div><div class="line">				takeWeapon(((Wolf *)p)-&gt;swordWeapon);</div><div class="line">				takeWeapon(((Wolf *)p)-&gt;bombWeapon);</div><div class="line">				takeWeapon(((Wolf *)p)-&gt;arrowWeapon);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		BloodWin += 8;</div><div class="line">	&#125;</div><div class="line">	void loseFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	void drawFight(Soldier *p, int t)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	void takeWeapon(Weapon *p)//缴获武器</div><div class="line">	&#123;</div><div class="line">		if (p == NULL) return;</div><div class="line">		if (p-&gt;getType() == 0&amp;&amp;swordWeapon==NULL)</div><div class="line">		&#123;</div><div class="line">			swordWeapon = p;</div><div class="line">		&#125;</div><div class="line">		if (p-&gt;getType() == 1 &amp;&amp; bombWeapon == NULL)</div><div class="line">		&#123;</div><div class="line">			bombWeapon =(Bomb *) p;</div><div class="line">			hasBomb = (Bomb *)p;</div><div class="line">		&#125;</div><div class="line">		if (p-&gt;getType() == 2 &amp;&amp; arrowWeapon == NULL)</div><div class="line">		&#123;</div><div class="line">			arrowWeapon = (Arrow *)p;</div><div class="line">			hasArrow = (Arrow *)p;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int fight()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack;</div><div class="line">		ad += getSwordAttack(swordWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	int fightback()</div><div class="line">	&#123;</div><div class="line">		int ad = Attack / 2;</div><div class="line">		ad += getSwordAttack(swordWeapon);</div><div class="line">		return ad;</div><div class="line">	&#125;</div><div class="line">	void loseWeapon(int t)//战斗后调用</div><div class="line">	&#123;</div><div class="line">		if (swordWeapon&amp;&amp;t==0)</div><div class="line">		&#123;</div><div class="line">			if (swordWeapon-&gt;lose() == 0)</div><div class="line">			&#123;</div><div class="line">				//delete swordWeapon;</div><div class="line">				swordWeapon = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (bombWeapon&amp;&amp;t == 1)</div><div class="line">		&#123;</div><div class="line">			if (bombWeapon-&gt;lose() == 0)</div><div class="line">			&#123;</div><div class="line">				//delete bombWeapon;</div><div class="line">				bombWeapon = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (arrowWeapon&amp;&amp;t == 2)</div><div class="line">		&#123;</div><div class="line">			if (arrowWeapon-&gt;lose() == 0)</div><div class="line">			&#123;</div><div class="line">				//delete arrowWeapon;</div><div class="line">				arrowWeapon = NULL;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int getType()</div><div class="line">	&#123;</div><div class="line">		return 4;</div><div class="line">	&#125;</div><div class="line">	string getName()</div><div class="line">	&#123;</div><div class="line">		return &quot;wolf&quot;;</div><div class="line">	&#125;</div><div class="line">	void printWeapon()</div><div class="line">	&#123;</div><div class="line">		string s = printNowTime() + getPrint() + &quot; has &quot;;</div><div class="line">		if (swordWeapon == NULL &amp;&amp; bombWeapon == NULL &amp;&amp; arrowWeapon ==NULL)</div><div class="line">			s += &quot;no weapon&quot;;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			if (arrowWeapon != NULL) s += arrowWeapon-&gt;getPrint();</div><div class="line">			if (bombWeapon != NULL)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += bombWeapon-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">			if (swordWeapon != NULL)</div><div class="line">			&#123;</div><div class="line">				if (s[s.size() - 1] != &apos; &apos;) s += &apos;,&apos;;</div><div class="line">				s += swordWeapon-&gt;getPrint();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">vector&lt;Soldier *&gt; mAllSoldier;//全部武士集合</div><div class="line"></div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	int Blood;</div><div class="line">	int BloodWin;</div><div class="line">	int SoidierNum;//从1开始编号</div><div class="line">	vector&lt;Soldier*&gt; mSoldier;//武士集合</div><div class="line">	int occupied;//0 no,1 </div><div class="line">	void init()//初始化大本营</div><div class="line">	&#123;</div><div class="line">		Blood = M;</div><div class="line">		SoidierNum = 0;</div><div class="line">		/*for (int i = 0; i &lt;= mSoldier.size(); i++)</div><div class="line">		&#123;</div><div class="line">		delete mSoldier[i];</div><div class="line">		&#125;*/</div><div class="line">		mSoldier.clear();</div><div class="line">		//mSoldier.push_back(NULL);</div><div class="line">		occupied = 0;</div><div class="line">	&#125;</div><div class="line">	void tackBloodWin()</div><div class="line">	&#123;</div><div class="line">		Blood += BloodWin;</div><div class="line">		BloodWin = 0;</div><div class="line">	&#125;</div><div class="line">	virtual int creatwho(int t) = 0;</div><div class="line">	virtual int getCamp() = 0;</div><div class="line">	virtual string getCampName() = 0;</div><div class="line">	Soldier* CreatSoldier();//返回指向soldier的指针，创建失败的时候的返回null</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">class RedBase :public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	int creatwho(int t)</div><div class="line">	&#123;</div><div class="line">		return t % 5;</div><div class="line">	&#125;</div><div class="line">	int getCamp()</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	string getCampName()</div><div class="line">	&#123;</div><div class="line">		return &quot;red&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">RedBase *RedBaseInstance;//红魔军实例</div><div class="line">class BlueBase:public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	int creatwho(int t)</div><div class="line">	&#123;</div><div class="line">		int k = t % 5;</div><div class="line">		switch (k)</div><div class="line">		&#123;</div><div class="line">		case 0:</div><div class="line">			return 1;</div><div class="line">		case 1:</div><div class="line">			return 4;</div><div class="line">		case 2:</div><div class="line">			return 3;</div><div class="line">		case 3:</div><div class="line">			return 0;</div><div class="line">		case 4:</div><div class="line">			return 2;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	int getCamp()</div><div class="line">	&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	string getCampName()</div><div class="line">	&#123;</div><div class="line">		return &quot;blue&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">BlueBase *BlueBaseInstance;//蓝魔军实例</div><div class="line">class City</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	</div><div class="line">public:</div><div class="line">	int Id;</div><div class="line">	Soldier* RedSoldier;</div><div class="line">	Soldier* BlueSoldier;</div><div class="line">	int Blood;</div><div class="line">	int whoLastWin;//0 no 1 red 2 blue</div><div class="line">	int Flag;//as up</div><div class="line">	int FlagRaise;</div><div class="line">	int lastPrintFlag;</div><div class="line">	int whoFirst;//who first to attack,0 red,1 blue</div><div class="line">	int redReward, blueReward;</div><div class="line">	queue&lt;string&gt; output;</div><div class="line">	City(int t)</div><div class="line">	&#123;</div><div class="line">		lastPrintFlag = 0;</div><div class="line">		Id = t;</div><div class="line">		Blood = 0;</div><div class="line">		whoLastWin = 0;</div><div class="line">		Flag = 0;</div><div class="line">		redReward = 0; </div><div class="line">		blueReward = 0;</div><div class="line">		FlagRaise = 0;</div><div class="line">		RedSoldier = NULL;</div><div class="line">		BlueSoldier = NULL;</div><div class="line">		while (!output.empty()) output.pop();</div><div class="line">	&#125;</div><div class="line">	void addBlood()</div><div class="line">	&#123;</div><div class="line">		Blood += 10;</div><div class="line">	&#125;</div><div class="line">	int takeBlood(int who)//拿走所有的生命元</div><div class="line">	&#123;</div><div class="line">		int t = Blood;</div><div class="line">		Blood = 0;</div><div class="line">		string s = printNowTime();</div><div class="line">		if (who == 0)</div><div class="line">		&#123;</div><div class="line">			s += RedSoldier-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		if (who == 1)</div><div class="line">		&#123;</div><div class="line">			s += BlueSoldier-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		s += &quot; earned &quot; +toString(t)+ &quot; elements for his headquarter&quot;;</div><div class="line">		puts(s.c_str());</div><div class="line">		return t;</div><div class="line">	&#125;</div><div class="line">	int takeWinBlood(int c, int who)</div><div class="line">	&#123;</div><div class="line">		int t = Blood;</div><div class="line">		Blood = 0;</div><div class="line">		string s = printNowTime();</div><div class="line">		if (who == 0)</div><div class="line">		&#123;</div><div class="line">			s += RedSoldier-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		if (who == 1)</div><div class="line">		&#123;</div><div class="line">			s += BlueSoldier-&gt;getPrint();</div><div class="line">		&#125;</div><div class="line">		s += &quot; earned &quot; + toString(t) + &quot; elements for his headquarter&quot;;</div><div class="line">		//puts(s.c_str());</div><div class="line">		output.push(s);</div><div class="line">		return t;</div><div class="line">	&#125;</div><div class="line">	void printFlag(int p)</div><div class="line">	&#123;</div><div class="line">		string s=printNowTime();</div><div class="line">		if (Flag == 1)</div><div class="line">		&#123;</div><div class="line">			s += &quot;red flag raised in city &quot; + toString(p);</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			s += &quot;blue flag raised in city &quot; + toString(p);</div><div class="line">		&#125;</div><div class="line">		puts(s.c_str());</div><div class="line">	&#125;</div><div class="line">	void changeFlag(int p,int t)//t 1 red win ,t 2 blue win</div><div class="line">	&#123;</div><div class="line">		//if (Flag == t) return;</div><div class="line">		if (t == 1)</div><div class="line">		&#123;</div><div class="line">			if (whoLastWin == 1)</div><div class="line">			&#123;</div><div class="line">				Flag = 1;</div><div class="line">				FlagRaise = 1;</div><div class="line">				//printFlag(p);</div><div class="line">				whoFirst = 0;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				whoLastWin = 1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			if (whoLastWin == 2)</div><div class="line">			&#123;</div><div class="line">				Flag = 2;</div><div class="line">				FlagRaise = 2;</div><div class="line">				//printFlag(p);</div><div class="line">				whoFirst = 1;</div><div class="line">			&#125;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				whoLastWin = 2;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">vector &lt;City*&gt; mAllCity;</div><div class="line"></div><div class="line">void Init()//游戏初始化</div><div class="line">&#123;</div><div class="line">	cin &gt;&gt; M &gt;&gt; N &gt;&gt; R &gt;&gt; K &gt;&gt; T;</div><div class="line">	cin &gt;&gt; SoldierBlood[0] &gt;&gt; SoldierBlood[1] &gt;&gt; SoldierBlood[2] &gt;&gt; SoldierBlood[3] &gt;&gt; SoldierBlood[4];</div><div class="line">	cin &gt;&gt; SoldierAd[0] &gt;&gt; SoldierAd[1] &gt;&gt; SoldierAd[2] &gt;&gt; SoldierAd[3] &gt;&gt; SoldierAd[4];</div><div class="line"></div><div class="line">	N++;//使得编号N为bluebase</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; mAllSoldier.size(); i++)</div><div class="line">	&#123;</div><div class="line">		delete mAllSoldier[i];</div><div class="line">	&#125;</div><div class="line">	mAllSoldier.clear();</div><div class="line">	//mAllSoldier.push_back(NULL);//放入一个空指针占位</div><div class="line"></div><div class="line">	RedBaseInstance = new RedBase();</div><div class="line">	RedBaseInstance-&gt;init();</div><div class="line">	BlueBaseInstance = new BlueBase();</div><div class="line">	BlueBaseInstance-&gt;init();</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; mAllCity.size(); i++)</div><div class="line">	&#123;</div><div class="line">		delete mAllCity[i];</div><div class="line">	&#125;</div><div class="line">	mAllCity.clear();</div><div class="line">	for (int i = 0; i &lt;= N; i++)//0号city为redbase，N号为bluebase</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		mAllCity.push_back(new City(i));</div><div class="line">		mAllCity[i]-&gt;whoFirst = (i+1) % 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">string printTime()</div><div class="line">&#123;</div><div class="line">	int t = CurrentTime;</div><div class="line">	int h = t / 60;</div><div class="line">	int m = t % 60;</div><div class="line">	string s;</div><div class="line">	s += h / 100 + &apos;0&apos;;</div><div class="line">	s += (h / 10) % 10 + &apos;0&apos;;</div><div class="line">	s += h % 10 + &apos;0&apos;;</div><div class="line">	s += &apos;:&apos;;</div><div class="line">	s += m / 10 + &apos;0&apos;;</div><div class="line">	s += m % 10 + &apos;0&apos;;</div><div class="line">	return s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printBorn(string s, Soldier* p)</div><div class="line">&#123;</div><div class="line">	if (p == NULL) return;//表示没有创建</div><div class="line">	s += &apos; &apos; + p-&gt;getPrint() + &quot; born&quot;;</div><div class="line">	puts(s.c_str());</div><div class="line">	if (p-&gt;getType() == 0)//is dragon</div><div class="line">	&#123;</div><div class="line">		double t = ((Dragon*)(p))-&gt;getMorale();</div><div class="line">		//t = (double)((int)(t * 100 + 0.5)) / 100.0;//四舍五入</div><div class="line">		//oj上的测试数据并没有四舍五入。。。直接截尾取得两位有效数字，坑啊</div><div class="line">		printf(&quot;Its morale is %.2lf\n&quot;, t);</div><div class="line">	&#125;</div><div class="line">	if (p-&gt;getType() == 3)//is lion</div><div class="line">	&#123;</div><div class="line">		printf(&quot;Its loyalty is %d\n&quot;, ((Lion*)(p))-&gt;getLoyalty());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void printLionRun(string s, Lion* p)//判断lion是否逃跑以及相应信息的输出</div><div class="line">&#123;</div><div class="line">	p-&gt;runAway();</div><div class="line">	s += &quot; lion &quot; + toString(p-&gt;getId()) + &quot; ran away&quot;;</div><div class="line">	puts(s.c_str());</div><div class="line">&#125;</div><div class="line">int printMove(int c)</div><div class="line">&#123;</div><div class="line">	Soldier *p = NULL;</div><div class="line">	string s;</div><div class="line">	int f = 0;</div><div class="line"></div><div class="line">	p = mAllCity[c]-&gt;RedSoldier;//red</div><div class="line">	if (p)</div><div class="line">	&#123;</div><div class="line">		s = printNowTime() + p-&gt;getPrint();</div><div class="line">		if (c == 0) </div><div class="line">			s += &quot; reached red headquarter&quot;;</div><div class="line">		else if (c == N) s += &quot; reached blue headquarter&quot;;</div><div class="line">		else s += &quot; marched to city &quot; + toString(c);</div><div class="line">		s += &quot; with &quot; + toString(p-&gt;getBlood()) + &quot; elements and force &quot; + toString(p-&gt;getAttack());</div><div class="line">		puts(s.c_str());</div><div class="line"></div><div class="line">		if (BlueBaseInstance-&gt;occupied==2&amp;&amp;c == N)</div><div class="line">		&#123;</div><div class="line">			f = 1;</div><div class="line">			printf(&quot;%sblue headquarter was taken\n&quot;, printNowTime().c_str());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	p = mAllCity[c]-&gt;BlueSoldier;//blue</div><div class="line">	if (p)</div><div class="line">	&#123;</div><div class="line">		s = printNowTime() + p-&gt;getPrint();</div><div class="line">		if (c == 0) </div><div class="line">			s += &quot; reached red headquarter&quot;;</div><div class="line">		else if (c == N) s += &quot; reached blue headquarter&quot;;</div><div class="line">		else s += &quot; marched to city &quot; + toString(c);</div><div class="line">		s += &quot; with &quot; + toString(p-&gt;getBlood()) + &quot; elements and force &quot; + toString(p-&gt;getAttack());</div><div class="line">		puts(s.c_str());</div><div class="line"></div><div class="line">		if (RedBaseInstance-&gt;occupied==2&amp;&amp;c == 0)</div><div class="line">		&#123;</div><div class="line">			f = 1;</div><div class="line">			printf(&quot;%sred headquarter was taken\n&quot;, printNowTime().c_str());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return f;</div><div class="line">&#125;</div><div class="line">int checkBomb(Soldier *p,Soldier *q,int t)//返回1即使需要使用bomb</div><div class="line">&#123;</div><div class="line">	//t 谁先攻击，这个应该在city中处理，0 red 1 blue</div><div class="line">	if (q-&gt;getBlood() - q-&gt;tArrow &lt;= 0) return 0;</div><div class="line">	if (p-&gt;getBlood() - p-&gt;tArrow &lt;= 0) return 0;</div><div class="line">	int a = 0, b = 0,c = 0,d = 0;</div><div class="line">	if (t == 0)//p 先攻击</div><div class="line">	&#123;</div><div class="line">		a = p-&gt;fight();</div><div class="line">		b = q-&gt;getBlood() - q-&gt;tArrow;</div><div class="line">		</div><div class="line">		if (a &lt; b)//q 没死 反击</div><div class="line">		&#123;</div><div class="line">			c = q-&gt;fightback();</div><div class="line">			d = p-&gt;getBlood() - p-&gt;tArrow;</div><div class="line">			if (c &gt;= d) return 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else//q 先攻击</div><div class="line">	&#123;</div><div class="line">		a = q-&gt;fight();</div><div class="line">		b = p-&gt;getBlood() - p-&gt;tArrow;</div><div class="line">		</div><div class="line">		if (a &gt;= b) return 1;//q 打死了 p就返回1</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int checkBomb2(Soldier *p, Soldier *q, int t)</div><div class="line">&#123;</div><div class="line">	//t 谁先攻击，这个应该在city中处理，0 red 1 blue</div><div class="line">	if (q-&gt;getBlood() - q-&gt;tArrow &lt;= 0) return 0;</div><div class="line">	if (p-&gt;getBlood() - p-&gt;tArrow &lt;= 0) return 0;</div><div class="line">	int a = 0, b = 0, c = 0, d = 0;</div><div class="line">	if (t == 0)</div><div class="line">	&#123;</div><div class="line">		a = p-&gt;fight();</div><div class="line">		b = q-&gt;getBlood() - q-&gt;tArrow;</div><div class="line">		if (a &gt;= b) return 1;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		c = q-&gt;fight();</div><div class="line">		d = p-&gt;getBlood() - p-&gt;tArrow;</div><div class="line">		if (c &lt; d)</div><div class="line">		&#123;</div><div class="line">			a = p-&gt;fightback();</div><div class="line">			b = q-&gt;getBlood() - q-&gt;tArrow;</div><div class="line">			if (a &gt;= b) return 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int checkArrow(Soldier* p)//结算arrow的伤害并检查是否被射死了,返回1是被射死了</div><div class="line">&#123;</div><div class="line">	if (!p) return -1;</div><div class="line">	p-&gt;loseBlood(p-&gt;tArrow);</div><div class="line">	p-&gt;tArrow = 0;</div><div class="line">	if (p-&gt;getBlood() &lt;= 0)</div><div class="line">	&#123;</div><div class="line">		p-&gt;dieByArrow = 1;</div><div class="line">		p-&gt;die();</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int printFight(int i,Soldier *p,Soldier *q)//返回0，就是q死了</div><div class="line">&#123;</div><div class="line">	int a = p-&gt;fight();</div><div class="line">	int b = q-&gt;getBlood();</div><div class="line">	p-&gt;loseWeapon(0);//武器损耗</div><div class="line">	q-&gt;loseBlood(a);</div><div class="line">	string s = printTime();</div><div class="line">	string sp, sq;</div><div class="line">	if (p-&gt;getCamp() == 0) sp = &quot; red &quot;;</div><div class="line">		else sp = &quot; blue &quot;;</div><div class="line">	if (q-&gt;getCamp() == 0) sq = &quot; red &quot;;</div><div class="line">		else sq = &quot; blue &quot;;</div><div class="line">	s += sp + p-&gt;getName() + &apos; &apos; + toString(p-&gt;getId()) + &quot; attacked&quot; + sq;</div><div class="line">	s += q-&gt;getName() + &apos; &apos; + toString(q-&gt;getId()) + &quot; in city &quot; + toString(i);</div><div class="line">	s += &quot; with &quot; + toString(p-&gt;getBlood()) + &quot; elements and force &quot; + toString(p-&gt;getAttack());</div><div class="line">	//puts(s.c_str());</div><div class="line">	mAllCity[i]-&gt;output.push(s);</div><div class="line">	return q-&gt;isLive;</div><div class="line">&#125;</div><div class="line">int printFightBack(int i, Soldier *p, Soldier *q)</div><div class="line">&#123;</div><div class="line">	if (p-&gt;getType() == 1)//ninjia no fightback</div><div class="line">		return 1;</div><div class="line">	int a = p-&gt;fightback();</div><div class="line">	int b = q-&gt;getBlood();</div><div class="line">	p-&gt;loseWeapon(0);</div><div class="line">	q-&gt;loseBlood(a);</div><div class="line">	string s = printNowTime();</div><div class="line">	s += p-&gt;getPrint() + &quot; fought back against &quot; + q-&gt;getPrint() + &quot; in city &quot; + toString(i);</div><div class="line">	//puts(s.c_str());</div><div class="line">	mAllCity[i]-&gt;output.push(s);</div><div class="line">	return q-&gt;isLive;</div><div class="line">&#125;</div><div class="line">void printKilled(int i,Soldier *p)</div><div class="line">&#123;</div><div class="line">	string s = printTime() + &apos; &apos; + p-&gt;getCampName() + &apos; &apos;;</div><div class="line">	s += p-&gt;getName() + &apos; &apos; + toString(p-&gt;getId()) + &quot; was killed in city &quot; + toString(i);</div><div class="line">	//puts(s.c_str());</div><div class="line">	mAllCity[i]-&gt;output.push(s);</div><div class="line">&#125;</div><div class="line">void afterbattle(int i, int t)//在city i 战斗结束后的事情，0 平局 1 red win 2 blue win</div><div class="line">&#123;</div><div class="line">	if (t == 0)//平局</div><div class="line">	&#123;</div><div class="line">		mAllCity[i]-&gt;RedSoldier-&gt;drawFight(mAllCity[i]-&gt;BlueSoldier, i);</div><div class="line">		mAllCity[i]-&gt;BlueSoldier-&gt;drawFight(mAllCity[i]-&gt;RedSoldier, i);</div><div class="line">		mAllCity[i]-&gt;whoLastWin = 0;</div><div class="line">	&#125;</div><div class="line">	if (t == 1)//red win</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		mAllCity[i]-&gt;RedSoldier-&gt;winFight(mAllCity[i]-&gt;BlueSoldier, i);</div><div class="line">		mAllCity[i]-&gt;BlueSoldier-&gt;loseFight(mAllCity[i]-&gt;RedSoldier, i);</div><div class="line">		RedBaseInstance-&gt;BloodWin += mAllCity[i]-&gt;takeWinBlood(i, 0);</div><div class="line">		mAllCity[i]-&gt;changeFlag(i,1);</div><div class="line">	&#125;</div><div class="line">	if (t == 2)//blue win</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		mAllCity[i]-&gt;RedSoldier-&gt;loseFight(mAllCity[i]-&gt;BlueSoldier, i);</div><div class="line">		mAllCity[i]-&gt;BlueSoldier-&gt;winFight(mAllCity[i]-&gt;RedSoldier, i);</div><div class="line">		BlueBaseInstance-&gt;BloodWin += mAllCity[i]-&gt;takeWinBlood(i, 1);</div><div class="line">		mAllCity[i]-&gt;changeFlag(i,2);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void redReward()</div><div class="line">&#123;</div><div class="line">	for (int i = N - 1; i &gt; 0; i--)//red reward</div><div class="line">	&#123;</div><div class="line">		if (!mAllCity[i]-&gt;RedSoldier) continue;</div><div class="line">		while (mAllCity[i]-&gt;RedSoldier-&gt;BloodWin&gt;0)</div><div class="line">			if (RedBaseInstance-&gt;Blood &gt;= 8)</div><div class="line">			&#123;</div><div class="line">				RedBaseInstance-&gt;Blood -= 8;</div><div class="line">				mAllCity[i]-&gt;RedSoldier-&gt;Blood += 8;</div><div class="line">				mAllCity[i]-&gt;RedSoldier-&gt;BloodWin -= 8;</div><div class="line">				mAllCity[i]-&gt;redReward = 1;</div><div class="line">			&#125;</div><div class="line">		//mAllCity[i]-&gt;RedSoldier-&gt;BloodWin = 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void blueReward()</div><div class="line">&#123;</div><div class="line">	for (int i = 1; i &lt; N; i++)//blue reward</div><div class="line">	&#123;</div><div class="line">		if (!mAllCity[i]-&gt;BlueSoldier) continue;</div><div class="line">		while (mAllCity[i]-&gt;BlueSoldier-&gt;BloodWin&gt;0)</div><div class="line">			if (BlueBaseInstance-&gt;Blood &gt;= 8)</div><div class="line">			&#123;</div><div class="line">				BlueBaseInstance-&gt;Blood -= 8;</div><div class="line">				mAllCity[i]-&gt;BlueSoldier-&gt;Blood += 8;</div><div class="line">				mAllCity[i]-&gt;BlueSoldier-&gt;BloodWin -= 8;</div><div class="line">				mAllCity[i]-&gt;blueReward = 1;</div><div class="line">			&#125;</div><div class="line">		//mAllCity[i]-&gt;BlueSoldier-&gt;BloodWin = 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Game()//游戏进程</div><div class="line">&#123;</div><div class="line">	CurrentTime = -1;</div><div class="line">	Soldier *RedOccSoldier = NULL;</div><div class="line">	Soldier *BlueOccSoldier = NULL;</div><div class="line">	while (CurrentTime &lt;= T)</div><div class="line">	&#123;</div><div class="line">		CurrentTime++;</div><div class="line">		if (CurrentTime &gt; T) return;</div><div class="line">		int CurrentMinute = CurrentTime % 60;</div><div class="line">		string st = printTime();</div><div class="line">		switch (CurrentMinute)</div><div class="line">		&#123;</div><div class="line">			case 0:</div><div class="line">			&#123;</div><div class="line">				string s = st;</div><div class="line">				//red</div><div class="line">				Soldier* p = RedBaseInstance-&gt;CreatSoldier();</div><div class="line">				printBorn(s, p);</div><div class="line"></div><div class="line">				//blue</div><div class="line">				p = BlueBaseInstance-&gt;CreatSoldier();</div><div class="line">				printBorn(s, p);</div><div class="line"></div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 5:</div><div class="line">			&#123;</div><div class="line">				for (int i = 0; i &lt;= N; i++)//从西向东</div><div class="line">				&#123;</div><div class="line">					//red</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier&amp;&amp;mAllCity[i]-&gt;RedSoldier-&gt;getType() == 3)//is lion</div><div class="line">						if (i != N)//not at bluebase</div><div class="line">						&#123;</div><div class="line">							Lion *p = (Lion *)mAllCity[i]-&gt;RedSoldier;</div><div class="line">							string s = st;</div><div class="line">							s += &quot; red&quot;;</div><div class="line">							if (p-&gt;getLoyalty() &lt;= 0)</div><div class="line">							&#123;</div><div class="line">								printLionRun(s, p);</div><div class="line">								mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">							&#125;	</div><div class="line">						&#125;</div><div class="line"></div><div class="line">					//blue</div><div class="line">					if (mAllCity[i]-&gt;BlueSoldier&amp;&amp;mAllCity[i]-&gt;BlueSoldier-&gt;getType() == 3)//is lion</div><div class="line">						if (i != 0)//not at redbase</div><div class="line">						&#123;</div><div class="line">							Lion *p = (Lion *)mAllCity[i]-&gt;BlueSoldier;</div><div class="line">							string s = st;</div><div class="line">							s += &quot; blue&quot;;</div><div class="line">							if (p-&gt;getLoyalty() &lt;= 0)</div><div class="line">							&#123;</div><div class="line">								printLionRun(s, p);</div><div class="line">								mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 10:</div><div class="line">			&#123;</div><div class="line">				int f = 0;//1即为占领了</div><div class="line"></div><div class="line">				//red</div><div class="line">				for (int i = N; i &gt; 0; i--)</div><div class="line">				&#123;</div><div class="line">					if (i == N &amp;&amp; mAllCity[N]-&gt;RedSoldier) RedOccSoldier = mAllCity[N]-&gt;RedSoldier;</div><div class="line">					mAllCity[i]-&gt;RedSoldier = mAllCity[i - 1]-&gt;RedSoldier;</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier&amp;&amp;mAllCity[i]-&gt;RedSoldier-&gt;getType() == 2)</div><div class="line">					&#123;</div><div class="line">						((Iceman*)mAllCity[i]-&gt;RedSoldier)-&gt;Move();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				mAllCity[0]-&gt;RedSoldier = NULL;</div><div class="line">				if (mAllCity[N]-&gt;RedSoldier) &#123; BlueBaseInstance-&gt;occupied++; &#125;</div><div class="line">				</div><div class="line"></div><div class="line">				//blue</div><div class="line">				for (int i = 0; i &lt; N; i++)</div><div class="line">				&#123;</div><div class="line">					if (i == 0 &amp;&amp; mAllCity[0]-&gt;BlueSoldier) BlueOccSoldier = mAllCity[0]-&gt;BlueSoldier;</div><div class="line">					mAllCity[i]-&gt;BlueSoldier = mAllCity[i + 1]-&gt;BlueSoldier;</div><div class="line">					if (mAllCity[i]-&gt;BlueSoldier&amp;&amp;mAllCity[i]-&gt;BlueSoldier-&gt;getType() == 2)</div><div class="line">					&#123;</div><div class="line">						((Iceman*)mAllCity[i]-&gt;BlueSoldier)-&gt;Move();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				mAllCity[N]-&gt;BlueSoldier = NULL;</div><div class="line">				if (mAllCity[0]-&gt;BlueSoldier) RedBaseInstance-&gt;occupied++;</div><div class="line">				for (int i = 0; i &lt;= N; i++)</div><div class="line">				&#123;</div><div class="line">					if (printMove(i)) f = 1;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				//be occupied?</div><div class="line">				if (f) return;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 20:</div><div class="line">			&#123;</div><div class="line">				for (int i = 1; i &lt; N; i++)//不包括红蓝司令部</div><div class="line">				&#123;</div><div class="line">					mAllCity[i]-&gt;addBlood();</div><div class="line">				&#125;</div><div class="line">				/*RedBaseInstance-&gt;Blood += 10;</div><div class="line">				BlueBaseInstance-&gt;Blood += 10;*/</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 30:</div><div class="line">			&#123;</div><div class="line">				for (int i = 1; i &lt; N; i++)</div><div class="line">				&#123;</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier != NULL&amp;&amp;mAllCity[i]-&gt;BlueSoldier == NULL)</div><div class="line">						RedBaseInstance-&gt;Blood += mAllCity[i]-&gt;takeBlood(0);</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier == NULL&amp;&amp;mAllCity[i]-&gt;BlueSoldier != NULL)</div><div class="line">						BlueBaseInstance-&gt;Blood += mAllCity[i]-&gt;takeBlood(1);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 35:</div><div class="line">			&#123;</div><div class="line">				//red</div><div class="line">				for (int i = 1; i &lt; N; i++)</div><div class="line">				&#123;</div><div class="line">					Soldier *p = mAllCity[i]-&gt;RedSoldier;</div><div class="line">					//if (!p) continue;</div><div class="line">					if (i &lt; N-1)</div><div class="line">					&#123;</div><div class="line">						if (p&amp;&amp;p-&gt;hasArrow)</div><div class="line">						&#123;</div><div class="line">							Arrow *q = p-&gt;hasArrow;</div><div class="line">							if (mAllCity[i + 1]-&gt;BlueSoldier)</div><div class="line">							&#123;</div><div class="line">								mAllCity[i + 1]-&gt;BlueSoldier-&gt;tArrow += R;</div><div class="line"></div><div class="line">								if (q-&gt;lose() == 0)//返回值为0说明arrow已经消失</div><div class="line">								&#123;</div><div class="line">									//delete q;</div><div class="line">									int t = p-&gt;getType();</div><div class="line">									switch (t)</div><div class="line">									&#123;</div><div class="line">									case 0:</div><div class="line">									&#123;</div><div class="line">										((Dragon *)p)-&gt;mWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 1:</div><div class="line">									&#123;</div><div class="line">										if (((Ninja *)p)-&gt;mWeapon1 &amp;&amp; ((Ninja *)p)-&gt;mWeapon1-&gt;getType() == 2) ((Ninja *)p)-&gt;mWeapon1 = NULL;</div><div class="line">										if (((Ninja *)p)-&gt;mWeapon2 &amp;&amp; ((Ninja *)p)-&gt;mWeapon2-&gt;getType() == 2) ((Ninja *)p)-&gt;mWeapon2 = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 2:</div><div class="line">									&#123;</div><div class="line">										((Iceman *)p)-&gt;mWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 4:</div><div class="line">									&#123;</div><div class="line">										((Wolf *)p)-&gt;arrowWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									&#125;</div><div class="line">									p-&gt;hasArrow = NULL;</div><div class="line">								&#125;</div><div class="line">								string s = st + &quot; red &quot;;</div><div class="line">								s += mAllCity[i]-&gt;RedSoldier-&gt;getName() + &apos; &apos; + toString(mAllCity[i]-&gt;RedSoldier-&gt;getId()) + &quot; shot&quot;;</div><div class="line">								if (mAllCity[i + 1]-&gt;BlueSoldier&amp;&amp;mAllCity[i + 1]-&gt;BlueSoldier-&gt;getBlood() &lt;= R)</div><div class="line">									s += &quot; and killed blue &quot; + mAllCity[i + 1]-&gt;BlueSoldier-&gt;getName() + &apos; &apos; + toString(mAllCity[i + 1]-&gt;BlueSoldier-&gt;getId());</div><div class="line">								puts(s.c_str());</div><div class="line">							&#125;</div><div class="line">						&#125;						</div><div class="line">					&#125;</div><div class="line">					//blue</div><div class="line">					if (i &gt; 1)</div><div class="line">					&#123;</div><div class="line">						Soldier *p = mAllCity[i]-&gt;BlueSoldier;</div><div class="line">						//if (!p) continue;</div><div class="line">						if (p&amp;&amp;p-&gt;hasArrow)</div><div class="line">						&#123;</div><div class="line">							Arrow *q = p-&gt;hasArrow;</div><div class="line">							if (mAllCity[i - 1]-&gt;RedSoldier)</div><div class="line">							&#123;</div><div class="line">								mAllCity[i - 1]-&gt;RedSoldier-&gt;tArrow += R;</div><div class="line">								if (q-&gt;lose() == 0)//返回值为0说明arrow已经消失</div><div class="line">								&#123;</div><div class="line">									//delete q;</div><div class="line">									int t = p-&gt;getType();</div><div class="line">									switch (t)</div><div class="line">									&#123;</div><div class="line">									case 0:</div><div class="line">									&#123;</div><div class="line">										((Dragon *)p)-&gt;mWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 1:</div><div class="line">									&#123;</div><div class="line">										if (((Ninja *)p)-&gt;mWeapon1 &amp;&amp; ((Ninja *)p)-&gt;mWeapon1-&gt;getType() == 2) ((Ninja *)p)-&gt;mWeapon1 = NULL;</div><div class="line">										if (((Ninja *)p)-&gt;mWeapon2 &amp;&amp; ((Ninja *)p)-&gt;mWeapon2-&gt;getType() == 2) ((Ninja *)p)-&gt;mWeapon2 = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 2:</div><div class="line">									&#123;</div><div class="line">										((Iceman *)p)-&gt;mWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									case 4:</div><div class="line">									&#123;</div><div class="line">										((Wolf *)p)-&gt;arrowWeapon = NULL;</div><div class="line">										break;</div><div class="line">									&#125;</div><div class="line">									&#125;</div><div class="line">									p-&gt;hasArrow = NULL;</div><div class="line">								&#125;</div><div class="line">								string s = st + &quot; blue &quot;;</div><div class="line">								s += mAllCity[i]-&gt;BlueSoldier-&gt;getName() + &apos; &apos; + toString(mAllCity[i]-&gt;BlueSoldier-&gt;getId()) + &quot; shot&quot;;</div><div class="line">								if (mAllCity[i - 1]-&gt;RedSoldier&amp;&amp;mAllCity[i - 1]-&gt;RedSoldier-&gt;getBlood() &lt;= R)</div><div class="line">									s += &quot; and killed red &quot; + mAllCity[i - 1]-&gt;RedSoldier-&gt;getName() + &apos; &apos; + toString(mAllCity[i - 1]-&gt;RedSoldier-&gt;getId());</div><div class="line">								puts(s.c_str());</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 38:</div><div class="line">			&#123;</div><div class="line"> 				for (int i = 1; i &lt; N; i++)</div><div class="line">				&#123;</div><div class="line">					string s = st;</div><div class="line">					Soldier *p = mAllCity[i]-&gt;RedSoldier;</div><div class="line">					if (p&amp;&amp;p-&gt;hasBomb)</div><div class="line">					&#123;</div><div class="line">						if (mAllCity[i]-&gt;BlueSoldier&amp;&amp;checkBomb(p,mAllCity[i]-&gt;BlueSoldier,mAllCity[i]-&gt;whoFirst))</div><div class="line">						&#123;</div><div class="line">							p-&gt;loseWeapon(1);</div><div class="line">							s = st;</div><div class="line">							s += &quot; red &quot;+p-&gt;getName()+&apos; &apos;+toString(p-&gt;getId())+&quot; used a bomb and killed blue &quot;;</div><div class="line">							s += mAllCity[i]-&gt;BlueSoldier-&gt;getName()+&apos; &apos;+toString(mAllCity[i]-&gt;BlueSoldier-&gt;getId());</div><div class="line">							puts(s.c_str());</div><div class="line">							p-&gt;die();</div><div class="line">							mAllCity[i]-&gt;BlueSoldier-&gt;die();</div><div class="line">							mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">							mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					s = st;</div><div class="line">					p = mAllCity[i]-&gt;BlueSoldier;</div><div class="line">					if (p&amp;&amp;p-&gt;hasBomb)</div><div class="line">					&#123;</div><div class="line">						if (mAllCity[i]-&gt;RedSoldier&amp;&amp;checkBomb2(mAllCity[i]-&gt;RedSoldier,p, mAllCity[i]-&gt;whoFirst))</div><div class="line">						&#123;</div><div class="line">							p-&gt;loseWeapon(1);</div><div class="line">							s = st;</div><div class="line">							s += &quot; blue &quot; + p-&gt;getName() + &apos; &apos; + toString(p-&gt;getId()) + &quot; used a bomb and killed red &quot;;</div><div class="line">							s += mAllCity[i]-&gt;RedSoldier-&gt;getName() + &apos; &apos; + toString(mAllCity[i]-&gt;RedSoldier-&gt;getId());</div><div class="line">							puts(s.c_str());</div><div class="line">							p-&gt;die();</div><div class="line">							mAllCity[i]-&gt;RedSoldier-&gt;die();</div><div class="line">							mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">							mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 40:</div><div class="line">			&#123;</div><div class="line">				for (int i = 1; i &lt; N; i++)//记录lion战斗前的blood</div><div class="line">				&#123;</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier&amp;&amp;mAllCity[i]-&gt;RedSoldier-&gt;getType() == 3)</div><div class="line">						((Lion *)mAllCity[i]-&gt;RedSoldier)-&gt;moveBlood();</div><div class="line">					if (mAllCity[i]-&gt;BlueSoldier&amp;&amp;mAllCity[i]-&gt;BlueSoldier-&gt;getType() == 3)</div><div class="line">						((Lion *)mAllCity[i]-&gt;BlueSoldier)-&gt;moveBlood();</div><div class="line">				&#125;</div><div class="line">				for (int i = 1; i &lt; N; i++)</div><div class="line">				&#123;</div><div class="line">					//先处理arrow事件</div><div class="line">					int r = checkArrow(mAllCity[i]-&gt;RedSoldier);</div><div class="line">					int b = checkArrow(mAllCity[i]-&gt;BlueSoldier);</div><div class="line">					if (r == -1 || b == -1)</div><div class="line">					&#123;</div><div class="line">						if (r==1) mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">						if (b==1) mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">						continue;//no fight</div><div class="line">					&#125;</div><div class="line">					if (r == 1 &amp;&amp; b == 1) &#123; mAllCity[i]-&gt;RedSoldier = NULL; mAllCity[i]-&gt;BlueSoldier = NULL; &#125;//all die,no fight</div><div class="line">					if (r == 0 &amp;&amp; b == 1) &#123; afterbattle(i, 1); mAllCity[i]-&gt;BlueSoldier = NULL; redReward(); &#125;//blue die,red win</div><div class="line">					if (r == 1 &amp;&amp; b == 0) &#123; afterbattle(i, 2); mAllCity[i]-&gt;RedSoldier = NULL; blueReward(); &#125;//blue win</div><div class="line"></div><div class="line">					if (r == 0 &amp;&amp; b == 0)//all not die,begin to fight</div><div class="line">					&#123;</div><div class="line">						int t = mAllCity[i]-&gt;whoFirst;</div><div class="line">						if (t == 0)//red attack,blue fightback</div><div class="line">						&#123;</div><div class="line">							int tmp = printFight(i, mAllCity[i]-&gt;RedSoldier, mAllCity[i]-&gt;BlueSoldier);</div><div class="line">							if (tmp)//没杀死，等待反击</div><div class="line">							&#123;</div><div class="line">								int tmp2=printFightBack(i, mAllCity[i]-&gt;BlueSoldier, mAllCity[i]-&gt;RedSoldier);</div><div class="line">								if (tmp2)//反击没死，平局</div><div class="line">								&#123;</div><div class="line">									afterbattle(i, 0);</div><div class="line">								&#125;</div><div class="line">								else// blue win</div><div class="line">								&#123;</div><div class="line">									printKilled(i, mAllCity[i]-&gt;RedSoldier);</div><div class="line">									afterbattle(i, 2);</div><div class="line">									mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">							else//杀死了，red win</div><div class="line">							&#123;</div><div class="line">								printKilled(i, mAllCity[i]-&gt;BlueSoldier);</div><div class="line">								afterbattle(i, 1);</div><div class="line">								mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						else</div><div class="line">						&#123;</div><div class="line">							int tmp = printFight(i, mAllCity[i]-&gt;BlueSoldier, mAllCity[i]-&gt;RedSoldier);</div><div class="line">							if (tmp)//没杀死，等待反击</div><div class="line">							&#123;</div><div class="line">								int tmp2 = printFightBack(i, mAllCity[i]-&gt;RedSoldier, mAllCity[i]-&gt;BlueSoldier);</div><div class="line">								if (tmp2)//反击没死，平局</div><div class="line">								&#123;</div><div class="line">									afterbattle(i, 0);</div><div class="line">								&#125;</div><div class="line">								else// red win</div><div class="line">								&#123;</div><div class="line">									printKilled(i, mAllCity[i]-&gt;BlueSoldier);</div><div class="line">									afterbattle(i, 1);</div><div class="line">									mAllCity[i]-&gt;BlueSoldier = NULL;</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">							else//杀死了，blue win</div><div class="line">							&#123;</div><div class="line">								printKilled(i, mAllCity[i]-&gt;RedSoldier);</div><div class="line">								afterbattle(i, 2);</div><div class="line">								mAllCity[i]-&gt;RedSoldier = NULL;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				redReward();</div><div class="line">				blueReward();</div><div class="line">				RedBaseInstance-&gt;tackBloodWin();</div><div class="line">				BlueBaseInstance-&gt;tackBloodWin();</div><div class="line">				for (int i = 1; i &lt; N; i++)//output</div><div class="line">				&#123;</div><div class="line">					while (!mAllCity[i]-&gt;output.empty())</div><div class="line">					&#123;</div><div class="line">						puts(mAllCity[i]-&gt;output.front().c_str());</div><div class="line">						mAllCity[i]-&gt;output.pop();</div><div class="line">					&#125;</div><div class="line">					/*if (mAllCity[i]-&gt;redReward)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;redReward = 0;</div><div class="line">						string s = printNowTime() + mAllCity[i]-&gt;RedSoldier-&gt;getPrint() + &quot; earned 8 elements for his headquarter&quot;;</div><div class="line">						puts(s.c_str());</div><div class="line">					&#125;</div><div class="line">					if (mAllCity[i]-&gt;blueReward)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;blueReward = 0;</div><div class="line">						string s = printNowTime() + mAllCity[i]-&gt;BlueSoldier-&gt;getPrint() + &quot; earned 8 elements for his headquarter&quot;;</div><div class="line">						puts(s.c_str());</div><div class="line">					&#125;*/</div><div class="line">					if (mAllCity[i]-&gt;FlagRaise == 1&amp;&amp; mAllCity[i]-&gt;lastPrintFlag!=1)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;FlagRaise = 0;</div><div class="line">						mAllCity[i]-&gt;lastPrintFlag = 1;</div><div class="line">						string s = printNowTime() + &quot;red flag raised in city &quot; + toString(i);</div><div class="line">						puts(s.c_str());</div><div class="line">					&#125;</div><div class="line">					if (mAllCity[i]-&gt;FlagRaise == 2&amp;&amp; mAllCity[i]-&gt;lastPrintFlag!=2)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;FlagRaise = 0;</div><div class="line">						mAllCity[i]-&gt;lastPrintFlag = 2;</div><div class="line">						string s = printNowTime() + &quot;blue flag raised in city &quot; + toString(i);</div><div class="line">						puts(s.c_str());</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 50:</div><div class="line">			&#123;</div><div class="line">				string s = printNowTime() + toString(RedBaseInstance-&gt;Blood) + &quot; elements in red headquarter&quot;;</div><div class="line">				puts(s.c_str());</div><div class="line">				s = printNowTime() + toString(BlueBaseInstance-&gt;Blood) + &quot; elements in blue headquarter&quot;;</div><div class="line">				puts(s.c_str());</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			case 55:</div><div class="line">			&#123;</div><div class="line">				for (int i = 0; i &lt;= N; i++)</div><div class="line">				&#123;</div><div class="line">					if (mAllCity[i]-&gt;RedSoldier)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;RedSoldier-&gt;printWeapon();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				if (RedOccSoldier) RedOccSoldier-&gt;printWeapon();</div><div class="line">				if (BlueOccSoldier) BlueOccSoldier-&gt;printWeapon();</div><div class="line">				for (int i = 0; i &lt;= N; i++)</div><div class="line">				&#123;</div><div class="line">					if (mAllCity[i]-&gt;BlueSoldier)</div><div class="line">					&#123;</div><div class="line">						mAllCity[i]-&gt;BlueSoldier-&gt;printWeapon();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int t;</div><div class="line">	cin &gt;&gt; t;</div><div class="line">	int c = 0;</div><div class="line">	while (t--) </div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++c &lt;&lt; &quot;:&quot; &lt;&lt; endl;</div><div class="line">		Init();</div><div class="line">		Game();</div><div class="line">	&#125;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Sword::init()</div><div class="line">&#123;</div><div class="line">	//Attack = mAllSoldier[Belong]-&gt;getAttack()*0.2;</div><div class="line">&#125;</div><div class="line">void Lion::init()</div><div class="line">&#123;</div><div class="line">	if (getCamp() == 0) &#123;</div><div class="line">		Loyalty = RedBaseInstance-&gt;Blood;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		Loyalty = BlueBaseInstance-&gt;Blood;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void getWeapon(Soldier * t,Weapon* &amp;p, int code)</div><div class="line">&#123;</div><div class="line">	switch (code)</div><div class="line">	&#123;</div><div class="line">		case 0:</div><div class="line">		&#123;</div><div class="line">			p = new Sword();</div><div class="line">			((Sword *)p)-&gt;init();</div><div class="line">			((Sword *)p)-&gt;setAttack(t-&gt;getAttack());</div><div class="line">			if (p-&gt;getAttack() == 0)</div><div class="line">			&#123;</div><div class="line">				delete p;</div><div class="line">				p = NULL;</div><div class="line">			&#125;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case 1:</div><div class="line">		&#123;</div><div class="line">			p = new Bomb();</div><div class="line">			((Bomb *)p)-&gt;init();</div><div class="line">			t-&gt;hasBomb = ((Bomb *)p);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case 2:</div><div class="line">		&#123;</div><div class="line">			p = new Arrow();</div><div class="line">			((Arrow *)p)-&gt;init();</div><div class="line">			t-&gt;hasArrow = ((Arrow *)p);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//p-&gt;setBelong(getuId());//设置属于谁的</div><div class="line">&#125;</div><div class="line">void Dragon::init()</div><div class="line">&#123;</div><div class="line">	getWeapon(this,mWeapon, Id % 3);</div><div class="line">	if(mWeapon) mWeapon-&gt;setBelong(getuId());//设置属于谁的</div><div class="line">	if (Camp == 0)//3.初始化morale</div><div class="line">	&#123;</div><div class="line">		Morale = (double)RedBaseInstance-&gt;Blood / (double)SoldierBlood[0];</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		Morale = (double)BlueBaseInstance-&gt;Blood / (double)SoldierBlood[0];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">Soldier* Base::CreatSoldier()</div><div class="line">&#123;</div><div class="line">	Soldier *tmp=NULL;</div><div class="line">	switch (creatwho(SoidierNum))</div><div class="line">	&#123;</div><div class="line">	case 0://iceman</div><div class="line">		tmp = new Iceman();</div><div class="line">		break;</div><div class="line">	case 1://lion</div><div class="line">		tmp = new Lion();</div><div class="line">		break;</div><div class="line">	case 2://wolf</div><div class="line">		tmp = new Wolf();</div><div class="line">		break;</div><div class="line">	case 3://ninja</div><div class="line">		tmp = new Ninja();</div><div class="line">		break;</div><div class="line">	case 4://dragon</div><div class="line">		tmp = new Dragon();</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">	if (tmp-&gt;getBlood() &lt;= Blood)//可以制造出生命值为 m 的武士</div><div class="line">	&#123;</div><div class="line">		Blood -= tmp-&gt;getBlood();</div><div class="line">		SoidierNum++;</div><div class="line">		tmp-&gt;setCamp(getCamp());</div><div class="line">		tmp-&gt;setId(SoidierNum);</div><div class="line">		tmp-&gt;init();</div><div class="line">		mSoldier.push_back(tmp);</div><div class="line">		mAllSoldier.push_back(tmp);</div><div class="line"></div><div class="line">		if (getCamp() == 0)</div><div class="line">		&#123;</div><div class="line">			mAllCity[0]-&gt;RedSoldier = tmp;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			mAllCity[N]-&gt;BlueSoldier = tmp;</div><div class="line">		&#125;</div><div class="line">		return tmp;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		delete tmp;//</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Dragon::yell(int t)//judge whether to yell</div><div class="line">&#123;</div><div class="line">	if (mAllCity[t]-&gt;whoFirst == Camp)//检测是否先攻击</div><div class="line">	&#123;</div><div class="line">		if (Morale &gt; 0.8)</div><div class="line">		&#123;</div><div class="line">			string s = printTime();</div><div class="line">			if (Camp == 0) s += &quot; red &quot;;</div><div class="line">			if (Camp == 1) s += &quot; blue &quot;;</div><div class="line">			s += getName() + &apos; &apos; + toString(getId())+&quot; yelled in city &quot;+toString(t);</div><div class="line">			mAllCity[t]-&gt;output.push(s);</div><div class="line">			//puts(s.c_str());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_算法作业_枚举]]></title>
      <url>http://blog.acbingo.cn/2016/03/05/coursera_%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A_%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>枚举的两个题，感觉很经典。虽然做了一天，但是尝试了各种解法，理解了很多东西。<br><a id="more"></a></p>
<h1 id="编程题＃1：-画家问题"><a href="#编程题＃1：-画家问题" class="headerlink" title="编程题＃1： 画家问题"></a>编程题＃1： 画家问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</div><div class="line"></div><div class="line">注意： 总时间限制: 1000ms 内存限制: 65536kB</div><div class="line"></div><div class="line">描述</div><div class="line"></div><div class="line">有一个正方形的墙，由N*N个正方形的砖组成，其中一些砖是白色的，另外一些砖是黄色的。Bob是个画家，想把全部的砖都涂成黄色。但他的画笔不好使。当他用画笔涂画第(i, j)个位置的砖时， 位置(i-1, j)、 (i+1, j)、 (i, j-1)、 (i, j+1)上的砖都会改变颜色。请你帮助Bob计算出最少需要涂画多少块砖，才能使所有砖的颜色都变成黄色。</div><div class="line"></div><div class="line">![](http://media.openjudge.cn/images/2813_1.jpg)</div><div class="line">输入</div><div class="line"></div><div class="line">第一行是个整数t(1≤t ≤20)，表示要测试的案例数。然后是t个案例。每个案例的首行是一个整数n (1≤n ≤15)，表示墙的大小。接下来的n行表示墙的初始状态。每一行包含n个字符。第i行的第j个字符表示位于位置(i,j)上的砖的颜色。“w”表示白砖，“y”表示黄砖。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">每个案例输出一行。如果Bob能够将所有的砖都涂成黄色，则输出最少需要涂画的砖数，否则输出“inf”。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">2</div><div class="line">3</div><div class="line">yyy</div><div class="line">yyy</div><div class="line">yyy</div><div class="line">5</div><div class="line">wwwww</div><div class="line">wwwww</div><div class="line">wwwww</div><div class="line">wwwww</div><div class="line">wwwww</div><div class="line">样例输出</div><div class="line"></div><div class="line">0</div><div class="line">15</div></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>跟课文中讲的例题一样，仔细分析后发现，其实当确定好第一行的画法后，第二行的画法可由第三行确定，进而依次确定到最后一行，然后检测最后一行是否都为黄色即可。</p>
<p>枚举完第一行的所有情况，记录下符合要求的解的次数，找到最小值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int change(int a[][20], int n, int i, int j)</div><div class="line">&#123;</div><div class="line">	a[i][j]++; a[i][j] %= 2;</div><div class="line">	a[i - 1][j]++; a[i - 1][j] %= 2;</div><div class="line">	a[i + 1][j]++; a[i + 1][j] %= 2;</div><div class="line">	a[i][j - 1]++; a[i][j - 1] %= 2;</div><div class="line">	a[i][j + 1]++; a[i][j + 1] %= 2;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">int fun(int a[][20], int n)</div><div class="line">&#123;</div><div class="line">	int ans = 0;</div><div class="line">	for (int i = 1; i &lt; n; i++)</div><div class="line">		for (int j = 1; j &lt;= n; j++)</div><div class="line">		&#123;</div><div class="line">			if (a[i][j] == 0)</div><div class="line">			&#123;</div><div class="line">				ans++;</div><div class="line">				change(a, n, i + 1, j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	for (int i = 1; i &lt;= n; i++)</div><div class="line">		for (int j = 1; j &lt;= n; j++)</div><div class="line">		&#123;</div><div class="line">			if (a[i][j] == 0) return -1;</div><div class="line">		&#125;</div><div class="line">	return ans;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int T;</div><div class="line">	cin &gt;&gt; T;</div><div class="line">	while (T--)</div><div class="line">	&#123;</div><div class="line">		int n;</div><div class="line">		cin &gt;&gt; n;</div><div class="line">		int a[20][20] = &#123; 0 &#125;;</div><div class="line">		for (int i = 1; i &lt;= n; i++)</div><div class="line">			for (int j = 1; j &lt;= n; j++)</div><div class="line">			&#123;</div><div class="line">				char x;</div><div class="line">				cin &gt;&gt; x;</div><div class="line">				if (x == &apos;y&apos;) a[i][j] = 1;</div><div class="line">				else a[i][j] = 0;</div><div class="line">			&#125;</div><div class="line">		int ans = 0xffff;</div><div class="line">		for (int k = 0; k&lt;=n; k++)</div><div class="line">		&#123;</div><div class="line">			int b[20][20] = &#123; 0 &#125;;</div><div class="line">			int tmp[20] = &#123; 0 &#125;;</div><div class="line">			for (int i = 0; i&lt;k; i++)</div><div class="line">			&#123;</div><div class="line">				tmp[n - i - 1] = 1;</div><div class="line">			&#125;</div><div class="line">			do</div><div class="line">			&#123;</div><div class="line">				for (int i = 1; i &lt;= n; i++)</div><div class="line">					for (int j = 1; j &lt;= n; j++)</div><div class="line">						b[i][j] = a[i][j];</div><div class="line">				for (int i = 0; i &lt; n; i++)</div><div class="line">				&#123;</div><div class="line">					if (tmp[i] == 1) change(b, n, 1, i + 1);</div><div class="line">				&#125;</div><div class="line">				int p = fun(b, n);</div><div class="line">				if (p &gt;= 0) ans = min(ans, k + p);</div><div class="line">			&#125; while (next_permutation(tmp, tmp + n));</div><div class="line">		&#125;</div><div class="line">		if (ans == 0xffff) cout &lt;&lt; &quot;inf&quot; &lt;&lt; endl;</div><div class="line">		else cout &lt;&lt; ans &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃2：拨钟问题"><a href="#编程题＃2：拨钟问题" class="headerlink" title="编程题＃2：拨钟问题"></a>编程题＃2：拨钟问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</div><div class="line"></div><div class="line">注意： 总时间限制: 1000ms 内存限制: 65536kB</div><div class="line"></div><div class="line">描述</div><div class="line"></div><div class="line">有9个时钟，排成一个3*3的矩阵。</div><div class="line"></div><div class="line">        |-------|    |-------|    |-------|</div><div class="line">        |       |    |       |    |   |   |</div><div class="line">        |---O   |    |---O   |    |   O   |</div><div class="line">        |       |    |       |    |       |</div><div class="line">        |-------|    |-------|    |-------|    </div><div class="line">            A            B            C    </div><div class="line">        |-------|    |-------|    |-------|</div><div class="line">        |       |    |       |    |       |</div><div class="line">        |   O   |    |   O   |    |   O   |</div><div class="line">        |   |   |    |   |   |    |   |   |</div><div class="line">        |-------|    |-------|    |-------|    </div><div class="line">            D            E            F    </div><div class="line">        |-------|    |-------|    |-------|</div><div class="line">        |       |    |       |    |       |</div><div class="line">        |   O   |    |   O---|    |   O   |</div><div class="line">        |   |   |    |       |    |   |   |</div><div class="line">        |-------|    |-------|    |-------|    </div><div class="line">            G            H            I    </div><div class="line">                       (图 1)</div><div class="line">现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。</div><div class="line"></div><div class="line">移动    影响的时钟  1        ABDE </div><div class="line"> 2        ABC </div><div class="line"> 3        BCEF </div><div class="line"> 4        ADG </div><div class="line"> 5        BDEFH </div><div class="line"> 6        CFI </div><div class="line"> 7        DEGH </div><div class="line"> 8        GHI </div><div class="line"> 9        EFHI         </div><div class="line">    (图 2)</div><div class="line">输入</div><div class="line"></div><div class="line">从标准输入设备读入9个整数，表示各时钟指针的起始位置。0=12点、1=3点、2=6点、3=9点。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号大小，输出结果。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">3 3 0</div><div class="line">2 2 2</div><div class="line">2 1 2</div><div class="line">样例输出</div><div class="line"></div><div class="line">4 5 8 9</div></pre></td></tr></table></figure>
<h1 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h1><p>这一题实质类似熄灯问题和画家问题。其共通点在于：<br>操作对环境的改变是无序的，每个操作都会影响到周围的状态。<br>同时每一种操作都有周期性限制，也即最多需要几次操作，多于这个次数产生循环。</p>
<p>熄灯问题中，每个灯最多熄灯一次，因为灯只有两种状态，<br>并且循环。而这里，有4种循环的状态，因此每个移动操作顶多使用3次。</p>
<p>首先，可以直接暴力枚举，最多有4^9个组合，不会超时</p>
<p>其实仔细分析发现，只需要枚举前三项即可，后面的根据前三项都可以确定出来（有点类似于百钱百鸡问题）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int check(int a[])</div><div class="line">&#123;</div><div class="line">	for (int i = 1; i &lt;= 9; i++)</div><div class="line">		if (a[i] != 0) return 0;</div><div class="line">	return 1;</div><div class="line">&#125;</div><div class="line">void nextop(int op[])</div><div class="line">&#123;</div><div class="line">	//肯定有解，所以不必考虑搜完的情况</div><div class="line">	int t = 9;</div><div class="line">	op[t]++;</div><div class="line">	while (op[t] &gt; 3)</div><div class="line">	&#123;</div><div class="line">		op[t] %= 4;</div><div class="line">		op[t - 1]++;</div><div class="line">		t--;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void nextop2(int a[],int op[])</div><div class="line">&#123;</div><div class="line">	//肯定有解，所以不必考虑搜完的情况</div><div class="line">	/*int t = 9;</div><div class="line">	op[t]++;</div><div class="line">	while (op[t] &gt; 3)</div><div class="line">	&#123;</div><div class="line">		op[t]%=4;</div><div class="line">		op[t - 1]++;</div><div class="line">		t--;</div><div class="line">	&#125;*/</div><div class="line">	int t = 3;</div><div class="line">	op[t]++;</div><div class="line">	while (op[t] &gt; 3)</div><div class="line">	&#123;</div><div class="line">		op[t] %= 4;</div><div class="line">		op[t - 1]++;</div><div class="line">		t--;</div><div class="line">	&#125;</div><div class="line">	op[4] = 4 - a[1] - op[1] - op[2]; op[4] += 16; op[4] %= 4;</div><div class="line">	op[5] = 4 - a[2] - op[1] - op[2] - op[3]; op[5] += 16; op[5] %= 4;</div><div class="line">	op[6] = 4 - a[3] - op[2] - op[3]; op[6] += 16; op[6] %= 4;</div><div class="line">	op[7] = 4 - a[4] - op[1] - op[4] - op[5]; op[7] += 16; op[7] %= 4;</div><div class="line">	op[8] = 4 - a[7] - op[4] - op[7]; op[8] += 16; op[8] %= 4;</div><div class="line">	op[9] = 4 - a[9] - op[6] - op[8]; op[9] += 16; op[9] %= 4;</div><div class="line">&#125;</div><div class="line">void move(int a[], char t)</div><div class="line">&#123;</div><div class="line">	a[t - &apos;A&apos; + 1]++; a[t - &apos;A&apos; + 1] %= 4;</div><div class="line">&#125;</div><div class="line">void fun(int a[], int op[], int k)</div><div class="line">&#123;</div><div class="line">	for (int i = 1; i &lt;= 9; i++)</div><div class="line">		for (int j = 1; j &lt;= op[i]; j++)</div><div class="line">		&#123;</div><div class="line">			switch (i)</div><div class="line">			&#123;</div><div class="line">			case 1:move(a, &apos;A&apos;); move(a, &apos;B&apos;); move(a, &apos;D&apos;); move(a, &apos;E&apos;); break;</div><div class="line">			case 2:move(a, &apos;A&apos;); move(a, &apos;B&apos;); move(a, &apos;C&apos;); break;</div><div class="line">			case 3:move(a, &apos;B&apos;); move(a, &apos;C&apos;); move(a, &apos;E&apos;); move(a, &apos;F&apos;); break;</div><div class="line">			case 4:move(a, &apos;A&apos;); move(a, &apos;D&apos;); move(a, &apos;G&apos;); break;</div><div class="line">			case 5:move(a, &apos;B&apos;); move(a, &apos;D&apos;); move(a, &apos;E&apos;); move(a, &apos;F&apos;); move(a, &apos;H&apos;); break;</div><div class="line">			case 6:move(a, &apos;C&apos;); move(a, &apos;F&apos;); move(a, &apos;I&apos;); break;</div><div class="line">			case 7:move(a, &apos;D&apos;); move(a, &apos;E&apos;); move(a, &apos;G&apos;); move(a, &apos;H&apos;); break;</div><div class="line">			case 8:move(a, &apos;G&apos;); move(a, &apos;H&apos;); move(a, &apos;I&apos;); break;</div><div class="line">			case 9:move(a, &apos;E&apos;); move(a, &apos;F&apos;); move(a, &apos;H&apos;); move(a, &apos;I&apos;); break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int a[11] = &#123; 0 &#125;;</div><div class="line">	for (int i = 1; i &lt;= 9; i++)</div><div class="line">		cin &gt;&gt; a[i];</div><div class="line">	int op[11] = &#123; 0 &#125;;</div><div class="line">	op[9] = -1; nextop(op);</div><div class="line">	op[3] = -1; nextop2(a,op);</div><div class="line">	while (1)</div><div class="line">	&#123;</div><div class="line">		int b[11];</div><div class="line">		for (int i = 1; i &lt;= 9; i++)</div><div class="line">			b[i] = a[i];</div><div class="line">		fun(b, op, 9);</div><div class="line">		if (check(b)) break;</div><div class="line">		//nextop(op);//枚举所有情况，暴力</div><div class="line">		nextop2(a,op);//分析问题后发现，只需枚举前三项</div><div class="line">	&#125;</div><div class="line">	int ans[50] = &#123; 0 &#125;;</div><div class="line">	int top = 0;</div><div class="line">	for (int i = 1; i &lt;= 9; i++)</div><div class="line">		for (int j = 1; j &lt;= op[i]; j++)</div><div class="line">		&#123;</div><div class="line">			ans[top++] = i;</div><div class="line">		&#125;</div><div class="line">	cout &lt;&lt; ans[0];</div><div class="line">	for (int i = 1; i &lt; top; i++)</div><div class="line">		cout &lt;&lt; &quot; &quot; &lt;&lt; ans[i];</div><div class="line">	cout &lt;&lt; endl;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_c++高级主体和c++11新特性]]></title>
      <url>http://blog.acbingo.cn/2016/01/27/coursera_c++%E9%AB%98%E7%BA%A7%E4%B8%BB%E4%BD%93%E5%92%8Cc++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>c++11特性<br><a id="more"></a><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0e2l83chzj30rf0f5jtr.jpg" alt=""><br>成员变量可以有初始值了（从java学来的）<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0e38urgdxj30qj0erjsw.jpg" alt=""></p>
<p>auto关键字<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0e39gg63ej30r60fi416.jpg" alt=""></p>
<p>是不是有些东西只能用auto关键字来做呢？<br>当返回值不确定的时候，可以用auto来实际情况实际判断。看下面两个实例<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0e4ripl3sj30r60f0wgm.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0e4vcpa9xj30qa0f8wha.jpg" alt=""></p>
<p>智能指针<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f0e4xdiuvzj30ql0esdk1.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0e50viks5j30qq0em0vo.jpg" alt=""><br>当一个东西没有被托管时，会自动被delete掉。<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0e546k9f0j30qu0entcn.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0e5m2pudij30qh0eujub.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0eb8axfcyj30qq0ektbq.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0eba8pz8uj30qf0f4412.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0ebdgqjw8j30qw0ef780.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0egfertlmj30qp0evn08.jpg" alt=""></p>
<p>c++11终于引入了哈希表<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0egfertlmj30qp0evn08.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f0egi564kmj30qk0esmz8.jpg" alt=""><br>用法和map一模一样，但是相比下时间效率更高，但是内存占用更多</p>
<p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0egj99r09j30qv0epwii.jpg" alt=""></p>
<p>Lambda表达式<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f0egzh835uj30qm0epgnf.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0eh3k5bvlj30qt0f2782.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0eh8mhzvwj30qs0esq55.jpg" alt=""><br>lambda表达式的好用之处<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0ehwdcf90j30qq0engnl.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0ehy5u66sj30qq0esmxu.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0ehzxumw1j30qv0engok.jpg" alt=""><br>递归调用<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f0ei3xnj9ej30r10etdiq.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_c++期末考试]]></title>
      <url>http://blog.acbingo.cn/2016/01/27/coursera_c++%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>期末考试、习题、答案以及反思。<br><a id="more"></a></p>
<h1 id="编程题＃1：输出200"><a href="#编程题＃1：输出200" class="headerlink" title="编程题＃1：输出200"></a>编程题＃1：输出200</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>使以下代码输出结果为200.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Number &#123;</div><div class="line">public:</div><div class="line">    int num;</div><div class="line">    Number(int n=0): num(n) &#123;&#125;</div><div class="line">// 在此处补充你的代码</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    Number n1(10), n2(20);</div><div class="line">    Number n3;n3 = n1*n2;</div><div class="line">    cout &lt;&lt; int(n3) &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">输出结果为200。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line">样例输出</div><div class="line"></div><div class="line">200</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Number operator *( Number const &amp; n2)</div><div class="line">	&#123;</div><div class="line">		return Number(this-&gt;num*n2.num);</div><div class="line">	&#125;</div><div class="line">	operator int()</div><div class="line">	&#123;</div><div class="line">		return this-&gt;num;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>考察自定义强制类型转换。<br>重载格式如下<br>operator int()<br>无返回值，无参数</p>
<h1 id="编程题＃2：输出指定结果一"><a href="#编程题＃2：输出指定结果一" class="headerlink" title="编程题＃2：输出指定结果一"></a>编程题＃2：输出指定结果一</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>填写代码，使输出结果为</p>
<p>2</p>
<p>2</p>
<p>8</p>
<p>10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Number &#123;</div><div class="line">public:</div><div class="line">    int num;</div><div class="line">    Number(int n): num(n) &#123;</div><div class="line">    &#125;</div><div class="line">// 在此处补充你的代码</div><div class="line">&#125;;</div><div class="line">int main() &#123;</div><div class="line">    Number a(2);</div><div class="line">    Number b = a;</div><div class="line">    cout &lt;&lt; a.value() &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; b.value() &lt;&lt; endl;</div><div class="line">    a.value() = 8;</div><div class="line">    cout &lt;&lt; a.value() &lt;&lt; endl;</div><div class="line">    a+b;</div><div class="line">    cout &lt;&lt; a.value() &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">使输出结果为</div><div class="line"></div><div class="line">2</div><div class="line"></div><div class="line">2</div><div class="line"></div><div class="line">8</div><div class="line"></div><div class="line">10</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line">样例输出</div><div class="line"></div><div class="line">2</div><div class="line">2</div><div class="line">8</div><div class="line">10</div></pre></td></tr></table></figure>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int&amp; value()</div><div class="line">	&#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line">	void operator+(Number const&amp; i)</div><div class="line">	&#123;</div><div class="line">		this-&gt;num += i.num;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>重载+号</p>
<h1 id="编程题＃3：计算数列平方和"><a href="#编程题＃3：计算数列平方和" class="headerlink" title="编程题＃3：计算数列平方和"></a>编程题＃3：计算数列平方和</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>请写出sum函数，使其可以计算输入数列的平方和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int sqr(int n) &#123;</div><div class="line">    return n * n;</div><div class="line">&#125;</div><div class="line">int main() &#123;</div><div class="line">    int t, n, a[0x100];</div><div class="line">    cin &gt;&gt; t;</div><div class="line">    for (int c = 0; c &lt; t; ++c) &#123;</div><div class="line">        cin &gt;&gt; n;</div><div class="line">    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];</div><div class="line">    cout &lt;&lt; sum(a, n, sqr) &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">第一行是一个整数 t (t &lt;= 10)，表示数据组数；</div><div class="line"></div><div class="line">每组输入数据包含两行，第一行是一个整数 n (n &lt;= 100)，</div><div class="line"></div><div class="line">第二行是 n 个用空格分隔开的整数</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">对每组输入数据，输出该组数据中 n 个整数的平方和</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">2</div><div class="line">2</div><div class="line">4 3</div><div class="line">3</div><div class="line">0 1 2</div><div class="line">样例输出</div><div class="line"></div><div class="line">25</div><div class="line">5</div></pre></td></tr></table></figure>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int sum(int* a, int n, int (*op)(int))</div><div class="line">&#123;</div><div class="line">	int ans = 0;</div><div class="line">	for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">		ans += (*op)(a[i]);</div><div class="line">	&#125;</div><div class="line">	return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考察函数名作为参数的传递。<br>int （<em>op）(int,int)
</em>op即为函数名</p>
<h1 id="编程题＃4：计算整数平方和"><a href="#编程题＃4：计算整数平方和" class="headerlink" title="编程题＃4：计算整数平方和"></a>编程题＃4：计算整数平方和</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>下列程序每次读入一个整数N，若N为0则退出，否则输出N和N的平方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line">        CType obj;</div><div class="line">        int n;</div><div class="line">        cin&gt;&gt;n;</div><div class="line">        while ( n ) &#123;</div><div class="line">                obj.setvalue(n);</div><div class="line">                cout&lt;&lt;obj++&lt;&lt;&quot; &quot;&lt;&lt;obj&lt;&lt;endl;</div><div class="line">                cin&gt;&gt;n;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">K个整数。除最后一个数据外，其他数据均不为0。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">K-1行。第I行输出第I个输入数和它的平方。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">1 5 8 9 0</div><div class="line">样例输出</div><div class="line"></div><div class="line">1 1</div><div class="line">5 25</div><div class="line">8 64</div><div class="line">9 81</div></pre></td></tr></table></figure>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class CType &#123;</div><div class="line">	int n;</div><div class="line">public:</div><div class="line">	void setvalue(int t)</div><div class="line">	&#123;</div><div class="line">		n = t;</div><div class="line">	&#125;</div><div class="line">	//输入输出运算符只能用友元函数重载</div><div class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const CType &amp;c);</div><div class="line">	int operator++(int)</div><div class="line">	&#123;</div><div class="line">		return n;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">ostream &amp;operator&lt;&lt;(ostream &amp;os, const CType &amp;c)</div><div class="line">&#123;</div><div class="line">	os &lt;&lt; c.n*c.n;</div><div class="line">	return os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考察&lt;&lt;运算符的重载，<br>只能重载为友元函数<br>ostream &amp;operator&lt;&lt;(ostream &amp;os, const CType &amp;c)<br>{<br>    os &lt;&lt; c.n*c.n;<br>    return os;<br>}<br>对于“++” 和“–”这两个一元运算符，存在前置和后置的问题，在定义时必须有所区分。<br>（1） 用成员函数的形式来进行重载<br>如果++为前增量运算符时，重载函数的一般格式为：<br>&lt; type &gt; ClassName :: operator ++ ( )<br>{<br> //…<br>}</p>
<p>如果++为后增量运算符时，重载函数的一般格式为：<br>&lt; type &gt; ClassName :: operator ++ ( int  )<br>{<br> //…<br>}</p>
<p>(2) 非成员函数形式的重载<br>以++ 为例说明<br>用友元函数来实现“++”运算符的重载时，前置++运算符的重载的一般格式：<br>friend <type> operator ++ (ClassName &amp; );<br>其中，第一个参数是要实现++运算的对象。</type></p>
<p>后置++运算符的重载的一般格式：<br>friend <type> operator ++(ClassName &amp;,int);<br>其中，第一个参数是要实现++运算的对象；而第二个参数除了用于区分是后置运算外，并没有其他意义，故起参数可有可无</type></p>
<h1 id="编程题＃5：计算数组的低3位之和"><a href="#编程题＃5：计算数组的低3位之和" class="headerlink" title="编程题＃5：计算数组的低3位之和"></a>编程题＃5：计算数组的低3位之和</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>输入一个正整数构成的数组a[0], a[1], a[2], … , a[n-1], 计算它们的二进制低3位之和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line">        int v, my_sum=0;</div><div class="line">        vector&lt;int&gt; vec;</div><div class="line">        cin&gt;&gt;v;</div><div class="line">        while ( v ) &#123;</div><div class="line">                vec.push_back(v);</div><div class="line">                cin&gt;&gt;v;</div><div class="line">        &#125;</div><div class="line">        for_each(vec.begin(), vec.end(), CMy_add(my_sum));</div><div class="line">        cout&lt;&lt;my_sum&lt;&lt;endl;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">数组a,以0表示输入结束。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">一个整数 , 所输入数组各元素的二进制低3位之和。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">1 3 9 7 3 6 20 15 18 17 4 8 18 0</div><div class="line">样例输出</div><div class="line"></div><div class="line">41</div><div class="line">## 代码</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class CMy_add</div><div class="line">&#123;</div><div class="line">	int &amp;sum;</div><div class="line">public:</div><div class="line">	CMy_add(int &amp;n) :sum(n) &#123;&#125;</div><div class="line">	int operator()(int x)</div><div class="line">	&#123;</div><div class="line">		while (x &gt;= 8) &#123;</div><div class="line">			x -= 8;</div><div class="line">		&#125;</div><div class="line">		sum += x;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>考察函数对象。此题不会。<br>这节课没好好听= =</p>
<h1 id="编程题＃6：MyString"><a href="#编程题＃6：MyString" class="headerlink" title="编程题＃6：MyString"></a>编程题＃6：MyString</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>请写出 MyString类，使得下面程序的输出结果符合下面的要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int CompareString( const void * e1, const void * e2)</div><div class="line">&#123;</div><div class="line">        MyString * s1 = (MyString * ) e1;</div><div class="line">        MyString * s2 = (MyString * ) e2;</div><div class="line">        if( * s1 &lt; *s2 )</div><div class="line">                 return -1;</div><div class="line">        else if( *s1 == *s2)</div><div class="line">                 return 0;</div><div class="line">        else if( *s1 &gt; *s2 )</div><div class="line">                 return 1;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        MyString s1(&quot;abcd-&quot;),s2,s3(&quot;efgh-&quot;),s4(s1);</div><div class="line">        MyString SArray[4] = &#123;&quot;big&quot;,&quot;me&quot;,&quot;about&quot;,&quot;take&quot;&#125;;</div><div class="line">        cout &lt;&lt; &quot;1. &quot; &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3&lt;&lt; s4&lt;&lt; endl;</div><div class="line">        s4 = s3;</div><div class="line">        s3 = s1 + s3;</div><div class="line">        cout &lt;&lt; &quot;2. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; &quot;3. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; &quot;4. &quot; &lt;&lt; s3 &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; &quot;5. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; &quot;6. &quot; &lt;&lt; s1[2] &lt;&lt; endl;</div><div class="line">        s2 = s1;</div><div class="line">        s1 = &quot;ijkl-&quot;;</div><div class="line">        s1[2] = &apos;A&apos; ;</div><div class="line">        cout &lt;&lt; &quot;7. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; &quot;8. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">        s1 += &quot;mnop&quot;;</div><div class="line">        cout &lt;&lt; &quot;9. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">        s4 = &quot;qrst-&quot; + s2;</div><div class="line">        cout &lt;&lt; &quot;10. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">        s1 = s2 + s4 + &quot; uvw &quot; + &quot;xyz&quot;;</div><div class="line">        cout &lt;&lt; &quot;11. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">        qsort(SArray,4,sizeof(MyString),CompareString);</div><div class="line">        for( int i = 0;i &lt; 4;i ++ )</div><div class="line">        cout &lt;&lt; SArray[i] &lt;&lt; endl;</div><div class="line">        //s1的从下标0开始长度为4的子串</div><div class="line">        cout &lt;&lt; s1(0,4) &lt;&lt; endl;</div><div class="line">        //s1的从下标5开始长度为10的子串</div><div class="line">        cout &lt;&lt; s1(5,10) &lt;&lt; endl;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输入</p>
<p>无</p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">1. abcd-efgh-abcd-</div><div class="line"></div><div class="line">2. abcd-</div><div class="line"></div><div class="line">3.</div><div class="line"></div><div class="line">4. abcd-efgh-</div><div class="line"></div><div class="line">5. efgh-</div><div class="line"></div><div class="line">6. c</div><div class="line"></div><div class="line">7. abcd-</div><div class="line"></div><div class="line">8. ijAl-</div><div class="line"></div><div class="line">9. ijAl-mnop</div><div class="line"></div><div class="line">10. qrst-abcd-</div><div class="line"></div><div class="line">11. abcd-qrst-abcd- uvw xyz</div><div class="line"></div><div class="line">about</div><div class="line"></div><div class="line">big</div><div class="line"></div><div class="line">me</div><div class="line"></div><div class="line">take</div><div class="line"></div><div class="line">abcd</div><div class="line"></div><div class="line">qrst-abcd-</div></pre></td></tr></table></figure></p>
<p>样例输入</p>
<p>无<br>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1. abcd-efgh-abcd-</div><div class="line">2. abcd-</div><div class="line">3.</div><div class="line">4. abcd-efgh-</div><div class="line">5. efgh-</div><div class="line">6. c</div><div class="line">7. abcd-</div><div class="line">8. ijAl-</div><div class="line">9. ijAl-mnop</div><div class="line">10. qrst-abcd-</div><div class="line">11. abcd-qrst-abcd- uvw xyz</div><div class="line">about</div><div class="line">big</div><div class="line">me</div><div class="line">take</div><div class="line">abcd</div><div class="line">qrst-abcd-</div></pre></td></tr></table></figure></p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>考察各种运算符重载，这题出的很全啊。</p>
<p>不过尼玛原来只是继承string就行了啊啊啊啊啊啊啊啊啊啊<br>害我完全自己写了MyString类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class MyString :public string &#123;</div><div class="line">public:</div><div class="line">	MyString() :string() &#123;&#125;;</div><div class="line">	MyString(const char *s) :string(s) &#123;&#125;;</div><div class="line">	MyString(const string &amp;s) :string(s) &#123;&#125;;</div><div class="line">	MyString operator()(int i, int j) &#123;</div><div class="line">		return this-&gt;substr(i, j);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">// 在此处补充你的代码</div><div class="line">//class MyString</div><div class="line">//&#123;</div><div class="line">//	string s;</div><div class="line">//public:</div><div class="line">//	MyString() &#123;&#125;</div><div class="line">//	MyString(string t) :s(t) &#123;&#125;</div><div class="line">//	MyString(const char* t)</div><div class="line">//	&#123;</div><div class="line">//		string st;</div><div class="line">//		for (int i = 0; t[i] != &apos;\0&apos;; i++)</div><div class="line">//			st += t[i];</div><div class="line">//		s = st;</div><div class="line">//	&#125;</div><div class="line">//	MyString(const MyString&amp; t)</div><div class="line">//	&#123;</div><div class="line">//		//cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;</div><div class="line">//		this-&gt;s = t.s;</div><div class="line">//	&#125;</div><div class="line">//	bool operator&lt;(MyString &amp;s2)</div><div class="line">//	&#123;</div><div class="line">//		return this-&gt;s &lt; s2.s;</div><div class="line">//	&#125;</div><div class="line">//	bool operator==(MyString &amp;s2)</div><div class="line">//	&#123;</div><div class="line">//		return this-&gt;s == s2.s;</div><div class="line">//	&#125;</div><div class="line">//	bool operator&gt;(MyString &amp;s2)</div><div class="line">//	&#123;</div><div class="line">//		return this-&gt;s &gt; s2.s;</div><div class="line">//	&#125;</div><div class="line">//	friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const MyString &amp;t);</div><div class="line">//	char &amp; operator[](int i)</div><div class="line">//	&#123;</div><div class="line">//		return this-&gt;s[i];</div><div class="line">//	&#125;</div><div class="line">//	MyString operator+(MyString const &amp;t)</div><div class="line">//	&#123;</div><div class="line">//		MyString p;</div><div class="line">//		p.s = this-&gt;s + t.s;</div><div class="line">//		return p;</div><div class="line">//	&#125;</div><div class="line">//	MyString operator=(string t)</div><div class="line">//	&#123;</div><div class="line">//		this-&gt;s = t;</div><div class="line">//		return *this;</div><div class="line">//	&#125;</div><div class="line">//	MyString operator=(char *t)</div><div class="line">//	&#123;</div><div class="line">//		string st;</div><div class="line">//		for (int i = 0; t[i] != &apos;\0&apos;; i++)</div><div class="line">//			st += t[i];</div><div class="line">//		this-&gt;s = st;</div><div class="line">//		return *this;</div><div class="line">//	&#125;</div><div class="line">//	char operator=(char t)</div><div class="line">//	&#123;</div><div class="line">//		return t;</div><div class="line">//	&#125;</div><div class="line">//	MyString&amp; operator+=(string t)</div><div class="line">//	&#123;</div><div class="line">//		this-&gt;s += t;</div><div class="line">//		return *this;</div><div class="line">//	&#125;</div><div class="line">//	friend MyString&amp; operator+(string t, MyString &amp;st);</div><div class="line">//	friend MyString&amp; operator+(char *t, MyString &amp;st);</div><div class="line">//	MyString&amp; operator+(string t)</div><div class="line">//	&#123;</div><div class="line">//		this-&gt;s += t;</div><div class="line">//		return *this;</div><div class="line">//	&#125;</div><div class="line">//	MyString&amp; operator+(char* t)</div><div class="line">//	&#123;</div><div class="line">//		string st;</div><div class="line">//		for (int i = 0; t[i] != &apos;\0&apos;; i++)</div><div class="line">//			st += t[i];</div><div class="line">//</div><div class="line">//		this-&gt;s += st;</div><div class="line">//		return *this;</div><div class="line">//	&#125;</div><div class="line">//	string operator()(int p, int len)</div><div class="line">//	&#123;</div><div class="line">//		return this-&gt;s.substr(p, len);</div><div class="line">//	&#125;</div><div class="line">//&#125;;</div><div class="line">//MyString&amp; operator+(string t,  MyString  &amp;st)</div><div class="line">//&#123;</div><div class="line">//	MyString p(t + st.s);</div><div class="line">//	return p;</div><div class="line">//&#125;</div><div class="line">//MyString&amp; operator+(char* t, MyString  &amp;st)</div><div class="line">//&#123;</div><div class="line">//	string stp;</div><div class="line">//	for (int i = 0; t[i] != &apos;\0&apos;; i++)</div><div class="line">//		stp += t[i];</div><div class="line">//	MyString p(t + st.s);</div><div class="line">//	return p;</div><div class="line">//&#125;</div><div class="line">//ostream &amp; operator&lt;&lt;(ostream &amp;os, const MyString &amp;t)</div><div class="line">//&#123;</div><div class="line">//	os &lt;&lt; t.s;</div><div class="line">//	return os;</div><div class="line">//&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int CompareString(const void * e1, const void * e2)</div><div class="line">&#123;</div><div class="line">	MyString * s1 = (MyString *)e1;</div><div class="line">	MyString * s2 = (MyString *)e2;</div><div class="line">	if (*s1 &lt; *s2)</div><div class="line">		return -1;</div><div class="line">	else if (*s1 == *s2)</div><div class="line">		return 0;</div><div class="line">	else if (*s1 &gt; *s2)</div><div class="line">		return 1;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	MyString s1(&quot;abcd-&quot;), s2, s3(&quot;efgh-&quot;), s4(s1);</div><div class="line">	MyString SArray[4] = &#123; &quot;big&quot;,&quot;me&quot;,&quot;about&quot;,&quot;take&quot; &#125;;</div><div class="line">	cout &lt;&lt; &quot;1. &quot; &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">	s4 = s3;</div><div class="line">	s3 = s1 + s3;</div><div class="line">	cout &lt;&lt; &quot;2. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">	cout &lt;&lt; &quot;3. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">	cout &lt;&lt; &quot;4. &quot; &lt;&lt; s3 &lt;&lt; endl;</div><div class="line">	cout &lt;&lt; &quot;5. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">	cout &lt;&lt; &quot;6. &quot; &lt;&lt; s1[2] &lt;&lt; endl;</div><div class="line">	s2 = s1;</div><div class="line">	s1 = &quot;ijkl-&quot;;</div><div class="line">	s1[2] = &apos;A&apos;;</div><div class="line">	cout &lt;&lt; &quot;7. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">	cout &lt;&lt; &quot;8. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">	s1 += &quot;mnop&quot;;</div><div class="line">	cout &lt;&lt; &quot;9. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">	s4 = &quot;qrst-&quot; + s2;</div><div class="line">	cout &lt;&lt; &quot;10. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">	s1 = s2 + s4 + &quot; uvw &quot; + &quot;xyz&quot;;</div><div class="line">	cout &lt;&lt; &quot;11. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">	qsort(SArray, 4, sizeof(MyString), CompareString);</div><div class="line">	for (int i = 0; i &lt; 4; i++)</div><div class="line">		cout &lt;&lt; SArray[i] &lt;&lt; endl;</div><div class="line">	//s1的从下标0开始长度为4的子串</div><div class="line">	cout &lt;&lt; s1(0, 4) &lt;&lt; endl;</div><div class="line">	//s1的从下标5开始长度为10的子串</div><div class="line">	cout &lt;&lt; s1(5, 10) &lt;&lt; endl;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃7：字符串排序"><a href="#编程题＃7：字符串排序" class="headerlink" title="编程题＃7：字符串排序"></a>编程题＃7：字符串排序</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>请按照要求对输入的字符串进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">private:</div><div class="line">        string name;</div><div class="line">public:</div><div class="line">        A(string n) :name(n)&#123;&#125;</div><div class="line">        friend bool operator &lt; (const class A&amp; a1, const class A &amp;a2);</div><div class="line">        friend bool operator == (const class A &amp;a1, const class A &amp;a2)&#123;</div><div class="line">                if (a1.name.size() == a2.name.size())</div><div class="line">                        return true;</div><div class="line">                else</div><div class="line">                        return false;</div><div class="line">        &#125;</div><div class="line">        friend ostream &amp; operator &lt;&lt; (ostream &amp;o, const A &amp;a)&#123;</div><div class="line">                o &lt;&lt; a.name;</div><div class="line">                return o;</div><div class="line">        &#125;</div><div class="line">        string get_name() const&#123;</div><div class="line">                return name;</div><div class="line">        &#125;</div><div class="line">        int get_size() const&#123;</div><div class="line">                return name.size();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">        list&lt;A&gt; lst;</div><div class="line">        int ncase, n, i = 1;</div><div class="line">        string s;</div><div class="line">        cin &gt;&gt; ncase;</div><div class="line">        while (ncase--)&#123;</div><div class="line">                cout &lt;&lt; &quot;Case: &quot;&lt;&lt;i++ &lt;&lt; endl;</div><div class="line">                cin &gt;&gt; n;</div><div class="line">                for (int i = 0; i &lt; n; i++)&#123;</div><div class="line">                         cin &gt;&gt; s;</div><div class="line">                         lst.push_back(A(s));</div><div class="line">                &#125;</div><div class="line">                lst.sort();</div><div class="line">                Show(lst.begin(), lst.end(), Print());</div><div class="line"></div><div class="line">                cout &lt;&lt; endl;</div><div class="line">                lst.sort(MyLarge&lt;A&gt;());</div><div class="line">                Show(lst.begin(), lst.end(), Print());</div><div class="line">                cout &lt;&lt; endl;</div><div class="line">                lst.clear();</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">第一行是正整数T，表示测试数据的组数</div><div class="line"></div><div class="line">每组测试数据输入共两行，</div><div class="line"></div><div class="line">第一行是正整数N，表示字符串个数</div><div class="line"></div><div class="line">第二行是N个字符串, 字符串间用空格分离</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">对于每组测试数据，先输出一行：</div><div class="line"></div><div class="line">Case: n</div><div class="line"></div><div class="line">如对第一组数据就输出Case: 1</div><div class="line"></div><div class="line">第二行按照字符串长度从小到大排序之后输出N个字符串，字符串之间以空格间隔（不会出现字符串长度相同的情况）</div><div class="line"></div><div class="line">第三行按照字符串首字符ASCII码序从小到大排序之后输出N个字符串，字符串之间以空格间隔（不会出现字符串首字母相同的情况）</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">2</div><div class="line">4</div><div class="line">a bnss ds tsdfasg</div><div class="line">5</div><div class="line">aaa bbbb ccccd sa q</div><div class="line">样例输出</div><div class="line"></div><div class="line">Case: 1</div><div class="line">a ds bnss tsdfasg</div><div class="line">a bnss ds tsdfasg</div><div class="line">Case: 2</div><div class="line">q sa aaa bbbb ccccd</div><div class="line">aaa bbbb ccccd q sa</div></pre></td></tr></table></figure>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><p>考察函数对象这一块。。。看样子是得回头好好看看了= =这题自己一点头绪没有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bool operator&lt; (const A&amp; a1, const A &amp;a2) &#123;</div><div class="line">	return a1.name.size() &lt; a2.name.size();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;class Iterator, class Function&gt;</div><div class="line">void Show(Iterator begin, Iterator end, Function print) &#123;</div><div class="line">	for (Iterator iterator1 = begin; iterator1 != end; iterator1++) &#123;</div><div class="line">		print(*iterator1);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Print &#123;</div><div class="line">public:</div><div class="line">	void operator()(const A &amp;a) &#123;</div><div class="line">		cout &lt;&lt; a.get_name() &lt;&lt; &quot; &quot;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;class A&gt;</div><div class="line">struct MyLarge &#123;</div><div class="line">	inline bool operator()(const A &amp;a1, const A &amp;a2) &#123;</div><div class="line">		return a1.get_name() &lt; a2.get_name();</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃8：计算整数k"><a href="#编程题＃8：计算整数k" class="headerlink" title="编程题＃8：计算整数k"></a>编程题＃8：计算整数k</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>输入整数 n ( 0 &lt;=n&lt;= 2^30) , 以及整数i,j(0 &lt;= i,j &lt;31,i &lt; j-1), 输出整数k(按十六进制输出结果 )，k的第i位和n相同，第j位和n不同，i,j之间的位是1, 其他位都是0。这里提到的所有的位，指的都是二进制位，最右边算第0位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">第一行是整数 t，表示数据组数。</div><div class="line"></div><div class="line">每组输入数据是一行，三个整数 n,i和j。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">对每组输入数据，按十六进制输出结果。</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">2</div><div class="line">23 3 5</div><div class="line">7 0 2</div><div class="line">样例输出</div><div class="line"></div><div class="line">30</div><div class="line">3</div></pre></td></tr></table></figure>
<p>提示</p>
<p>本题请写出完整的程序。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;bitset&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int kkk;</div><div class="line">	cin &gt;&gt; kkk;</div><div class="line">	while (kkk--) &#123;</div><div class="line">		int n, i, j;</div><div class="line">		cin &gt;&gt; n &gt;&gt; i &gt;&gt; j;</div><div class="line">		bitset&lt;50&gt; p;</div><div class="line">		bitset&lt;50&gt; t(n);</div><div class="line">		p[i] = t[i];</div><div class="line">		p[j] = !t[j];</div><div class="line">		for (int k = i + 1; k &lt; j; k++)</div><div class="line">			p[k] = 1;</div><div class="line">		//cout &lt;&lt; p &lt;&lt; endl;</div><div class="line">		int ans = p.to_ulong();</div><div class="line">		cout &lt;&lt; hex &lt;&lt; ans &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考察bitset,甚是好用呀。</p>
<h1 id="编程题＃9：人群的排序和分类"><a href="#编程题＃9：人群的排序和分类" class="headerlink" title="编程题＃9：人群的排序和分类"></a>编程题＃9：人群的排序和分类</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>对人群按照输入的信息进行排序和分类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"></div><div class="line">        int t;</div><div class="line">        cin &gt;&gt; t;</div><div class="line">        set&lt;A*,Comp&gt; ct;</div><div class="line">        while( t -- ) &#123;</div><div class="line">                int n;</div><div class="line">                cin &gt;&gt; n;</div><div class="line">                ct.clear();</div><div class="line">                for( int i = 0;i &lt; n; ++i)	&#123;</div><div class="line">                        char c; int k;</div><div class="line">                        cin &gt;&gt; c &gt;&gt; k;</div><div class="line"></div><div class="line">                        if( c == &apos;A&apos;)</div><div class="line">                                ct.insert(new A(k));</div><div class="line">                        else</div><div class="line">                                ct.insert(new B(k));</div><div class="line">                &#125;</div><div class="line">                for_each(ct.begin(),ct.end(),Print);</div><div class="line">                cout &lt;&lt; &quot;****&quot; &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">第一行是整数t,表明一共t组数据. t &lt; 20</div><div class="line"></div><div class="line">对每组数据：</div><div class="line"></div><div class="line">第一行是整数n,表示下面一共有n行。 0 &lt; n &lt; 100</div><div class="line"></div><div class="line">下面的每行代表一个人。每行以一个字母开头，代表该人所属的类别，然后跟着一个整数，代表年龄。字母只会是 &apos;A‘或‘B&apos; 。整数范围0到100。数据保证年龄都不相同。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">对每组输入数据，将这些人按年龄从小到大输出。每个人先输出类别，再输出年龄。每组数据的末尾加一行 &quot;****&quot;</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">2</div><div class="line">4</div><div class="line">A 3</div><div class="line">B 4</div><div class="line">A 5</div><div class="line">B 6</div><div class="line">3</div><div class="line">A 4</div><div class="line">A 3</div><div class="line">A 2</div><div class="line">样例输出</div><div class="line"></div><div class="line">A 3</div><div class="line">B 4</div><div class="line">A 5</div><div class="line">B 6</div><div class="line">****</div><div class="line">A 2</div><div class="line">A 3</div><div class="line">A 4</div><div class="line">****</div></pre></td></tr></table></figure>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><p>B是A的子类。。。一开始没有想到这一点。comp是比较函数。。。。纳闷半天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">public:</div><div class="line">	int age;</div><div class="line">	string s;</div><div class="line">	A(int a) :age(a), s(&quot;A&quot;) &#123;&#125;</div><div class="line">	A(int a, string str) :age(a), s(str) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B :public A &#123;</div><div class="line">public:</div><div class="line">	B(int b) :A(b, &quot;B&quot;) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Comp &#123;</div><div class="line">	bool operator()(const A* a1, const A* a2) const &#123;</div><div class="line">		return a1-&gt;age &lt; a2-&gt;age;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void Print(const A *a) &#123;</div><div class="line">	string t = a-&gt;s;</div><div class="line">	cout &lt;&lt; t.c_str() &lt;&lt; &quot; &quot; &lt;&lt; a-&gt;age &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃10：输出指定结果二"><a href="#编程题＃10：输出指定结果二" class="headerlink" title="编程题＃10：输出指定结果二"></a>编程题＃10：输出指定结果二</h1><p>来源: 北京大学在线程序评测系统POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>总时间限制: 1000ms 内存限制: 1024kB</p>
<p>描述</p>
<p>通过填空使得程序输出的结果符合下面的要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int A::count = 0;</div><div class="line">void func(B b) &#123; &#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        A a1(5),a2;</div><div class="line">        cout &lt;&lt; A::count &lt;&lt; endl;</div><div class="line">        B b1(4);</div><div class="line">        cout &lt;&lt; A::count &lt;&lt; endl;</div><div class="line">        func(b1);</div><div class="line">        cout &lt;&lt; A::count &lt;&lt; endl;</div><div class="line">        A * pa = new B(4);</div><div class="line">        cout &lt;&lt; A::count &lt;&lt; endl;</div><div class="line">        delete pa;</div><div class="line">        cout &lt;&lt; A::count &lt;&lt; endl;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">使得程序的输出结果是：</div><div class="line"></div><div class="line">2</div><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">B::destructor</div><div class="line"></div><div class="line">A::destructor</div><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">4</div><div class="line"></div><div class="line">B::destructor</div><div class="line"></div><div class="line">A::destructor</div><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">B::destructor</div><div class="line"></div><div class="line">A::destructor</div><div class="line"></div><div class="line">A::destructor</div><div class="line"></div><div class="line">A::destructor</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">不需要输入。</div><div class="line">样例输出</div><div class="line"></div><div class="line">2</div><div class="line">3</div><div class="line">B::destructor</div><div class="line">A::destructor</div><div class="line">3</div><div class="line">4</div><div class="line">B::destructor</div><div class="line">A::destructor</div><div class="line">3</div><div class="line">B::destructor</div><div class="line">A::destructor</div><div class="line">A::destructor</div><div class="line">A::destructor</div></pre></td></tr></table></figure>
<p>提示</p>
<p>int A::count = 0; 这个变量是用来记录一共有多少个类A及类A的派生类的对象的。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><p>考察虚函数。哎，有时间再回头仔细复习下c++。虚函数学过去就忘啊。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class A &#123;</div><div class="line">public:</div><div class="line">	static int count;</div><div class="line">	</div><div class="line">	A()&#123; A::count++; &#125;</div><div class="line">	A(int t)&#123;</div><div class="line">		A::count++;</div><div class="line">	&#125;</div><div class="line">	virtual ~A()</div><div class="line">	&#123;</div><div class="line">		A::count--;</div><div class="line">		cout &lt;&lt; &quot;A::destructor&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">class B :public A &#123;</div><div class="line">public:</div><div class="line">	B():A()&#123;&#125;</div><div class="line">	B(int t):A(t)&#123;&#125;</div><div class="line">	B(const B &amp;t):A()&#123;&#125;</div><div class="line">	virtual ~B() &#123;</div><div class="line">		cout &lt;&lt; &quot;B::destructor&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃11：数据库内的学生信息"><a href="#编程题＃11：数据库内的学生信息" class="headerlink" title="编程题＃11：数据库内的学生信息"></a>编程题＃11：数据库内的学生信息</h1><p>描述</p>
<p>程序填空，使得下面的程序,先输出</p>
<p>(Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100),</p>
<p>(Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100),</p>
<p>(70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice),</p>
<p>(70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice),</p>
<hr>
<p>然后，再根据输入数据按要求产生输出数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">struct Student</div><div class="line">&#123;</div><div class="line">        string name;</div><div class="line">        int score;</div><div class="line">&#125;;</div><div class="line">template &lt;class T&gt;</div><div class="line">void Print(T first,T last) &#123;</div><div class="line">        for(;first!= last; ++ first)</div><div class="line">                cout &lt;&lt; * first &lt;&lt; &quot;,&quot;;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"></div><div class="line">        Student s[] = &#123; &#123;&quot;Tom&quot;,80&#125;,&#123;&quot;Jack&quot;,70&#125;,</div><div class="line">                                        &#123;&quot;Jone&quot;,90&#125;,&#123;&quot;Tom&quot;,70&#125;,&#123;&quot;Alice&quot;,100&#125; &#125;;</div><div class="line">        MyMultimap&lt;string,int&gt; mp;</div><div class="line">        for(int i = 0; i&lt;5; ++ i)</div><div class="line">                mp.insert(make_pair(s[i].name,s[i].score));</div><div class="line">        Print(mp.begin(),mp.end()); //按姓名从大到小输出</div><div class="line"></div><div class="line">        mp.Set(&quot;Tom&quot;,78); //把所有名为&quot;Tom&quot;的学生的成绩都设置为78</div><div class="line">        Print(mp.begin(),mp.end());</div><div class="line"></div><div class="line"></div><div class="line">        MyMultimap&lt;int,string,less&lt;int&gt; &gt; mp2;</div><div class="line">        for(int i = 0; i&lt;5; ++ i)</div><div class="line">                mp2.insert(make_pair(s[i].score,s[i].name));</div><div class="line"></div><div class="line">        Print(mp2.begin(),mp2.end()); //按成绩从小到大输出</div><div class="line">        mp2.Set(70,&quot;Error&quot;);          //把所有成绩为70的学生，名字都改为&quot;Error&quot;</div><div class="line">        Print(mp2.begin(),mp2.end());</div><div class="line">        cout &lt;&lt; &quot;******&quot; &lt;&lt; endl;</div><div class="line"></div><div class="line">        mp.clear();</div><div class="line">        </div><div class="line">        string name;</div><div class="line">        string cmd;</div><div class="line">        int score;</div><div class="line">        while(cin &gt;&gt; cmd ) &#123;</div><div class="line">                if( cmd == &quot;A&quot;) &#123;</div><div class="line">                        cin &gt;&gt; name &gt;&gt; score;</div><div class="line">                        if(mp.find(name) != mp.end() ) &#123;</div><div class="line">                                cout &lt;&lt; &quot;erroe&quot; &lt;&lt; endl;</div><div class="line">                        &#125;</div><div class="line">                        mp.insert(make_pair(name,score));</div><div class="line">                &#125;</div><div class="line">                else if(cmd == &quot;Q&quot;) &#123;</div><div class="line">                        cin &gt;&gt; name;</div><div class="line">                        MyMultimap&lt;string,int&gt;::iterator p = mp.find(name);</div><div class="line">                        if( p!= mp.end()) &#123;</div><div class="line">                                cout &lt;&lt; p-&gt;second &lt;&lt; endl;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                                cout &lt;&lt; &quot;Not Found&quot; &lt;&lt; endl;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">输入</div><div class="line"></div><div class="line">输入数据的每一行，格式为以下之一：</div><div class="line"></div><div class="line">A name score</div><div class="line"></div><div class="line">Q name score</div><div class="line"></div><div class="line">name是个不带个空格的字符串，长度小于 20</div><div class="line"></div><div class="line">score是个整数，能用int表示</div><div class="line"></div><div class="line">A name score 表示往数据库中新增一个姓名为name的学生，其分数为score。开始时数据库中一个学生也没有。</div><div class="line"></div><div class="line">Q name 表示在数据库中查询姓名为name的学生的分数</div><div class="line"></div><div class="line">数据保证学生不重名。</div><div class="line"></div><div class="line">输入数据少于200,000行。</div><div class="line"></div><div class="line">输出</div><div class="line"></div><div class="line">对于每个查询，输出学生的分数。如果查不到，则输出 &quot;Not Found&quot;</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">A Tom1 30</div><div class="line">A Tom2 40</div><div class="line">Q Tom3</div><div class="line">A Tom4 89</div><div class="line">Q Tom1</div><div class="line">Q Tom2</div><div class="line">样例输出</div><div class="line"></div><div class="line">(Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100),</div><div class="line">(Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100),</div><div class="line">(70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice),</div><div class="line">(70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice),</div><div class="line">******</div><div class="line">Not Found</div><div class="line">30</div><div class="line">40</div></pre></td></tr></table></figure>
<p>提示</p>
<p>1) 编写模板的时候，连续的两个 “&gt;”最好要用空格分开，以免被编译器看作是 “&gt;&gt;”运算符。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。</p>
<p>比如 vector<vector<int>&gt; 有可能出错，要改成 vector<vector<int> &gt;</vector<int></vector<int></p>
<p>2) 在模板中写迭代器时，最好在前面加上 typename关键字，否则可能会编译错。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><p>居然让实现一个Multimap。。。。<br>此题不会，日后再做。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_STL2作业]]></title>
      <url>http://blog.acbingo.cn/2016/01/24/coursera_STL2%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<p>stl2的作业<br><a id="more"></a></p>
<h1 id="编程题＃1"><a href="#编程题＃1" class="headerlink" title="编程题＃1"></a>编程题＃1</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>下面的程序用枚举法解决如下问题，请填空。</p>
<p>平面上的一个矩形，如果其边平行于坐标轴，我们就称其为“标准矩形”。给定不重复的 n 个整点（横、纵坐标都是整数的点），求从这n个点中任取4点作为顶点所构成的四边形中，有多少个是标准矩形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">struct Point &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    Point(int x_,int y_):x(x_),y(y_) &#123; &#125;</div><div class="line">&#125;;</div><div class="line">bool operator &lt; ( const Point &amp; p1, const Point &amp; p2)</div><div class="line">&#123;</div><div class="line">    if( p1.y &lt; p2.y )</div><div class="line">        return true;</div><div class="line">    else if( p1.y == p2.y )</div><div class="line">        return p1.x &lt; p2.x;</div><div class="line">    else</div><div class="line">        return false;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int t;</div><div class="line">    int x,y;</div><div class="line">    cin &gt;&gt; t;</div><div class="line">    vector&lt;Point&gt; v;</div><div class="line">    while( t -- ) &#123;</div><div class="line">        cin &gt;&gt; x &gt;&gt; y;</div><div class="line">        v.push_back(Point(x,y));</div><div class="line">    &#125;</div><div class="line">    vector&lt;Point&gt;::iterator i,j;</div><div class="line">    int nTotalNum = 0;</div><div class="line">// 在此处补充你的代码</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输入</p>
<p>第一行是点的数目</p>
<p>其后每一行都代表一个点，由两个整数表示，第一个是x坐标，第二个是y坐标</p>
<p>输出</p>
<p>输出标准矩形的数目</p>
<p>样例输入</p>
<p>6<br>2 3<br>2 5<br>4 5<br>4 4<br>2 4<br>4 3<br>样例输出</p>
<p>3<br>提示</p>
<p>所缺代码具有如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_____________________;</div><div class="line">for( i = v.begin(); i &lt; v.end() - 1;i ++ )</div><div class="line">    for(_____________; ______________; _____________) &#123;</div><div class="line">        if(binary_search(v.begin(),v.end(),Point( j-&gt;x, i-&gt;y)) &amp;&amp;</div><div class="line">            ____________________________________________ &amp;&amp;</div><div class="line">            ____________________________________________ &amp;&amp;</div><div class="line">            ____________________________________________ )</div><div class="line">            nTotalNum ++;</div><div class="line">    &#125;</div><div class="line">cout &lt;&lt; _________________;</div></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路：<br>其实，点的关系只要满足存在这四个点就可以了(x1,y1)(x2,y2)(x1,y2)(x2,y1)。注意x1!=x2,x2!=x1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sort(v.begin(), v.end());</div><div class="line">	for (i = v.begin(); i &lt; v.end() - 1; i++)</div><div class="line">		for (j = i+1; j &lt; v.end(); j++)</div><div class="line">		&#123;</div><div class="line">			if (binary_search(v.begin(), v.end(), Point(j-&gt;x, i-&gt;y)) &amp;&amp;</div><div class="line">				binary_search(v.begin(), v.end(), Point(i-&gt;x, j-&gt;y)) &amp;&amp;</div><div class="line">				(i-&gt;x!=j-&gt;x) &amp;&amp;</div><div class="line">				(i-&gt;y!=j-&gt;y))</div><div class="line">					nTotalNum++;</div><div class="line">		&#125;</div><div class="line">	cout &lt;&lt; nTotalNum/2 &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2"><a href="#编程题＃2" class="headerlink" title="编程题＃2"></a>编程题＃2</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>写一个自己的 CMyistream_iterator 模板，使之能和 istream_iterator 模板达到一样的效果，即：</p>
<p>输入：</p>
<p>79 90 20 hello me</p>
<p>输出：</p>
<p>79</p>
<p>79,90,20</p>
<p>hello,me<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    CMyistream_iterator&lt;int&gt; inputInt(cin);</div><div class="line">    int n1,n2,n3;</div><div class="line">    n1 = * inputInt; //读入 n1</div><div class="line">    int tmp = * inputInt;</div><div class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</div><div class="line">    inputInt ++;</div><div class="line">    n2 = * inputInt; //读入 n2</div><div class="line">    inputInt ++;</div><div class="line">    n3 = * inputInt; //读入 n3</div><div class="line">    cout &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2&lt;&lt; &quot;,&quot; &lt;&lt; n3 &lt;&lt; endl;</div><div class="line">    CMyistream_iterator&lt;string&gt; inputStr(cin);</div><div class="line">    string s1,s2;</div><div class="line">    s1 = * inputStr;</div><div class="line">    inputStr ++;</div><div class="line">    s2 = * inputStr;</div><div class="line">    cout &lt;&lt; s1 &lt;&lt; &quot;,&quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输入</p>
<p>79 90 20 hello me</p>
<p>输出</p>
<p>79</p>
<p>79,90,20</p>
<p>hello,me</p>
<p>样例输入</p>
<p>79 90 20 hello me<br>样例输出</p>
<p>79<br>79,90,20<br>hello,me<br>提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">istream_iterator模版使用说明：</div><div class="line"></div><div class="line">其构造函数执行过程中就会要求输入，然后每次执行++，则读取输入流中的下一个项目，执行 * 则返回上次从输入流中读取的项目。例如，下面程序运行时，就会等待用户输入数据，输入数据后程序才会结束：</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">using namespace std;</div><div class="line">int main() &#123;</div><div class="line">        istream_iterator&lt;int&gt; inputInt(cin);</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line">下面程序运行时，如果输入 12 34 程序输出结果是： 12,12</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        istream_iterator&lt;int&gt; inputInt(cin);</div><div class="line">        cout &lt;&lt; * inputInt &lt;&lt; &quot;,&quot; &lt;&lt; * inputInt &lt;&lt; endl;</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line">下面程序运行时，如果输入 12 34 56程序输出结果是： 12,56</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        istream_iterator&lt;int&gt; inputInt(cin);</div><div class="line">        cout &lt;&lt; * inputInt &lt;&lt; &quot;,&quot; ;</div><div class="line">        inputInt ++;</div><div class="line">        inputInt ++;</div><div class="line">        cout &lt;&lt; * inputInt;</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>没啥可说的。仔细听课了就会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class CMyistream_iterator</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	CMyistream_iterator(istream &amp;input) :in(input) &#123;</div><div class="line">		in &gt;&gt; a;</div><div class="line">	&#125;</div><div class="line">	T operator *() &#123;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">	void operator ++(int) &#123;</div><div class="line">		in &gt;&gt; a;</div><div class="line">	&#125;</div><div class="line">private:</div><div class="line">	T a;</div><div class="line">	istream &amp; in;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃3：Set"><a href="#编程题＃3：Set" class="headerlink" title="编程题＃3：Set"></a>编程题＃3：Set</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 5000ms 内存限制: 100000kB</p>
<p>描述</p>
<p>现有一整数集（允许有重复元素），初始为空。我们定义如下操作：</p>
<p>add x 把x加入集合</p>
<p>del x 把集合中所有与x相等的元素删除</p>
<p>ask x 对集合中元素x的情况询问</p>
<p>对每种操作，我们要求进行如下输出。</p>
<p>add 输出操作后集合中x的个数</p>
<p>del 输出操作前集合中x的个数</p>
<p>ask 先输出0或1表示x是否曾被加入集合（0表示不曾加入），再输出当前集合中x的个数，中间用空格格开。</p>
<p>输入</p>
<p>第一行是一个整数n，表示命令数。0&lt;=n&lt;=100000。</p>
<p>后面n行命令，如Description中所述。</p>
<p>输出</p>
<p>共n行，每行按要求输出。</p>
<p>样例输入</p>
<p>7<br>add 1<br>add 1<br>ask 1<br>ask 2<br>del 2<br>del 1<br>ask 1<br>样例输出</p>
<p>1<br>2<br>1 2<br>0 0<br>0<br>2<br>1 0<br>提示</p>
<p>Please use STL’s set and multiset to finish the task</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	multiset&lt;int&gt; mset;</div><div class="line">	set&lt;int&gt; mm;</div><div class="line">	char commend[5];</div><div class="line">	int i, n, num;</div><div class="line">	cin &gt;&gt; n;</div><div class="line">	for (i = 0; i&lt;n; i++)</div><div class="line">	&#123;</div><div class="line">		cin &gt;&gt; commend &gt;&gt; num;</div><div class="line">		switch (commend[1])</div><div class="line">		&#123;</div><div class="line">		case &apos;d&apos;:</div><div class="line">			mset.insert(num);</div><div class="line">			mm.insert(num);</div><div class="line">			cout &lt;&lt; mset.count(num) &lt;&lt; endl;</div><div class="line">			break;</div><div class="line">		case &apos;e&apos;:</div><div class="line">			cout &lt;&lt; mset.count(num) &lt;&lt; endl;</div><div class="line">			mset.erase(num);</div><div class="line">			break;</div><div class="line">		case &apos;s&apos;:</div><div class="line">			if (mm.find(num) == mm.end())</div><div class="line">				cout &lt;&lt; &quot;0 0&quot; &lt;&lt; endl;</div><div class="line">			else</div><div class="line">			&#123;</div><div class="line">				cout &lt;&lt; &quot;1 &quot;;</div><div class="line">				cout &lt;&lt; mset.count(num) &lt;&lt; endl;</div><div class="line">			&#125;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃4：-字符串操作"><a href="#编程题＃4：-字符串操作" class="headerlink" title="编程题＃4： 字符串操作"></a>编程题＃4： 字符串操作</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>给定n个字符串（从1开始编号），每个字符串中的字符位置从0开始编号，长度为1-500，现有如下若干操作：</p>
<p>copy N X L：取出第N个字符串第X个字符开始的长度为L的字符串。</p>
<p>add S1 S2：判断S1，S2是否为0-99999之间的整数，若是则将其转化为整数做加法，若不是，则作字符串加法，返回的值为一字符串。</p>
<p>find S N：在第N个字符串中从左开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。</p>
<p>rfind S N：在第N个字符串中从右开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。</p>
<p>insert S N X：在第N个字符串的第X个字符位置中插入S字符串。</p>
<p>reset S N：将第N个字符串变为S。</p>
<p>print N：打印输出第N个字符串。</p>
<p>printall：打印输出所有字符串。</p>
<p>over：结束操作。</p>
<p>其中N，X，L可由find与rfind操作表达式构成，S，S1，S2可由copy与add操作表达式构成。</p>
<p>输入</p>
<p>第一行为一个整数n（n在1-20之间）</p>
<p>接下来n行为n个字符串，字符串不包含空格及操作命令等。</p>
<p>接下来若干行为一系列操作，直到over结束。</p>
<p>输出</p>
<p>根据操作提示输出对应字符串。</p>
<p>样例输入</p>
<p>3<br>329strjvc<br>Opadfk48<br>Ifjoqwoqejr<br>insert copy 1 find 2 1 2 2 2<br>print 2<br>reset add copy 1 find 3 1 3 copy 2 find 2 2 2 3<br>print 3<br>insert a 3 2<br>printall<br>over<br>样例输出</p>
<p>Op29adfk48<br>358<br>329strjvc<br>Op29adfk48<br>35a8<br>提示</p>
<p>推荐使用string类中的相关操作函数。</p>
<h1 id="编程题＃5：-热血格斗场"><a href="#编程题＃5：-热血格斗场" class="headerlink" title="编程题＃5： 热血格斗场"></a>编程题＃5： 热血格斗场</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家热血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。</p>
<p>我们假设格斗的实力可以用一个正整数表示，成为实力值。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有两个人的实力值与他差别相同，则他会选择比他弱的那个（显然，虐人必被虐好）。</p>
<p>不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。</p>
<p>输入</p>
<p>第一行一个数n(0 &lt; n &lt;=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。输入保证两人的实力值不同。</p>
<p>输出</p>
<p>N行，每行两个数，为每场比赛双方的id，新手的id写在前面。</p>
<p>样例输入</p>
<p>3<br>2 1<br>3 3<br>4 2<br>样例输出</p>
<p>2 1<br>3 2<br>4 2</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>用map或set存，考察lower_bound这破玩意的使用。<br>注意在poj上用cin、cout太慢了会超时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#define _CRT_SECURE_NO_WARNINGS</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long int LL;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	map&lt;LL,LL&gt; mp;</div><div class="line">	int n;</div><div class="line">	cin &gt;&gt; n;</div><div class="line">	mp.insert(make_pair(1000000000,1));</div><div class="line">	while (n--)</div><div class="line">	&#123;</div><div class="line">		LL a, b;</div><div class="line">		scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);</div><div class="line">		mp.insert(make_pair(b, a));</div><div class="line">		LL t;</div><div class="line">		map&lt;LL, LL&gt;::iterator it;</div><div class="line">		map&lt;LL, LL&gt;::iterator it2;</div><div class="line">		it = mp.lower_bound(b);</div><div class="line">		it2 = mp.upper_bound(b);</div><div class="line">		if (it==mp.begin()) </div><div class="line">		&#123;</div><div class="line">			t = it2-&gt;second;</div><div class="line">		&#125;</div><div class="line">		else if (it == mp.end())</div><div class="line">		&#123;</div><div class="line">			t = it-&gt;second;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			it--;</div><div class="line">			LL t1, t2;</div><div class="line">			t1 = abs(it-&gt;first - b);</div><div class="line">			t2 = abs(it2-&gt;first - b);</div><div class="line">			if (t1 &gt; t2) t = it2-&gt;second;</div><div class="line">			else t = it-&gt;second;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%lld %lld\n&quot;, a, t);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃6：-priority-queue练习题"><a href="#编程题＃6：-priority-queue练习题" class="headerlink" title="编程题＃6： priority queue练习题"></a>编程题＃6： priority queue练习题</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 2500ms 内存限制: 131072kB</p>
<p>描述</p>
<p>我们定义一个正整数a比正整数b优先的含义是：</p>
<p>*a的质因数数目（不包括自身）比b的质因数数目多；</p>
<p>*当两者质因数数目相等时，数值较大者优先级高。</p>
<p>现在给定一个容器，初始元素数目为0，之后每次往里面添加10个元素，每次添加之后，要求输出优先级最高与最低的元素，并把该两元素从容器中删除。</p>
<p>输入</p>
<p>第一行: num (添加元素次数，num &lt;= 30)</p>
<p>下面10*num行，每行一个正整数n（n &lt; 10000000).</p>
<p>输出</p>
<p>每次输入10个整数后，输出容器中优先级最高与最低的元素，两者用空格间隔。</p>
<p>样例输入</p>
<p>1<br>10 7 66 4 5 30 91 100 8 9<br>样例输出</p>
<p>66 5</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>都1点了，实在困的不想做了。<br>优先队列只允许删除队首的元素，所以我们用两个优先队列来处理就行了。按老师教的写好myless以及mygreater比较器。（只重载&lt;号的话，两种优先级就得分别想办法处理了。。可能会比较麻烦吧，大家有别的好主意不妨给出）<br>其它没啥好说的。<br>给出的代码是网上搞来的，出处不可考。感觉写得超级棒，居然用了bitset这种神奇的东西。<br>这绝对是本题的标准答案啊，优美极了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;bitset&gt;</div><div class="line">using namespace std;</div><div class="line">bitset&lt;3200&gt; tab;</div><div class="line">int getNum(int k) &#123;</div><div class="line">	int num = 0;</div><div class="line">	for (int j = 2; j &lt; 3200 &amp;&amp; j &lt; k; j++) &#123;</div><div class="line">		if (tab[j] == 0 &amp;&amp; k % j == 0) &#123;</div><div class="line">			while (k % j == 0)</div><div class="line">				k /= j;</div><div class="line">			num++;</div><div class="line">			if (k == 1) break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if (k == 1)</div><div class="line">		return num;</div><div class="line">	else if (num == 0)</div><div class="line">		return 0;</div><div class="line">	else</div><div class="line">		return num + 1;</div><div class="line">&#125;</div><div class="line">class MyLess &#123;</div><div class="line">public:</div><div class="line">	bool operator() (pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123;</div><div class="line">		int num1 = a.first, num2 = a.first;</div><div class="line">		if (num1 &lt; num2)</div><div class="line">			return true;</div><div class="line">		else if (num1 == num2)</div><div class="line">			return a &lt; b;</div><div class="line">		else</div><div class="line">			return false;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class MyGreater &#123;</div><div class="line">public:</div><div class="line">	bool operator() (pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123;</div><div class="line">		int num1 = a.first, num2 = a.first;</div><div class="line">		if (num1 &gt; num2)</div><div class="line">			return true;</div><div class="line">		else if (num1 == num2)</div><div class="line">			return a &gt; b;</div><div class="line">		else</div><div class="line">			return false;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">	for (int i = 0; i &lt; 3200; i++)</div><div class="line">		tab[i] = 0;</div><div class="line">	tab[0] = tab[1] = 1;</div><div class="line">	for (int i = 2; i &lt; 3200; i++) &#123;</div><div class="line">		if (!tab[i])</div><div class="line">			for (int j = i + i; j &lt; 3200; j += i)</div><div class="line">				tab[j] = 1;</div><div class="line">	&#125;</div><div class="line">	int num = 0;</div><div class="line">	priority_queue&lt;int, vector&lt;pair&lt;int, int&gt; &gt;, MyLess&gt; pq1;</div><div class="line">	priority_queue&lt;int, vector&lt;pair&lt;int, int&gt; &gt;, MyGreater&gt; pq2;</div><div class="line">	cin &gt;&gt; num;</div><div class="line">	while (num--) &#123;</div><div class="line">		int tmp = 0;</div><div class="line">		for (int t = 0; t &lt; 10; t++) &#123;</div><div class="line">			cin &gt;&gt; tmp;</div><div class="line">			pq1.push(make_pair(getNum(tmp), tmp));</div><div class="line">			pq2.push(make_pair(getNum(tmp), tmp));</div><div class="line">		&#125;</div><div class="line">		cout &lt;&lt; pq1.top().second &lt;&lt; &quot; &quot; &lt;&lt; pq2.top().second &lt;&lt; endl;</div><div class="line">		pq1.pop();</div><div class="line">		pq2.pop();</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera容器适配器_算法]]></title>
      <url>http://blog.acbingo.cn/2016/01/21/coursera%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>除了常用的容器之外的，容器适配器.<br>算法<br><a id="more"></a><br>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊<br>做了两天的笔记，居然没保存啊啊啊啊啊啊啊啊啊啊啊啊啊啊<br>我去你的vsc</p>
<p>哎。。。不想再写了。。。</p>
<p>直接贴pdf</p>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p><a href="https://d396qusza40orc.cloudfront.net/pkupop/lectures/Week9/W9-03_%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.pdf" target="_blank" rel="external">容器适配器</a></p>
<h1 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h1><p><a href="https://d396qusza40orc.cloudfront.net/pkupop/lectures/Week9/W9-04_%E7%AE%97%E6%B3%95.pdf" target="_blank" rel="external">算法1</a><br><a href="https://d396qusza40orc.cloudfront.net/pkupop/lectures/Week9/W9-05_%E7%AE%97%E6%B3%95.pdf" target="_blank" rel="external">算法2</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera标准模版库STL2]]></title>
      <url>http://blog.acbingo.cn/2016/01/21/coursera%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93STL2/</url>
      <content type="html"><![CDATA[<p>STL的第二节<br><a id="more"></a></p>
<h1 id="set和multiset，关联容器"><a href="#set和multiset，关联容器" class="headerlink" title="set和multiset，关联容器"></a>set和multiset，关联容器</h1><p>关联容器，内部是排好序的。<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f071195roqj30qt0ejgox.jpg" alt=""></p>
<h2 id="预备知识，pair模板"><a href="#预备知识，pair模板" class="headerlink" title="预备知识，pair模板"></a>预备知识，pair模板</h2><p>这里用struct来构造，和class的区别是成员直接是public了，其他一样。<br>注意第三个模板<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f071321op7j30re0eqtbz.jpg" alt=""><br>map和multimap都是用pair来构造的，并且是按first排序的</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>这里给出了multiset排序的默认规则。。。嗯。。用一个less模板，less的默认定义呢是用&lt;来比较大小的。。巴拉巴拉<br>总之，我们需要自定义排序规则的时候，重载&lt;就行了<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f071cx9ox6j30qw0f577s.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f071grb8jgj30qo0eytcz.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f071sfqiukj30r60exacq.jpg" alt=""></p>
<h3 id="multiset用法"><a href="#multiset用法" class="headerlink" title="multiset用法"></a>multiset用法</h3><p>这里会出错。为啥错？<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f071ux3kbvj30qx0eswgx.jpg" alt=""><br>因为编译器会实例化一个less&lt;A&gt;，然后less会用到&lt;，然而你这个&lt;又没有定义。。。<br>所有，需要重载下&lt;</p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f071wo4ej9j30qt0exmxr.jpg" alt=""><br>这里需要重载&gt;</p>
<p>实例：<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f071y3nskoj30qy0f0acj.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0737nqvlhj30qw0eljuq.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f073krikm4j30qo0f0gpz.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f073p5h5o3j30qr0ewdgi.jpg" alt=""></p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set里面不能有重复元素。<br>什么叫重复呢，满足，a&lt;b并且b&lt;a不成立,便认为a、b是重复的<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f073tcpqcaj30qd0ettai.jpg" alt=""></p>
<h2 id="set用法"><a href="#set用法" class="headerlink" title="set用法"></a>set用法</h2><p>若set中已存在该元素，是插入不成功的<br>如何检测你插入成功了吗？<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f073tkpwcyj30qu0f20wm.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f073yrhw5nj30qm0ez0tf.jpg" alt=""></p>
<h1 id="Map和Multimap"><a href="#Map和Multimap" class="headerlink" title="Map和Multimap"></a>Map和Multimap</h1><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f077n50t44j30r80f3dj3.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f077ov3cvmj30qh0evjug.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f077spmvpsj30qm0ex75b.jpg" alt=""><br>按first的&lt;规则进行排序</p>
<h2 id="multimap例题"><a href="#multimap例题" class="headerlink" title="multimap例题"></a>multimap例题</h2><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f077ummtzuj30qo0fbq6z.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f077zph8x1j30qu0f476e.jpg" alt=""><br>在c++里面，类的内部还可以定义新的类。<br>注意内部类的使用方法。前面要注明外部类的命名空间。<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0786woe6mj30qs0ettbh.jpg" alt=""><br>mp.insert()要插入一个pair模板类的对象。如何生存一个临时的pair模板类的对象呢。如图所示。<br>为multimap的value_type生成.<br>这样写也可以<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f078umouiuj30qs02jq3g.jpg" alt=""></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f078vfpzuvj30qp0eatb1.jpg" alt=""><br>map有[]成员函数<br>而multimap没有<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f078vz1ehrj30qr0eq0ui.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f078x9p8ahj30qk06q756.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f078ylllzvj30am011jra.jpg" alt=""><br>这句话的意思是：定义一个map容器，first值是int，second值double，（按first来的）顺序关系规则是less&lt;int&gt;</p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f0792hyj16j30qr0epdgf.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera编程作业-STL1]]></title>
      <url>http://blog.acbingo.cn/2016/01/20/coursera%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A-STL1/</url>
      <content type="html"><![CDATA[<p>stl1课后给的两个题，有点难度。<br>要求对stl相当熟悉才行呀。<br><a id="more"></a></p>
<h1 id="编程题＃1"><a href="#编程题＃1" class="headerlink" title="编程题＃1"></a>编程题＃1</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>下面的程序输出结果是:</p>
<p>1 2 6 7 8 9</p>
<p>请填空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt; </div><div class="line">#include &lt;iterator&gt; </div><div class="line">#include &lt;set&gt; </div><div class="line">using namespace std;</div><div class="line">int main() &#123; </div><div class="line">    int a[] = &#123;8,7,8,9,6,2,1&#125;; </div><div class="line">// 在此处补充你的代码</div><div class="line">    ostream_iterator&lt;int&gt; o(cout,&quot; &quot;);</div><div class="line">    copy( v.begin(),v.end(),o); </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>无</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>1 2 6 7 8 9</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>无</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>1 2 6 7 8 9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">using namespace std;</div><div class="line">int main() &#123;</div><div class="line">    int a[] = &#123; 8,7,8,9,6,2,1 &#125;;</div><div class="line">    set&lt;int&gt; v(a, a + 7);</div><div class="line">    ostream_iterator&lt;int&gt; o(cout, &quot; &quot;);</div><div class="line">    copy(v.begin(), v.end(), o);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃1-List"><a href="#编程题＃1-List" class="headerlink" title="编程题＃1 List"></a>编程题＃1 List</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 4000ms 内存限制: 65536kB</p>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>写一个程序完成以下命令：<br>new id ——新建一个指定编号为id的序列(id&lt;10000)<br>add id num——向编号为id的序列加入整数num<br>merge id1 id2——合并序列id1和id2中的数，并将id2清空<br>unique id——去掉序列id中重复的元素<br>out id ——从小到大输出编号为id的序列中的元素，以空格隔开</p>
</blockquote>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数n，表示有多少个命令( n＜＝２０００００)。以后n行每行一个命令。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>按题目要求输出。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">16</div><div class="line">new 1</div><div class="line">new 2</div><div class="line">add 1 1</div><div class="line">add 1 2</div><div class="line">add 1 3</div><div class="line">add 2 1</div><div class="line">add 2 2</div><div class="line">add 2 3</div><div class="line">add 2 4</div><div class="line">out 1</div><div class="line">out 2</div><div class="line">merge 1 2</div><div class="line">out 1</div><div class="line">out 2</div><div class="line">unique 1</div><div class="line">out 1</div></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 2 3 </div><div class="line">1 2 3 4</div><div class="line">1 1 2 2 3 3 4</div><div class="line"></div><div class="line">1 2 3 4</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>list中的unique是删除所有和前一个元素相同的元素。所有在使用前应该先sort()一下</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>这里给出一开始写得跟屎一样的代码。<br>用map来存储list表。没有封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;iterator&gt; </div><div class="line">using namespace std;</div><div class="line">map&lt;int, list&lt;int&gt; &gt; m;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	cin &gt;&gt; n;</div><div class="line">	while (n--)</div><div class="line">	&#123;</div><div class="line">		string st;</div><div class="line">		cin &gt;&gt; st;</div><div class="line">		switch (st[0]) &#123;</div><div class="line">		case &apos;n&apos;:</div><div class="line">		&#123;</div><div class="line">			int t;</div><div class="line">			cin &gt;&gt; t;</div><div class="line">			list&lt;int&gt; *l = new list&lt;int&gt;;</div><div class="line">			m[t] = *l;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case &apos;a&apos;:</div><div class="line">			int t1, t2;</div><div class="line">			cin &gt;&gt; t1 &gt;&gt; t2;</div><div class="line">			m[t1].push_back(t2);</div><div class="line">			break;</div><div class="line">		case &apos;m&apos;:</div><div class="line">		&#123;</div><div class="line">			int t1, t2;</div><div class="line">			cin &gt;&gt; t1 &gt;&gt; t2;</div><div class="line">			m[t1].merge(m[t2]);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case &apos;u&apos;:</div><div class="line">		&#123;</div><div class="line">			int t;</div><div class="line">			cin &gt;&gt; t;</div><div class="line">			m[t].sort();</div><div class="line">			m[t].unique();</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case &apos;o&apos;:</div><div class="line">		&#123;</div><div class="line">			int t;</div><div class="line">			cin &gt;&gt; t;</div><div class="line">			m[t].sort();</div><div class="line">			list&lt;int&gt;::iterator it;</div><div class="line">			for (it = m[t].begin(); it != m[t].end(); it++)</div><div class="line">			&#123;</div><div class="line">				cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</div><div class="line">			&#125;</div><div class="line">			cout &lt;&lt; endl;</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内存 4740kB<br>时间 3770ms</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>为了锻炼编写面向对象代码的能力。重写了一下。<br>这次使用vector来存储list表，所有相比下要多写一个find函数来定位list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">class MyList &#123;</div><div class="line">public:</div><div class="line">	int id;</div><div class="line">	list &lt;int&gt; lst;</div><div class="line">	MyList(int t)</div><div class="line">	&#123;</div><div class="line">		id = t;</div><div class="line">	&#125;</div><div class="line">	void PrintList()</div><div class="line">	&#123;</div><div class="line">		lst.sort();</div><div class="line">		list&lt;int&gt;::iterator it;</div><div class="line">		for (it = lst.begin(); it != lst.end(); it++)</div><div class="line">		&#123;</div><div class="line">			cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</div><div class="line">		&#125;</div><div class="line">		cout &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	static MyList &amp; _Find(vector&lt;MyList&gt; &amp; v,int t)</div><div class="line">	&#123;</div><div class="line">		vector&lt;MyList&gt;::iterator i;</div><div class="line">		i = v.begin();</div><div class="line">		return *(i + t - 1);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	cin &gt;&gt; n;</div><div class="line">	vector&lt;MyList &gt; v;</div><div class="line">	while (n--)</div><div class="line">	&#123;</div><div class="line">		string s;</div><div class="line">		cin &gt;&gt; s;</div><div class="line">		if (s == &quot;new&quot;)</div><div class="line">		&#123;</div><div class="line">			int t;</div><div class="line">			cin &gt;&gt; t;</div><div class="line">			v.push_back(MyList(t));</div><div class="line">		&#125;</div><div class="line">		if (s == &quot;add&quot;)</div><div class="line">		&#123;</div><div class="line">			int t1, t2;</div><div class="line">			cin &gt;&gt; t1 &gt;&gt; t2;</div><div class="line">			MyList&amp; p1=MyList::_Find(v,t1);</div><div class="line">			p1.lst.push_back(t2);</div><div class="line">		&#125;</div><div class="line">		if (s == &quot;out&quot;)</div><div class="line">		&#123;</div><div class="line">			int t1;</div><div class="line">			cin &gt;&gt; t1;</div><div class="line">			MyList&amp; p1 = MyList::_Find(v, t1);</div><div class="line">			p1.PrintList();</div><div class="line">		&#125;</div><div class="line">		if (s == &quot;merge&quot;)</div><div class="line">		&#123;</div><div class="line">			int t1, t2;</div><div class="line">			cin &gt;&gt; t1 &gt;&gt; t2;</div><div class="line">			MyList&amp; p1 = MyList::_Find(v, t1);</div><div class="line">			MyList&amp; p2 = MyList::_Find(v, t2);</div><div class="line">			p1.lst.merge(p2.lst);</div><div class="line">		&#125;</div><div class="line">		if (s == &quot;unique&quot;)</div><div class="line">		&#123;</div><div class="line">			int t1;</div><div class="line">			cin &gt;&gt; t1;</div><div class="line">			MyList&amp; p1 = MyList::_Find(v, t1);</div><div class="line">			p1.lst.sort();</div><div class="line">			p1.lst.unique();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内存4336kB<br>时间2910ms    </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera疑问]]></title>
      <url>http://blog.acbingo.cn/2016/01/20/coursera%E7%96%91%E9%97%AE/</url>
      <content type="html"><![CDATA[<p>这里汇集各种问题<br><a id="more"></a></p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt; </div><div class="line">#include &lt;iterator&gt; </div><div class="line">#include &lt;set&gt; </div><div class="line">using namespace std;</div><div class="line">int main() &#123; </div><div class="line">    int a[] = &#123;8,7,8,9,6,2,1&#125;; </div><div class="line">// 在此处补充你的代码</div><div class="line">    set&lt;int&gt;  v(a,a+7);</div><div class="line">    </div><div class="line">    ostream_iterator&lt;int&gt; o(cout,&quot; &quot;);</div><div class="line">    copy( v.begin(),v.end(),o); </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出 1 2 6 7 8 9<br>这段代码是怎么执行的呢。。。看不懂。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记-函数对象]]></title>
      <url>http://blog.acbingo.cn/2016/01/19/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>coursera学习笔记-函数对象<br><a id="more"></a><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f058v8zyvkj30r10es0vg.jpg" alt=""></p>
<p>这有个比较nb的实例。<br>前段时间我用cocos开发飞机大战的时候，代码中实现自定义函数回调时就用到了这个特性，当时就感觉挺牛逼的，但是一直没想明白是怎么传递过去函数名字的<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f0593bujg7j30qe0ekdhx.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0597678lcj30r10evac6.jpg" alt=""><br>这里SumPowers类中重载了()。有一个构造函数，参数p，意思是p次方。重载()函数意思是求p次方的和</p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f059a38t42j30qu0f0n10.jpg" alt=""></p>
<p>如图，编译器会实例化（解释）出第一句对应的信息。<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f059chn372j30qr0f20uq.jpg" alt=""><br>v.begin()v.end()对应的是两个迭代器，0，对应整形参数。<br><strong>第四个参数是个函数的名字</strong>，什么样的形参才能够和函数的名字相匹配呢。<br>函数的指针可以和函数的名字相匹配，因此，实例过去的参数就是int (*op)(int,int)，这正好和SumSquares函数特点是一致的</p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f059jf97crj30r50ef40d.jpg" alt=""><br>在这里，op就不是函数名啦。他是SumPowers<int>类的一个实例，power值为3.<br>init=op(init,*first)实际上调用的是该类中的重载()函数</int></p>
<p>函数对象有啥价值呢？<br>反正我有点不太同意老师的说法。。。所有我现在也说不出。<br>等有时间专门研究下这个。</p>
<p>函数对象类模板<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f059t1q27fj30qy0eo0ua.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f05a1xtn62j30qw0ecdhk.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f05a1591f1j30qy0esmzt.jpg" alt=""><br>这里自己定义了一个MyLess函数对象类<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f05a2az3q1j30qn0ejgno.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f05a2xgq34j30qn0ehwgt.jpg" alt=""><br>lst.sort(cmp)，参数传的是cmp，别搞混了。<br>给出的参数是个函数对象，MyLess是个类的名字，后面跟个括号，实际上是个临时对象，该临时对象是用无参构造函数构造的</p>
<p>看到这，貌似对函数对象的价值有所认识了。<br>比如对lst.sort(Myless())这一句，为了实现同样的功能，我可以写一个MyLess的函数，而不是写成一个对象这么麻烦，但是呢，在面向对象开发中这是不友好的。</p>
<p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f05aam9dwpj30re0fcgo8.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f05abiylgej30qe0f2n06.jpg" alt=""><br>答案<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f05agav914j30qq0extau.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f05ahw2fumj30qq0ev0tm.jpg" alt=""><br>greater是重载的大于运算符</p>
<p>课后习题做错了一个题</p>
<h1 id="STL容器里存放对象还是指针"><a href="#STL容器里存放对象还是指针" class="headerlink" title="STL容器里存放对象还是指针"></a>STL容器里存放对象还是指针</h1><p>对于内建类型(int float char等)，容器的工作方式是纯粹的位拷贝，这里没有什么需要多说的。</p>
<p>对于自定义的对象，容器容纳了对象（比如通过insert或push_back等），但容器中存放的对象不是你给它们的那个对象，因为两个对象在内存中的位置不一样。此外，当你从容器中获取一个对象时，你所得到的对象不是容器里的那个对象。取而代之的是，当你向容器中添加一个对象（比如通过insert或push_back等），进入容器的是你指定的对象的拷贝。拷进去，拷出来。拷贝是STL的方式。</p>
<p><a href="http://hsw625728.blog.163.com/blog/static/3957072820091116115732821/" target="_blank" rel="external">STL容器里存放对象还是指针</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记-顺序容器Vector、List和Deque]]></title>
      <url>http://blog.acbingo.cn/2016/01/19/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8Vector/</url>
      <content type="html"><![CDATA[<p>顺序容器Vector、List和Deque<br><a id="more"></a><br>Vector的一些性质<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f057z2w7t3j30r00fcwhi.jpg" alt=""></p>
<ol>
<li>可以用数组作为构造函数参数</li>
<li>可以对Vector.insert达到从数组中插入的效果<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f0586n8qttj30qz0f4djb.jpg" alt=""></li>
</ol>
<p>二维动态数组<br>vector&lt; vector<int> &gt;v(3);<br>例子<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f0589287qij30qq0f6q57.jpg" alt=""></int></p>
<p>List<br>list实际上是一个双向链表</p>
<ol>
<li>不支持下标随机存储数</li>
<li><p>具有所有的顺序容器都有的成员函数</p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1f058bsst49j30qk0f8dje.jpg" alt=""></p>
</li>
<li>额外支持的成员函数<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f058czppd2j30r40fkjvj.jpg" alt=""><br>list中的sort函数<br>list是不支持标准库的sort函数的（想想why）<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1f058fflin7j30qy0fegqu.jpg" alt=""><br>各种成员函数的用法<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f058lsuq0aj30qq0eyaeb.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f058mwv8afj30qx0fajwu.jpg" alt=""><br>注意，merge只是清空了lst2，并没有删除。</li>
</ol>
<p>splice用法<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f058p40yizj30qf0f577y.jpg" alt=""></p>
<p>deque<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f058s1sm4tj30ql0eytc4.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-14-最长公共子序列]]></title>
      <url>http://blog.acbingo.cn/2015/12/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p><strong>最长公共子序列</strong>:一个数列，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 称为已知序列的最长公共子序列。</p>
<blockquote>
<p>最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。而最长公共子串(要求连续)和最长公共子序列是不同的</p>
</blockquote>
<a id="more"></a>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>举个例子，acbingo这个字符串中子序列有多少个呢？很显然有2^7个，比如其中的ac,aio等等都是其子序列，我们可以看出子序列不见得一定是连续的，连续的那是子串。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>这种方法是最简单，也是最容易想到的，当然时间复杂度也是龟速的，一个长度为N的字符串，其子序列有2N个，每个子序列要在第二个长度为N的字符串中去匹配，匹配一次需要O(N)的时间，总共也就是O(N*2^N)，可以看出，时间复杂度为指数级，恐怖的令人窒息。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>既然是经典的题目肯定是有优化空间的，并且解题方式是有固定流程的，这里我们采用的是矩阵实现，也就是二维数组。<br>第一步：先计算最长公共子序列的长度。<br>第二步：根据长度，然后通过回溯求出最长公共子序列。<br>现有两个序列X={x1,x2,x3，…xi}，Y={y1,y2,y3，….，yi}，<br>设一个C[i,j]: 保存Xi与Yj的LCS的长度。<br>递推方程为：<br><img src="http://pic002.cnblogs.com/images/2012/214741/2012111100085930.png" alt=""><br>不知道大家看懂了没？动态规划的一个重要性质特点就是解决“子问题重叠”的场景，可以有效的避免重复计算，根据上面的公式其实可以发现C[i,j]一直保存着当前(Xi,Yi)的最大子序列长度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-13-矩阵连乘问题]]></title>
      <url>http://blog.acbingo.cn/2015/12/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1,2 ,…,n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。例如：</p>
<pre><code>A1={30x35} ; A2={35x15} ;A3={15x5} ;A4={5x10} ;A5={10x20} ;A6={20x25} ;
</code></pre><p>最后的结果为：((A1(A2A3))((A4A5)A6))  最小的乘次为15125。<br><a id="more"></a></p>
<h1 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h1><p>直接求解的话，a、b两个矩阵相乘的计算量为<code>p*q*r</code>。<br>那么可以递归的枚举所有完全加括号的方式，如图<br><img src="http://img.my.csdn.net/uploads/201303/31/1364723980_5748.gif" alt=""></p>
<ol>
<li>（A（BCD））——&gt;（A（B（CD））），（A（（BC）D））;</li>
<li>（（AB）（CD））——&gt;NULL；</li>
<li>（（ABC）D）——&gt;（（A（BC）D）），（（（AB）C）D）;<br>对于上面四个矩阵来说，枚举方法是：<br>1、括号加在A和B之间，矩阵链被分为（A）和（BCD）；<br>2、括号加在B和C之间，矩阵链被分为（AB）和（CD）；<br>3、括号加在C和D之间，矩阵链被分为（ABC）和（D）；<br>在第一步中分出的（A）已经不能在加括号了，所以结束；<br>而（BCD）继续按照上面的步奏把括号依次加在B和C、C和D之间，其他情况相同。<br>加括号的过程是递归的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//m数组内存放矩阵链的行列信息</div><div class="line">//m[i-1]和m[i]分别为第i个矩阵的行和列（i = 1、2、3...）</div><div class="line">int Best_Enum(int m[], int left, int right)</div><div class="line">&#123;</div><div class="line">	//只有一个矩阵时，返回计算次数0</div><div class="line">	if (left == right)</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	int min = INF; //无穷大</div><div class="line">	int i;</div><div class="line">	//括号依次加在第1、2、3...n-1个矩阵后面</div><div class="line">	for (i = left; i &lt; right; i++)</div><div class="line">	&#123;</div><div class="line">		//计算出这种完全加括号方式的计算次数</div><div class="line">		int count = Best_Enum(m, left, i) + Best_Enum(m, i+1, right);</div><div class="line">		count += m[left-1] * m[i] * m[right];</div><div class="line">		//选出最小的</div><div class="line">		if (count &lt; min)</div><div class="line">		&#123;</div><div class="line">			min = count;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p><img src="http://img.my.csdn.net/uploads/201303/31/1364723989_8470.png" alt=""><br>上图为递归枚举过程，小方块内的1:4代表第1个矩阵至第4个矩阵的完全加括号方式<br>可以看到黄色方块中有很多重复计算，所以利用备忘录来保存计算结果，在每次进行计算前，先查表，看是否计算过，避免重复计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">#define SIZE 100</div><div class="line">#define INF 999999999</div><div class="line"></div><div class="line">int memo[SIZE][SIZE];</div><div class="line"></div><div class="line">//m数组内存放矩阵链的行列信息</div><div class="line">//m[i-1]和m[i]分别为第i个矩阵的行和列（i = 1、2、3...）</div><div class="line">int Best_Memo(int m[], int left, int right)</div><div class="line">&#123;</div><div class="line">	//只有一个矩阵时，返回计算次数0</div><div class="line">	if (left == right)</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	int min = INF;</div><div class="line">	int i;</div><div class="line">	//括号依次加在第1、2、3...n-1个矩阵后面</div><div class="line">	for (i = left; i &lt; right; i++)</div><div class="line">	&#123;</div><div class="line">		//计算出这种完全加括号方式的计算次数</div><div class="line">		int count;</div><div class="line">		if (memo[left][i] == 0)</div><div class="line">		&#123;</div><div class="line">			memo[left][i] = Best_Memo(m, left, i);</div><div class="line">		&#125;</div><div class="line">		count = memo[left][i];</div><div class="line">		if (memo[i+1][right] == 0)</div><div class="line">		&#123;</div><div class="line">			memo[i+1][right] = Best_Memo(m, i+1, right);</div><div class="line">		&#125;</div><div class="line">		count += memo[i+1][right];</div><div class="line">		count += m[left-1] * m[i] * m[right];</div><div class="line">		//选出最小的</div><div class="line">		if (count &lt; min)</div><div class="line">		&#123;</div><div class="line">			min = count;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return min;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	int m[SIZE];</div><div class="line">	int n;</div><div class="line">	while (scanf(&quot;%d&quot;, &amp;n) != EOF)</div><div class="line">	&#123;</div><div class="line">		int i;</div><div class="line">		for (i = 0; i &lt; n; i++)</div><div class="line">		&#123;</div><div class="line">			scanf(&quot;%d&quot;, &amp;m[i]);</div><div class="line">		&#125;</div><div class="line">		memset(memo, 0, sizeof(memo));</div><div class="line">		printf(&quot;%d\n&quot;, Best_Memo(m, 1, n-1));</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>那么，由上面的备忘录算法可以得出动态规划算法</p>
<blockquote>
<p>从连乘矩阵个数为2开始计算每次的最小乘次数m[i][j]: m[0][1] m[1][2] m[2][3] m[3][4] m[4][5]  //m[0][1]表示第一个矩阵与第二个矩阵的最小乘次数<br>然后再计算再依次计算连乘矩阵个数为3 :m[0][2] m[1][3] m[2][4] m[3][5]<br>　　　　　　　　　  连乘矩阵个数为4：m[0][3] m[1][4] m[2][5]<br>　　　　　　　　　　连乘矩阵个数为5：m[0][4] m[1][5]<br>　　　　　　　　　　连乘矩阵个数为6：m[0][5]    //即最后我们要的结果</p>
</blockquote>
<h2 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h2><p><img src="http://img.my.csdn.net/uploads/201303/31/1364723997_2096.gif" alt=""><br>k为矩阵链断开的位置<br>d数组存放矩阵链计算的最优值，d[i][j]是以第i个矩阵为首，第j个矩阵为尾的矩阵链的最优值，i &gt; 0<br>m数组内存放矩阵链的行列信息，m[i-1]和m[i]分别为第i个矩阵的行和列（i = 1、2、3…）</p>
<p>转移方程有了，有两种循环方法：</p>
<ol>
<li>外层循环枚举矩阵长度len,内层循环枚举矩阵(i,j=i+len)</li>
<li>外层枚举i，内层枚举j.<br>显然，第二种枚举方法是不对的。根本不适合此题。此题应该从小枚举矩阵.</li>
</ol>
<p>矩阵A(2,3),B(3,4),C(4,5)<br>输入数据:<br>3<br>2 3 4 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define SIZE 100</div><div class="line">#define INF 999999999</div><div class="line"></div><div class="line">int m[SIZE];		//存放矩阵链的行列信息，m[i-1]和m[i]分别为第i个矩阵的行和列（i = 1、2、3...）</div><div class="line">int d[SIZE][SIZE];	//存放矩阵链计算的最优值，d[i][j]为第i个矩阵到第j个矩阵的矩阵链的最优值，i &gt; 0</div><div class="line"></div><div class="line">int Best_DP(int n)</div><div class="line">&#123;</div><div class="line">	//把d[i][i]置为0，1 &lt;= i &lt; n</div><div class="line">	memset(d, 0, sizeof(d));</div><div class="line"></div><div class="line">	int len;</div><div class="line">	//递归计算矩阵链的连乘最优值</div><div class="line">	//len = 1，代表矩阵链由两个矩阵构成</div><div class="line">	for (len = 1; len &lt; n; len++)</div><div class="line">	&#123;</div><div class="line">		int i, j, k;</div><div class="line">		for (i = 1, j = i+len; j &lt; n; i++, j++)</div><div class="line">		&#123;</div><div class="line">			int min = INF; //无穷大</div><div class="line">			for (k = i; k &lt; j; k++)</div><div class="line">			&#123;</div><div class="line">				int count = d[i][k] + d[k+1][j] + m[i-1] * m[k] * m[j];</div><div class="line">				if (count &lt; min)</div><div class="line">				&#123;</div><div class="line">					min = count;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			d[i][j] = min;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return d[1][n-1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	int n;</div><div class="line">	while (scanf(&quot;%d&quot;, &amp;n) != EOF)</div><div class="line">	&#123;</div><div class="line">		int i;</div><div class="line">		for (i = 0; i &lt; n; i++)</div><div class="line">		&#123;</div><div class="line">			scanf(&quot;%d&quot;, &amp;m[i]);</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, Best_DP(n));</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/code_pang/article/details/8743601" target="_blank" rel="external">http://blog.csdn.net/code_pang/article/details/8743601</a><br>最近要实训，还有各种课程设计，代码有时间的话自己写，没时间标上Todo，对于我认为做起来意义不大的直接copy别人的吧= =</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-12-循环赛日程表]]></title>
      <url>http://blog.acbingo.cn/2015/12/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>设有n=2^k个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</p>
<ol>
<li>每个选手必须与其他n-1个选手各赛一次；</li>
<li>每个选手一天只能参赛一次；</li>
<li>循环赛在n-1天内结束。<br>请按此要求将比赛日程表设计成有n行和n-1列的一个表。在表中的第i行，第j列处填入第i个选手在第j天所遇到的选手。其中1≤i≤n，1≤j≤n-1。8个选手的比赛日程表如下图：<br><img src="http://img.my.csdn.net/uploads/201301/10/1357784715_3511.jpg" alt=""><a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>按分治策略，我们可以将所有的选手分为两半，则n个选手的比赛日程表可以通过n/2个选手的比赛日程表来决定。递归地用这种一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单。这时只要让这两个选手进行比赛就可以了。如上图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手1至选手4和选手5至选手8前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。依此思想容易将这个比赛日程表推广到具有任意多个选手的情形。</p>
</blockquote>
</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>代码思路.<br>书上的思路已经说的很好了。<br>以上图为例子吧。为了方便描述，我们将划分后的表顺时针分为四个象限.<br>那么，第三象限=第一象限,一般化：</p>
<pre><code>map[i+k/2][j+k/2]=map[i][j];
</code></pre><p>第二四象限=第一象限+K/2。一般化为：</p>
<pre><code>map[i+k/2][j]=map[i][j]+k/2;
map[i][j+k/2]=map[i][j]+k/2;
</code></pre><p>书上给出的是迭代代码，这里给出递归代码，对于分治来说，递归更易写也更易理解。但是迭代因为没有递归时系统栈的开销，所以效率更好一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-12-03 21:26</div><div class="line"> * Filename: xunhuansai.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int mp[100][100];</div><div class="line">void fun(int n)&#123;</div><div class="line">    if (n==2)&#123;</div><div class="line">        mp[1][1]=mp[2][2]=1;</div><div class="line">        mp[1][2]=mp[2][1]=2;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    if (n&gt;2) fun(n/2);</div><div class="line">    int k=n/2;</div><div class="line">    //进行复制</div><div class="line">    for (int i=1;i&lt;=k;i++)</div><div class="line">        for (int j=1;j&lt;=k;j++)&#123;</div><div class="line">            mp[i+k][j+k]=mp[i][j];</div><div class="line">            mp[i+k][j]=mp[i][j]+k;</div><div class="line">            mp[i][j+k]=mp[i][j]+k;</div><div class="line">        &#125;</div><div class="line">    return ;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cout&lt;&lt;&quot;请输入K值&quot;&lt;&lt;endl;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    fun(n);</div><div class="line">    for (int i=1;i&lt;=n;i++)&#123;</div><div class="line">        for (int j=1;j&lt;=n;j++)&#123;</div><div class="line">            cout&lt;&lt;mp[i][j]&lt;&lt;&quot; &quot;;</div><div class="line">        &#125;</div><div class="line">        cout&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>递归栈所需的计算复杂度为T(KlgK),复制数组总体上的计算复杂度为T(K^2)。故该算法的时间复杂度为O(K^2)。<br>由于算法肯定会对二维数组的每一个元素至少访问一次.故最优复杂度不会优于O(K^2)。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>无</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-11-最接近点对问题]]></title>
      <url>http://blog.acbingo.cn/2015/12/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最接近点问题。<br><a id="more"></a><br>这几天每天能挤出的时间不多。此题比较复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">//2d10-1 一维最邻近点对问题</div><div class="line">#include &quot;stdafx.h&quot;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">#include &lt;iostream&gt; </div><div class="line">using namespace std; </div><div class="line"></div><div class="line">const int L=100;</div><div class="line">//点对结构体</div><div class="line">struct Pair</div><div class="line">&#123;</div><div class="line">	float d;//点对距离</div><div class="line">	float d1,d2;//点对坐标</div><div class="line">&#125;;</div><div class="line">float Random();</div><div class="line">int input(float s[]);//构造S</div><div class="line">float Max(float s[],int p,int q);</div><div class="line">float Min(float s[],int p,int q);</div><div class="line">template &lt;class Type&gt;</div><div class="line">void Swap(Type &amp;x,Type &amp;y);</div><div class="line">template &lt;class Type&gt;</div><div class="line">int Partition(Type s[],Type x,int l,int r);</div><div class="line">Pair Cpair(float s[],int l,int r);</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	srand((unsigned)time(NULL));</div><div class="line">	int m;</div><div class="line">	float s[L];</div><div class="line">	Pair d;</div><div class="line">	m=input(s);</div><div class="line">	d=Cpair(s,0,m-1);</div><div class="line">	cout&lt;&lt;endl&lt;&lt;&quot;最近点对坐标为： (d1:&quot;&lt;&lt;d.d1&lt;&lt;&quot;,d2:&quot;&lt;&lt;d.d2&lt;&lt;&quot;)&quot;;</div><div class="line">	cout&lt;&lt;endl&lt;&lt;&quot;这两点距离为： &quot;&lt;&lt;d.d&lt;&lt;endl;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">float Random()</div><div class="line">&#123;</div><div class="line">	float result=rand()%10000;</div><div class="line">	 return result*0.01;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int input(float s[])</div><div class="line">&#123;</div><div class="line">	int length;</div><div class="line">	cout&lt;&lt;&quot;输入点的数目： &quot;;</div><div class="line">	cin&gt;&gt;length;</div><div class="line">	cout&lt;&lt;&quot;点集在X轴上坐标为：&quot;;</div><div class="line">	for(int i=0;i&lt;length;i++)</div><div class="line">	&#123;</div><div class="line">		s[i]=Random();</div><div class="line">		cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">float Max(float s[],int l,int r)//返回s[]中的最大值</div><div class="line">&#123;</div><div class="line">	float s_max=s[l];</div><div class="line">	for(int i=l+1;i&lt;=r;i++)</div><div class="line">		if(s_max&lt;s[i])</div><div class="line">			s_max=s[i];</div><div class="line">	return s_max;</div><div class="line">&#125;</div><div class="line"></div><div class="line">float Min(float s[],int l,int r)//返回s[]中的最小值</div><div class="line">&#123;</div><div class="line">	float s_min=s[l];</div><div class="line">	for(int i=l+1;i&lt;=r;i++) </div><div class="line">		if(s_min&gt;s[i])</div><div class="line">			s_min=s[i];</div><div class="line">	return s_min;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template &lt;class Type&gt;</div><div class="line">void Swap(Type &amp;x,Type &amp;y)</div><div class="line">&#123;</div><div class="line">	Type temp = x;</div><div class="line">	x = y;</div><div class="line">	y = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template &lt;class Type&gt;</div><div class="line">int Partition(Type s[],Type x,int l,int r)</div><div class="line">&#123;</div><div class="line">	int i = l - 1,j = r + 1;</div><div class="line"></div><div class="line">	while(true)</div><div class="line">	&#123;</div><div class="line">		while(s[++i]&lt;x &amp;&amp; i&lt;r);</div><div class="line">		while(s[--j]&gt;x);</div><div class="line">		if(i&gt;=j)</div><div class="line">		&#123;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		Swap(s[i],s[j]);</div><div class="line">	&#125;</div><div class="line">	return j;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回s[]中的具有最近距离的点对及其距离</div><div class="line">Pair Cpair(float s[],int l,int r)</div><div class="line">&#123;</div><div class="line">	Pair min_d=&#123;99999,0,0&#125;;//最短距离</div><div class="line"></div><div class="line">	if(r-l&lt;1) return min_d;</div><div class="line">	float m1=Max(s,l,r),m2=Min(s,l,r);</div><div class="line"></div><div class="line">	float m=(m1+m2)/2;//找出点集中的中位数</div><div class="line"></div><div class="line">	//将点集中的各元素按与m的大小关系分组</div><div class="line">	int j = Partition(s,m,l,r);</div><div class="line"></div><div class="line">	Pair d1=Cpair(s,l,j),d2=Cpair(s,j+1,r);//递归</div><div class="line">	float p=Max(s,l,j),q=Min(s,j+1,r);</div><div class="line"></div><div class="line">	//返回s[]中的具有最近距离的点对及其距离</div><div class="line">	if(d1.d&lt;d2.d)</div><div class="line">	&#123;</div><div class="line">		if((q-p)&lt;d1.d)</div><div class="line">		&#123;</div><div class="line">			min_d.d=(q-p);</div><div class="line">			min_d.d1=q;</div><div class="line">            min_d.d2=p;</div><div class="line">			return min_d;</div><div class="line">		&#125;</div><div class="line">		else return d1;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		if((q-p)&lt;d2.d)</div><div class="line">		&#123;</div><div class="line">			min_d.d=(q-p);</div><div class="line">			min_d.d1=q;</div><div class="line">            min_d.d2=p;</div><div class="line">			return min_d;</div><div class="line">		&#125;</div><div class="line">		else return d2;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-10-线性时间选择]]></title>
      <url>http://blog.acbingo.cn/2015/12/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p>其实这个问题就是<strong>寻找最大的K个数（TOP K算法）</strong><br><a id="more"></a></p>
<h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><p>直接进行排序，对重复的点进行压缩。最后直接输出第I个元素即可。<br>时间复杂度O(N^2)</p>
<h1 id="利用快速排序的划分方法"><a href="#利用快速排序的划分方法" class="headerlink" title="利用快速排序的划分方法"></a>利用快速排序的划分方法</h1><p>N个数存储在数组S中，再从数组中随机选取一个数X（随机选取基准元素，可做到线性期望时间O（N）的复杂度）（一般情况下随机取数的执行算法的效率并不高，可以用中位数代替随机数），把数组划分为Sa和Sb俩部分，Sa&lt;=X&lt;=Sb，<br>1，如果要查找的k个元素小于Sa的元素个数，则返回Sa中较小的k个元素；<br>2，否则返回Sa中k个小的元素+Sb中小的k-|Sa|个元素。<br>这样递归下去，不断把问题分解成更小的问题，平均时间复杂度O（Nlog2K）。<br>由于是随机的，所以其期望时间复杂度时O（N）的</p>
<h1 id="最坏情况线性时间"><a href="#最坏情况线性时间" class="headerlink" title="最坏情况线性时间"></a>最坏情况线性时间</h1><p>上面期望时间线性是因为可能存在某种最坏的情况，每次分割元的位置都是导致一边没有元素，这样就不能够达到线性了，接下来的一些预先工作就是避免这种情况发生。</p>
<p>算法SELECT通过执行下列步骤来确定一个有n个元素的输入数组中的第i个小的元素。</p>
<ol>
<li>将输入数组的n个元素划分为n/5组，每组5个元素，且至多有一个组由剩下的n mod 5个元素组成。</li>
<li>寻找n/5个组中每一组的中位数。（方法首先对每组中的元素进行插入排序，然后从排序过的序列中选出中位数）</li>
<li>对第2步中找出的n/5个中位数，递归调用SELECT找出其中位数x。（如果有偶数个中位数，根据约定，x是下中位数。）</li>
<li>利用修改过的PARTITION过程，按中位数的中位数x对输入数组进行划分。让k比划分低区的元素多1，所以x是第k小的元素，并且有n-k个元素在划分的高区。</li>
<li>如果i=k，则返回x，否则，如果i<k，则在低区递归调用select以找出第i小的元素,,如果i>k，则在高区找第（i-k）个最小元素。<br><img src="http://images.cnitblog.com/blog/342726/201212/23201146-25c3fae08dde4e4789469807ef7b1fb3.jpg" alt=""></k，则在低区递归调用select以找出第i小的元素,,如果i></li>
</ol>
<p>图中箭头指向表示大的数值指向小的数值，所以根据图可以看出，在x的右边，每一个包含5个元素的组中至少有3个元素大于x，x的左边，每一组中至少有3个元素小于x。（保证x分割一边必定有元素存在）<br>图中显示的中位数的中位数x的位置，每次选取x作为划分的好处是能够保证必定有一部分在x的一边。<br>所以算法最坏情况的递归公式可以写成：<br><img src="http://images.cnitblog.com/blog/342726/201212/23202211-5ddbfed51b07407e893cdef07528ce44.jpg" alt=""><br>使用替换法可以得出T（n）&lt;=cn。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">//线性时间选择，元素可以有重复</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define N 1000</div><div class="line">int num[N];</div><div class="line">void qsort(int *a,int x,int y)</div><div class="line">&#123;</div><div class="line">    int xx=x,yy=y;</div><div class="line">    int k=a[x];</div><div class="line">    if(x&gt;=y)</div><div class="line">        return;</div><div class="line">    while(xx!=yy)</div><div class="line">    &#123;</div><div class="line">        while(xx&lt;yy &amp;&amp; a[yy]&gt;=k)</div><div class="line">            yy--;</div><div class="line">        a[xx]=a[yy];</div><div class="line">        while(xx&lt;yy &amp;&amp; a[xx]&lt;=k)</div><div class="line">            xx++;</div><div class="line">        a[yy]=a[xx];</div><div class="line">    &#125;</div><div class="line">    a[xx]=k;</div><div class="line">    qsort(a,x,xx-1);</div><div class="line">    qsort(a,xx+1,y);</div><div class="line">&#125;</div><div class="line">void swap(int a,int b)</div><div class="line">&#123;</div><div class="line">    int c;</div><div class="line">    c=num[a];</div><div class="line">    num[a]=num[b];</div><div class="line">    num[b]=c;</div><div class="line">&#125;</div><div class="line">int mid(int a)</div><div class="line">&#123;</div><div class="line">    int b[5];</div><div class="line">    int i;</div><div class="line">    for(i=0;i&lt;5;++i)</div><div class="line">        b[i]=num[a+i];</div><div class="line">    qsort(b,0,4);</div><div class="line">    for(i=0;i&lt;5;++i)</div><div class="line">        if(b[2]==num[a+i])</div><div class="line">            return (a+i);</div><div class="line">&#125;</div><div class="line">int partition(int p,int r,int x)</div><div class="line">&#123;</div><div class="line">    int i=p,j=r+1;</div><div class="line">    while(true)</div><div class="line">    &#123;</div><div class="line">        while(num[++i]&lt;x);</div><div class="line">        while(num[--j]&gt;x);</div><div class="line">        if(i&gt;=j) break;</div><div class="line">        swap(i,j);</div><div class="line">    &#125;</div><div class="line">    num[p]=num[j];//必须是j不能是i</div><div class="line">    num[j]=x;</div><div class="line">    return j;</div><div class="line">&#125;</div><div class="line">int select(int p,int r,int k)//选择p到r间的第k小元素</div><div class="line">&#123;</div><div class="line">    if(r-p&lt;75)</div><div class="line">    &#123;</div><div class="line">        qsort(num,p,r);</div><div class="line">        return num[p+k-1];</div><div class="line">    &#125;</div><div class="line">    int n=r-p+1;</div><div class="line">    int i,j;</div><div class="line">    for(i=0;i&lt;=(n-5)/5;++i)</div><div class="line">    &#123;</div><div class="line">        j=mid(p+5*i);</div><div class="line">        swap(p+i,j);</div><div class="line">    &#125;</div><div class="line">    int x=select(p,p+(n-5)/5,(n-5)/10);</div><div class="line">    i=partition(p,r,x);</div><div class="line">j=i-p+1;</div><div class="line">int m,count;</div><div class="line">m=0;</div><div class="line">for(count=p;count&lt;=r;++count)</div><div class="line">    if(num[count]==x)</div><div class="line">        ++m;</div><div class="line">    if(m&gt;=1 &amp;&amp; j&lt;=k &amp;&amp; k&lt;=j+m-1)</div><div class="line">        return num[i];</div><div class="line">    else if(k&lt;=j) return select(p,i,k);</div><div class="line">    else return select(i+1+m,r,k-j-m);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i,j,k;</div><div class="line">    while(true)</div><div class="line">    &#123;</div><div class="line">        i=0;</div><div class="line">        printf(&quot;please putin num[]:\n&quot;);</div><div class="line">        while(scanf(&quot;%d&quot;,&amp;num[i]),num[i])&#123;++i;&#125;</div><div class="line">        printf(&quot;please putin k:\n&quot;);</div><div class="line">        scanf(&quot;%d&quot;,&amp;k);</div><div class="line">        j=select(0,i-1,k);</div><div class="line">        printf(&quot;the Kth element is: %d\n&quot;,j);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://blog.csdn.net/ts173383201/article/details/7839482" target="_blank" rel="external"> 寻找最大的K个数(TOP K算法)</a></li>
<li><a href="http://www.cnblogs.com/weixliu/archive/2012/12/23/2830199.html" target="_blank" rel="external">http://www.cnblogs.com/weixliu/archive/2012/12/23/2830199.html</a></li>
<li><a href="http://www.cnblogs.com/javaspring/archive/2012/08/17/2656208.html" target="_blank" rel="external">http://www.cnblogs.com/javaspring/archive/2012/08/17/2656208.html</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-9-快速排序]]></title>
      <url>http://blog.acbingo.cn/2015/11/27/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>啊哈，终于到了排序中最有名的也是最复杂的快速排序。<br>附一段《algorithms》上关于本节的介绍：</p>
<blockquote>
<p>The subject of this section is the sorting algorithm that is probably used more widely than any other, quicksort. Quicksort is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. The quicksort algorithm’s desirable features are that it is in-place (uses only a small auxiliary stack) and that it requires time proportional to N log N on the average to sort an array of length N. None of the algorithms that we have so far considered combine these two properties.Furthermore, quicksort has a shorter inner loop than most other sorting algorithms,which means that it is fast in practice as well as in theory. Its primary drawback is that it is fragile in the sense that some care is involved in the implementation to be sure to avoid bad performance. Numerous examples of mistakes leading to quadratic performance in practice are documented in the literature. Fortunately, the lessons learned from these mistakes have led to various improvements to the algorithm that make it of even broader utility, as we shall see.</p>
</blockquote>
<a id="more"></a>
<h1 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h1><p>说实话我还是想贴《algorithms》书上的介绍:</p>
<blockquote>
<p>Quicksort is a divide-and-conquer method for sorting. It works by partitioning an array into two subarrays, then sorting the subarrays independently.Quicksort is complementary to mergesort: for mergesort, we break the array into two subarrays to be sorted and then combine the ordered subarrays to make the whole ordered array; for quicksort, we rearrange the array such that, when the two subarrays are sorted, the whole array is ordered. In the first instance, we do the two recursive calls before working on the whole array; in the second instance, we do the two recursive calls after working on the whole array. For mergesort, the array is divided in half; for quicksort, the position of the partition depends on the contents of the array. </p>
</blockquote>
<p>简单的来说，快速排序递归调用发生在处理整个数组之后。如图<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1eygnl4gcscj30s10akgm3.jpg" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>快排的算法实现过程网上一大堆，这里贴一个讲的比较萌的。</p>
<hr>
<p>假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：</p>
<blockquote>
<p>3  1  2  5  4  6  9  7  10  8</p>
</blockquote>
<p>在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？</p>
<p>方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。<br><img src="http://s9.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNWg3HhPAAAfgmnJY0E832.jpg" alt=""><br>首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。<br><img src="http://s3.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNbjWRw9AAAfljx73DY807.jpg" alt=""><br><img src="http://s9.51cto.com/wyfs02/M00/19/FF/wKiom1MUSP7gBX4VAAAaPLt4QB0783.jpg" alt=""><br>现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p>
<blockquote>
<p>6  1  2  5  9  3  4  7  10  8</p>
</blockquote>
<p><img src="http://s7.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQCzWy0UAAAe9Ihqgcs108.jpg" alt=""><br><img src="http://s7.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQOCyGOFAAAbW4sRFRs031.jpg" alt=""><br>到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p>
<blockquote>
<p>6  1  2  5  4  3  9  7  10  8</p>
</blockquote>
<p>第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：</p>
<blockquote>
<p>3  1  2  5  4  6  9  7  10  8</p>
</blockquote>
<p><img src="http://s2.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQWiPameAAAawpa4u98529.jpg" alt=""><br><img src="http://s3.51cto.com/wyfs02/M02/19/FF/wKiom1MUSQizZS4AAAAg4BoYKU8539.jpg" alt=""><br><img src="http://s3.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQqSkSkpAAAchtx6GUg755.jpg" alt=""><br>到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。</p>
<p>OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。</p>
<p>左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧</p>
<p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是：</p>
<blockquote>
<p>2  1  3  5  4</p>
</blockquote>
<p>OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：</p>
<blockquote>
<p>1  2  3 4  5  6 9  7  10  8</p>
</blockquote>
<p>对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下</p>
<blockquote>
<p>1  2  3 4  5  6  7  8 9  10</p>
</blockquote>
<p>到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。<br><img src="http://s8.51cto.com/wyfs02/M02/19/FF/wKiom1MUSRPjUTOIAAC-kWvhNhc591.jpg" alt=""></p>
<h1 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-11-28 14:15</div><div class="line"> * File Name: quicksort.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">void quicksort(int *a,int l,int r)&#123;</div><div class="line">    //对数组a的[l~r]区间（闭区间）进行快速排序(升序)</div><div class="line">    if (l&gt;r) return;</div><div class="line">    int base=l;</div><div class="line">    int tmp=a[base];</div><div class="line">    int i=l,j=r;</div><div class="line">    while (i&lt;j)&#123;</div><div class="line">        while (a[j]&gt;=tmp&amp;&amp;i&lt;j) j--;</div><div class="line">        while (a[i]&lt;=tmp&amp;&amp;i&lt;j) i++;</div><div class="line">        if (i&lt;j) swap(a[i],a[j]);</div><div class="line">    &#125;</div><div class="line">    a[base]=a[i];</div><div class="line">    a[i]=tmp;</div><div class="line">    quicksort(a,l,i-1);</div><div class="line">    quicksort(a,i+1,r);</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    int a[100];</div><div class="line">    for (int i=0;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;a[i];</div><div class="line">    &#125;</div><div class="line">    quicksort(a,0,n-1);</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">    cout&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想一下，若是我不想让a[l]当基准元素，还是想用[l~r]中的任意一个值作为基准元素，应该怎么改？</p>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="切换到插入排序"><a href="#切换到插入排序" class="headerlink" title="切换到插入排序"></a>切换到插入排序</h2><ol>
<li>对于小数组，快速排序比插入排序慢；</li>
<li>因为递归，快速排序的sort()方法在小数组中也会调用自己.<br>因此，在排序小数组时应该切换到插入排序.<br>将代码中的<br>if (l&gt;r) return;<br>改为<br>if (l&gt;r+M) {insertsort(a,l,r);return;}<br>转换参数M取决于系统的性能，但是5~15之间的任意值大多数情况下总会令人满意.<h2 id="三取样切分"><a href="#三取样切分" class="headerlink" title="三取样切分"></a>三取样切分</h2>若数据中会出现含有大量重复元素的数组，那么一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组，显然这样做是不必要的。<br>一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。<br>实现及原理和复杂度证明Todo<br>或详见《algorithms》快速排序一节.<br>对于含有大量重复元素的数组，它将排序时间从线性对数级别降低到了线性级别.</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Algorithms》</li>
<li><a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="external">坐在马桶上看算法：快速排序</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-8-归并排序]]></title>
      <url>http://blog.acbingo.cn/2015/11/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>昨天脱更了，今天又配置了一整天的 vim，罪过罪过。话说现在我已经因为 vim 爱上了 ubuntu<br>在写的时候突然想到了以前写的文章太 ACM 化了，缺少分析与深入，先从此篇开始尽量的提高点质量。<br><a id="more"></a><br>合并排序又称归并排序（英语：Merge sort，或 mergesort）。是创建在归并操作上的一种有效的排序算法，效率为 O(n log n)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。<br>没错，就是那个提出计算机体系结构的人，这个结构至今沿用。<br>顾名思义，归并排序就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。</p>
<p>归并排序的时间复杂度为O(nlgn)，相比较快速排序，归并排序是一种稳定排序。<br><img src="http://images.cnitblog.com/blog/94031/201401/270639583285360.png" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="http://images.cnitblog.com/blog/94031/201401/270639591417244.gif" alt=""><br>算法实现在wikipedia上给出了两种：</p>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3></li>
<li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li>
<li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li>
<li>重复步骤2，直到所有元素排序完毕</li>
</ol>
<hr>
<p>采用递归法更易理解且代码实现。但是迭代法更节省时间与空间消耗。<br>下面是自顶向下的归并排序，它通过递归的归并两个子数组进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-27 18:59</div><div class="line"> * Filename: mergesort.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int n;</div><div class="line">void merge(int *a,int l,int mid,int r)&#123;</div><div class="line">    //将a[l,mid]与a[mid+1,r]合并</div><div class="line">    int i=l,j=mid+1;</div><div class="line">    int aux[n];</div><div class="line">    for (int k=l;k&lt;=r;k++)</div><div class="line">        aux[k]=a[k];</div><div class="line">    for (int k=l;k&lt;=r;k++)&#123;</div><div class="line">        if (i&gt;mid) a[k]=aux[j++];//如果左半边用尽</div><div class="line">        else if (j&gt;r) a[k]=aux[i++];//右半边用尽</div><div class="line">        else if (aux[j]&lt;aux[i]) a[k]=aux[i++];//左边大</div><div class="line">        else a[k]=aux[j++];//右边大</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void sort(int *a,int l,int r)&#123;//对数组a的l到r（闭区间）区间进行（降序）排序</div><div class="line">    if (r&lt;=l) return ;</div><div class="line">    int mid=l+(r-l)/2;</div><div class="line">    sort(a,l,mid);//对左半部分排序</div><div class="line">    sort(a,mid+1,r);//对右半部分排序</div><div class="line">    merge(a,l,mid,r);//将已经有序的两个数组归并</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cout&lt;&lt;&quot;几个元素？&quot;&lt;&lt;endl;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    int a[n];</div><div class="line">    cout&lt;&lt;&quot;分别是:&quot;&lt;&lt;endl;</div><div class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">    sort(a,0,n-1);</div><div class="line">    for (int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">    cout&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="分析与理解"><a href="#分析与理解" class="headerlink" title="分析与理解"></a>分析与理解</h1><p>要理解归并排序最好仔细研究下递归栈的调用情况。<br><img src="http://images.cnitblog.com/blog/94031/201401/270639599534830.png" alt=""><br>也许你看不太懂这个图片，下面有个更易观察的树状图。<br><img src="http://images.cnitblog.com/blog/94031/201401/270640009226901.png" alt=""><br>该树的前三层我们称其为子数组的依赖树。<br>对其一般化，这颗依赖树有n层，对于0～n-1之间的任意k，自顶向下的第k层有2^k个子数组，每个数组的长度为2^n-k，归并最多需要进行2^n-k次比较。因此每层的比较次数为2^k<em>2^n-k=2^n，n层总共为n</em>2^n=NlgN。<br><img src="http://images.cnitblog.com/blog/94031/201401/270640031414555.png" alt=""><br>归并排序所需时间的NlgN成正比，这表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组进行排序，可以用归并排序处理数百万甚至更大规模的数组，这是插入排序等一些初级排序算法做不到的。<br>归并排序的主要缺点是辅助数组所使用的额外空间和N的大小成正比。在内存比较关心的环境可能需要采取其它算法。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>另外，我们还能通过一些更细致的思考大幅度的缩短归并排序的运行时间。</p>
<h2 id="对小规模数组使用插入排序"><a href="#对小规模数组使用插入排序" class="headerlink" title="对小规模数组使用插入排序"></a>对小规模数组使用插入排序</h2><p>因为递归会是小规模问题的调用过于频繁，所以用不同的方法处理小规模的问题能改进大多数的递归算法的性能。<br>有证明，使用插入排序处理小规模的子数组（比如长度小于15）一般可以将归并排序的运行时间缩短10%~15%</p>
<p>在代码的实现中只需将sort函数改进一下即可。<br>比如加条判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (mid-l&lt;=15) insert(a,l,mid);else sort(a,l,mid)；</div><div class="line">//right同理</div></pre></td></tr></table></figure></p>
<h2 id="测试数组是否已经有序"><a href="#测试数组是否已经有序" class="headerlink" title="测试数组是否已经有序"></a>测试数组是否已经有序</h2><p>如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序的并跳过merge()方法。这个改动不会影响排序的递归调用，但是任意 有序的子数组算法的运行时间就会变为线性的了。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>分治算法通常比较容易进行并行化,因为我们均分的左右两侧的序列是独立的，所以可以进行并行，值得注意的是，并行化也有一个阈值，当序列长度小于某个阈值的时候，停止并行化能够提高效率.<br>这些详细的讨论在<a href="http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html" target="_blank" rel="external">浅谈并发与并行</a>这篇文章中有详细的介绍</p>
<hr>
<p>合并排序和快速排序一样都是时间复杂度为nlgn的算法，但是和快速排序相比，合并排序是一种稳定性排序，也就是说排序关键字相等的两个元素在整个序列排序的前后，相对位置不会发生变化，这一特性使得合并排序是稳定性排序中效率最高的一个。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>wikipedia</li>
<li>Algorithems，4th Edition</li>
<li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Merge-Sort.html" target="_blank" rel="external">浅谈算法和数据结构</a></li>
<li>推荐一个国外的小网站，这个网站有关于各种排序的动态比较与演示动画<br><a href="http://www.sorting-algorithms.com/" target="_blank" rel="external">http://www.sorting-algorithms.com/</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-7-棋盘覆盖问题]]></title>
      <url>http://blog.acbingo.cn/2015/11/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>棋盘覆盖问题<br>在一个2k x 2k ( 即：2^k x 2^k )个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。<br><img src="http://acm.hunnu.edu.cn/online/images/10432.jpg" alt=""><br><a id="more"></a><br>尼玛写了半天告诉我同步失败，然而我在本地又没保存！！！<br>什么破快盘。。。<br>写的思路都找不到了，不想再写一遍了- -<br>大体上是利用分治的思想，将划分出来的4个小方格为一组进行递归，当递归到2*2的方格时，上色，回溯。（也可以直接递归到1×1的方格，这样代码相对来说会更简短点，懒得改了）<br>Node(left,right)表示一个方格，left为该方格的左上角坐标，right为该方格的右上角坐标。<br>应该有更好的方格表示方法，比如指定left以及方格的边长等等。<br>大家可以把我代码中注释掉的地方反注释掉，用来观察递归的调用步骤，从而能看到上色的过程。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-24 20:10</div><div class="line"> * Filename: 棋盘覆盖.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">using namespace std;</div><div class="line">char chessboard[10000][10000];</div><div class="line">int n,p,q,ch;</div><div class="line">struct Node&#123;</div><div class="line">    int x,y;</div><div class="line">&#125;;</div><div class="line">void print()&#123;</div><div class="line">    for (int i=0;i&lt;n;i++)&#123;</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            cout&lt;&lt;chessboard[i][j];</div><div class="line">        cout&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int draw(Node k,Node l,Node r)&#123;</div><div class="line">    if (r.x-l.x==1)&#123;</div><div class="line">        if (chessboard[l.x][l.y]==&apos;-&apos;) chessboard[l.x][l.y]=ch;</div><div class="line">        if (chessboard[r.x][r.y]==&apos;-&apos;) chessboard[r.x][r.y]=ch;</div><div class="line">        if (chessboard[l.x][l.y+1]==&apos;-&apos;) chessboard[l.x][l.y+1]=ch;</div><div class="line">        if (chessboard[l.x+1][l.y]==&apos;-&apos;) chessboard[l.x+1][l.y]=ch;</div><div class="line">        ch++;if (ch&gt;&apos;Z&apos;) ch=&apos;A&apos;;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    int x=(r.x-l.x+1)/2+l.x;</div><div class="line">    int y=(r.y-l.y+1)/2+l.y;</div><div class="line">    int t=0;</div><div class="line">    if (k.y&lt;y)&#123;</div><div class="line">        if(k.x&lt;x)&#123;</div><div class="line">            chessboard[x][y]=ch;</div><div class="line">            chessboard[x-1][y]=ch;</div><div class="line">            chessboard[x][y-1]=ch;</div><div class="line">            t=1;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            chessboard[x][y]=ch;</div><div class="line">            chessboard[x-1][y-1]=ch;</div><div class="line">            chessboard[x-1][y]=ch;</div><div class="line">            t=2;</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (k.x&lt;x)&#123;</div><div class="line">            chessboard[x][y]=ch;</div><div class="line">            chessboard[x-1][y-1]=ch;</div><div class="line">            chessboard[x][y-1]=ch;</div><div class="line">            t=3;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            chessboard[x][y-1]=ch;</div><div class="line">            chessboard[x-1][y-1]=ch;</div><div class="line">            chessboard[x-1][y]=ch;</div><div class="line">            t=4;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ch++;if (ch&gt;&apos;Z&apos;) ch=&apos;A&apos;;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line">void fun(Node k,Node l,Node r)&#123;</div><div class="line">    //int ttt;cin&gt;&gt;ttt;</div><div class="line">    //print();</div><div class="line">    int x=(r.x-l.x+1)/2+l.x;</div><div class="line">    int y=(r.y-l.y+1)/2+l.y;</div><div class="line">    Node a,b,c,d,t1,t2,t3,t4;</div><div class="line">    a.x=x-1;a.y=y-1;</div><div class="line">    b.x=x-1;b.y=y;</div><div class="line">    c.x=x;c.y=y-1;</div><div class="line">    d.x=x;d.y=y;</div><div class="line">    t1.x=l.x;t1.y=y;</div><div class="line">    t2.x=x-1;t2.y=r.y;</div><div class="line">    t3.x=x;t3.y=l.y;</div><div class="line">    t4.x=r.x;t4.y=y-1;</div><div class="line">    if (1)&#123;</div><div class="line">        int t=draw(k,l,r);</div><div class="line">        if (t==0) return;</div><div class="line">        if (t==1)&#123;</div><div class="line">            fun(k,l,a);</div><div class="line">            fun(b,t1,t2);</div><div class="line">            fun(c,t3,t4);</div><div class="line">            fun(d,d,r);</div><div class="line">            return ;</div><div class="line">        &#125;else if (t==2)&#123;</div><div class="line">            fun(a,l,a);</div><div class="line">            fun(k,t1,t2);</div><div class="line">            fun(c,t3,t4);</div><div class="line">            fun(d,d,r);</div><div class="line">            return ;</div><div class="line">        &#125;else if (t==3)&#123;</div><div class="line">            fun(a,l,a);</div><div class="line">            fun(b,t1,t2);</div><div class="line">            fun(k,t3,t4);</div><div class="line">            fun(d,d,r);</div><div class="line">            return;</div><div class="line">        &#125;else if (t==4)&#123;</div><div class="line">            fun(a,l,a);</div><div class="line">            fun(b,t1,t2);</div><div class="line">            fun(c,t3,t4);</div><div class="line">            fun(k,d,r);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    cout&lt;&lt;&quot;请输入棋盘的规模K(棋盘总大小为2^k),k不要过大哦，虽然理论上最大支持10000*10000的棋盘= =&quot;&lt;&lt;endl;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    cout&lt;&lt;&quot;特殊方格的坐标:&quot;&lt;&lt;endl;</div><div class="line">    cin&gt;&gt;p&gt;&gt;q;</div><div class="line">    n=pow(2,n);</div><div class="line">    ch=&apos;A&apos;;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            chessboard[i][j]=&apos;-&apos;;</div><div class="line">    chessboard[p][q]=&apos;#&apos;;</div><div class="line">    Node a,left,right;</div><div class="line">    a.x=p;a.y=q;left.x=0;left.y=0;right.x=n-1;right.y=n-1;</div><div class="line">    fun(a,left,right);</div><div class="line">    for (int i=0;i&lt;n;i++)&#123;</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            cout&lt;&lt;chessboard[i][j];</div><div class="line">        cout&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-6-Strassen矩阵乘法]]></title>
      <url>http://blog.acbingo.cn/2015/11/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>请编程实现矩阵乘法，并考虑当矩阵规模较大时的优化方法。<br><a id="more"></a></p>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><p>wikipedia上是这么说的:</p>
<blockquote>
<p>两个矩阵的乘法仅当第一个矩阵B的列数和另一个矩阵A的行数相等时才能定义。如A是m×n矩阵和B是n×p矩阵，它们的乘积AB是一个m×p矩阵，它的一个元素其中 1 ≤ i ≤ m, 1 ≤ j ≤ p。</p>
</blockquote>
<p>引用<a href="http://blog.csdn.net/v_july_v/article/details/18824517" target="_blank" rel="external">july</a>大神的图片<br><img src="http://img.blog.csdn.net/20140128134632406" alt=""></p>
<p>注意，矩阵乘法满足结合律和分配率，但是不满足交换律。</p>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>根据定义，我们可以直接暴力写出算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-23 21:09</div><div class="line"> * Filename: matrix_mul.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Matrix&#123;</div><div class="line">    private:</div><div class="line">        int x,y;</div><div class="line">    public: </div><div class="line">        int **data;</div><div class="line">        Matrix()&#123;&#125;</div><div class="line">        Matrix(int x,int y)&#123;</div><div class="line">            this-&gt;x=x;this-&gt;y=y;</div><div class="line">            data=new int*[x];</div><div class="line">            for (int i=0;i&lt;x;i++)</div><div class="line">                data[i]=new int[y];</div><div class="line">        &#125;</div><div class="line">        Matrix (const Matrix &amp;tmp)&#123;</div><div class="line">            if (tmp.data)&#123;</div><div class="line">                x=tmp.x;</div><div class="line">                y=tmp.y;</div><div class="line">                data=new int*[x];</div><div class="line">                for (int i=0;i&lt;x;i++)</div><div class="line">                    data[i]=new int [y];</div><div class="line">                for (int i=0;i&lt;x;i++)</div><div class="line">                    for (int j=0;j&lt;y;j++)</div><div class="line">                        data[i][j]=tmp.data[i][j];</div><div class="line">            &#125; else &#123;</div><div class="line">                x=tmp.x;y=tmp.y;data=NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Matrix&amp; operator=(const Matrix &amp;tmp)&#123;</div><div class="line">            if (tmp.data)&#123;</div><div class="line">                x=tmp.x;</div><div class="line">                y=tmp.y;</div><div class="line">                data=new int*[x];</div><div class="line">                for (int i=0;i&lt;x;i++)</div><div class="line">                    data[i]=new int [y];</div><div class="line">                for (int i=0;i&lt;x;i++)</div><div class="line">                    for (int j=0;j&lt;y;j++)</div><div class="line">                        data[i][j]=tmp.data[i][j];</div><div class="line">            &#125; else &#123;</div><div class="line">                x=tmp.x;y=tmp.y;data=NULL;</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">        ~Matrix()&#123;</div><div class="line">            delete []data;</div><div class="line">        &#125;</div><div class="line">        void init()&#123;</div><div class="line">            cout&lt;&lt;&quot;现在请输入&quot;&lt;&lt;x&lt;&lt;&quot;行&quot;&lt;&lt;y&lt;&lt;&quot;列矩阵&quot;&lt;&lt;endl;</div><div class="line">            for (int i=0;i&lt;x;i++)</div><div class="line">                for (int j=0;j&lt;y;j++)</div><div class="line">                    cin&gt;&gt;data[i][j];</div><div class="line">        &#125;</div><div class="line">        void print()&#123;</div><div class="line">            for (int i=0;i&lt;x;i++)&#123;</div><div class="line">                for (int j=0;j&lt;y;j++)&#123;</div><div class="line">                    cout&lt;&lt;&quot; &quot;&lt;&lt;data[i][j];</div><div class="line">                &#125;</div><div class="line">                cout&lt;&lt;endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        friend Matrix Matrix_Mul(Matrix &amp;a,Matrix &amp;b);</div><div class="line">&#125;;</div><div class="line">Matrix Matrix_Mul(Matrix &amp;a,Matrix &amp;b)&#123;</div><div class="line">    Matrix c(a.x,b.y);</div><div class="line">    for (int i=0;i&lt;a.x;i++)</div><div class="line">        for (int j=0;j&lt;b.y;j++)&#123;</div><div class="line">            c.data[i][j]=0;</div><div class="line">            for (int k=0;k&lt;a.y;k++)</div><div class="line">                c.data[i][j]+=a.data[i][k]*b.data[k][j];</div><div class="line">        &#125;</div><div class="line">    return c;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    Matrix A(2,2),B(2,2);</div><div class="line">    A.init();B.init();</div><div class="line">    Matrix c(2,2);</div><div class="line">    c=Matrix_Mul(A,B);</div><div class="line">    c.print();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顺手写了个矩阵类。<br>注意，由于我是使用的new运算符动态申请的内存，系统的默认拷贝函数是不会自动帮我申请内存。所以需要处理深拷贝的问题，重载拷贝函数以及=号来实现深拷贝。<br>这里有一篇解释深拷贝的文章：<a href="http://blog.csdn.net/lwbeyond/article/details/6202256" target="_blank" rel="external">http://blog.csdn.net/lwbeyond/article/details/6202256</a><br>本来想用Template的，但是，在写拷贝构造函数的时候c艹无论如何也不会调用模板类的拷贝构造函数，也就是说只会调用默认的构造函数。</p>
<blockquote>
<p>类（包括模板类）构造函数是真实的构造函数；然而模板构造函数，其实质是模板函数。两者不能混为一谈。在一个模板类中，构造函数和模板构造函数同时存在时，优先调用构造函数。只有当确切符合模板构造函数的接口时，才调用模板构造函数。编译器永远不会把模板构造函数视为构造函数，即使客户没有自己定义拷贝构造函数，编译器也会生成一个默认的拷贝构造函数，这种情况同样存在于拷贝赋值函数和模板拷贝赋值函数。请看下面的例子：</p>
<p>#include <iostream><br>using namespace std;<br>template <typename t=""><br>class TempClass{<br>public:<br>    T d;<br>    //两个构造函数，其中第二个是拷贝构造函数<br>    TempClass<t>(T _d=0):d(_d){cout&lt;&lt;”This is TempClass Constructor1. “&lt;<endl;}; tempclass<t="">(TempClass<t> &amp;_tmp):d(_tmp.d){cout&lt;&lt;”This is TempClass Constructor2. “&lt;&lt;endl;}; </t></endl;};></t></typename></iostream></p>
</blockquote>
<pre><code>template &lt;typename O&gt; //模板构造函数 
TempClass&lt;T&gt;(TempClass&lt;O&gt; &amp;_tmp):d(_tmp.d){cout&lt;&lt;&quot;This is a template constructor, not a TempClass Constructor.&quot;&lt;&lt;endl;}; 
</code></pre><p>};<br>int main()<br>{<br>    TempClass<int> a;<br>    TempClass<int> b(a); //调用拷贝构造函数，即使在该模板类中用户没有自定义该函数，编译器也会生成一个默认拷贝构造函数。因为编译器永远不会认为一个模板构造函数是一个构造函数 </int></int></p>
<pre><code>TempClass&lt;double&gt; c(a); //调用模板拷贝构造函数 

return 0; 
</code></pre><p>}<br>输出结果是： </p>
<blockquote>
<p>This is TempClass Constructor1.<br>This is TempClass Constructor2.<br>This is a template constructor, not a TempClass Constructor.<br>PS：具体可以参考《Exceptional C++》之Item5 </p>
</blockquote>
<p>还有</p>
<blockquote>
<p>昨天看《Exceptional C++》，发现一个从来没有注意到标准（C++ 标准 12.8/2，note 4）：“模板构造函数永远都不能成为拷贝构造函数”。所以模板构造函数永远不能取代拷贝构造函数，即便有了模板构造函数，默认拷贝构造函数还是会合成的。<br>　　例如：<br>class A<br>{<br>public:<br>  // 这个构造函数不会掩盖默认拷贝构造函数<br>  template <t><br>  A (const T&amp; t) {}<br>};<br>　　同样的情况对于 operator=() 一样适合。也就是模板赋值函数不会覆盖默认拷贝赋值函数。<br>[美] Sutter, Hurb 著；聂雪军 译。《Exceptional C++ 中文版》。北京：机械工业出版社，2007 年 1 月第 1 版。第 11 页。</t></p>
</blockquote>
<p>坑不浅啊T T</p>
<h1 id="Strassen算法"><a href="#Strassen算法" class="headerlink" title="Strassen算法"></a>Strassen算法</h1><p>暴力解法中我们用3个循环解决，O(N^3)的时间复杂度并不理想。<br>一般说来，当数据量一大时，我们往往会把大的数据分割成小的数据，各个分别处理。遵此思路，如果丢给我们一个很大的两个矩阵呢，是否可以考虑分治的方法循序渐进处理各个小矩阵的相乘，因为我们知道一个矩阵是可以分成更多小的矩阵的。</p>
<p>如下图，当给定一个两个二维矩阵A B时：<br><img src="http://img.blog.csdn.net/20140128142718718" alt=""><br><img src="http://img.blog.csdn.net/20140128143128421" alt=""><br>矩阵乘法的复杂度主要就是体现在相乘上，而多一两次的加法并不会让复杂度上升太多。故此，我们思考，是否可以让矩阵乘法的运算过程中乘法的运算次数减少，从而达到降低矩阵乘法的复杂度呢？答案是肯定的。<br>1969年，德国的一位数学家Strassen证明O（N^3）的解法并不是矩阵乘法的最优算法，他做了一系列工作使得最终的时间复杂度降低到了O(n^2.80)。<br>他是怎么做到的呢？还是用上文A B两个矩阵相乘的例子，他定义了7个变量：<br><img src="http://img.blog.csdn.net/20140128144343843" alt=""><br>如此，Strassen算法的流程如下：</p>
<p>两个矩阵A B相乘时，将A, B, C分成相等大小的方块矩阵：<br><img src="http://img.blog.csdn.net/20140128145552375" alt=""><br>可以看出C是这么得来的：<br><img src="http://img.blog.csdn.net/20140128170746937" alt=""><br>现在定义7个新矩阵（读者可以思考下，这7个新矩阵是如何想到的）：<br><img src="http://img.blog.csdn.net/20140128145910500" alt=""><br>而最后的结果矩阵C 可以通过组合上述7个新矩阵得到：<br><img src="http://img.blog.csdn.net/20140128150240046" alt=""><br>表面上看，Strassen算法仅仅比通用矩阵相乘算法好一点，因为通用矩阵相乘算法时间复杂度是，而Strassen算法复杂度只是。但随着n的变大，比如当n &gt;&gt; 100时，Strassen算法是比通用矩阵相乘算法变得更有效率。</p>
<p>如下图所示：<br><img src="http://img.blog.csdn.net/20140128144552500" alt=""></p>
<h1 id="持续优化"><a href="#持续优化" class="headerlink" title="持续优化"></a>持续优化</h1><p>根据wikipedia上的介绍，后来，Coppersmith–Winograd 算法把 N* N大小的矩阵乘法的时间复杂度降低到了O(n^2.375477)：，而2010年，Andrew Stothers再度把复杂度降低到了O(N^2.3736)，一年后的2011年，Virginia Williams把复杂度最终定格为O(N^2.3727)</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="http://zh.wikipedia.org/wiki/%E6%96%BD%E7%89%B9%E6%8B%89%E6%A3%AE%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">wikipedia上关于Strassen算法的介绍</a></li>
<li>Strassen算法的大部分图文来自(july大神)(<a href="http://blog.csdn.net/v_july_v/article/details/18824517" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/18824517</a>)</li>
</ol>
<p>july大神出书了，佩服&amp;感叹啊。另外，欢迎大家购买july大神的新书《编程之法》，质量很高而且不贵。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-5-Hanoi塔问题]]></title>
      <url>http://blog.acbingo.cn/2015/11/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Hanoi%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Hanoi塔问题的讨论<br><a id="more"></a><br>Hanoi塔问题可以说是递归这一节最经典的问题，几乎没有一本书上的递归章节不拿这个当例子的。。。</p>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>现在有三根相邻的柱子，标号为A,B,C，A柱子上从下到上按金字塔状叠放着n个不同大小的圆盘，现在把所有盘子一个一个移动到柱子C上，并且每次移动同一根柱子上都不能出现大盘子在小盘子上方，请问至少需要多少次移动</p>
<p>如果只有一个盘子，则不需要利用B座，直接将盘子从A移动到C。<br>如果有2个盘子，可以先将盘子1上的盘子2移动到B；将盘子1移动到c；将盘子2移动到c。这说明了：可以借助B将2个盘子从A移动到C，当然，也可以借助C将2个盘子从A移动到B。<br>如果有3个盘子，那么根据2个盘子的结论，可以借助c将盘子1上的两个盘子从A移动到B；将盘子1从A移动到C，A变成空座；借助A座，将B上的两个盘子移动到C。这说明：可以借助一个空座，将3个盘子从一个座移动到另一个。<br>如果有4个盘子，那么首先借助空座C，将盘子1上的三个盘子从A移动到B；将盘子1移动到C，A变成空座；借助空座A，将B座上的三个盘子移动到C。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-22 16:48</div><div class="line"> * Filename: hanoi.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">void move(int i,char x,char y)&#123;</div><div class="line">    static int t=1;</div><div class="line">    cout&lt;&lt;&quot;Step &quot;&lt;&lt;t++&lt;&lt;&quot;:Move &quot;&lt;&lt;i&lt;&lt;&quot; to &quot;&lt;&lt;y&lt;&lt;&quot; which is from &quot;&lt;&lt;x&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">void hanoi(int n,char a,char b,char c)&#123;</div><div class="line">    if (n)&#123;</div><div class="line">        hanoi(n-1,a,c,b);</div><div class="line">        move(n-1,a,c);</div><div class="line">        hanoi(n-1,c,b,a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    hanoi(n,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般的，当一个算法可以构成嵌套调用的时候，往往可以采用递归，将问题划分。<br>但要想清楚递归退出（边界）的条件，以免造成死循环。<br>但是，递归的运行效率很低，耗费空间与时间用来建递归所需的栈有时候并不划算啊。复杂一些算法还是采用更优的结构比较好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-4-整数划分问题]]></title>
      <url>http://blog.acbingo.cn/2015/11/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>整数划分问题<br><a id="more"></a></p>
<h1 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h1><h2 id="什么是整数划分"><a href="#什么是整数划分" class="headerlink" title="什么是整数划分"></a>什么是整数划分</h2><blockquote>
<p>指把一个正整数n写成多个大于等于1且小于等于其本身的整数的和，则其中各加数所构成的集合为n的一个划分。</p>
<ol>
<li>n=m1+m2+…+mi; （其中mi为正整数，并且1 &lt;= mi &lt;= n），则{m1,m2,…,mi}为n的一个划分。</li>
<li>如果{m1,m2,…,mi}中的最大值不超过m，即max(m1,m2,…,mi)&lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);</li>
<li>举个例子，当n=5时我们可以获得以下这几种划分（注意，例子中m&gt;=5）<br>5 = 5<br>= 4 + 1<br>= 3 + 2<br>= 3 + 1 + 1<br>= 2 + 2 + 1<br>= 2 + 1 + 1 + 1<br>= 1 + 1 + 1 + 1 + 1</li>
</ol>
</blockquote>
<!--more-->
<h2 id="递归or动态规划解法"><a href="#递归or动态规划解法" class="headerlink" title="递归or动态规划解法"></a>递归or动态规划解法</h2><p>根据n和m的关系，考虑以下几种情况： </p>
<ol>
<li>当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; </li>
<li>当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1}; </li>
<li>当n=m时，根据划分中是否包含n，可以分为两种情况：<br> (1) 划分中包含n的情况，只有一个即{n}；<br> (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); </li>
<li>当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); </li>
<li>但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况：<br> (1) 划分中包含m的情况，即{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m);<br> (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</li>
</ol>
<p>综合以上情况，我们可以看出，上面的结论具有递归定义特征，其中（1）和（2）属于回归条件，（3）和（4）属于特殊情况，将会转换为情况（5）。而情况（5）为通用情况，属于递推的方法，其本质主要是通过减小m以达到回归条件，从而解决问题。其递推表达式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f(n, m) =   1;                               ( n = 1 or m = 1 )</div><div class="line">            f(n, n);                         ( n &lt; m )</div><div class="line">            1+ f(n, m - 1);                  ( n = m )</div><div class="line">            f(n - m, m) + f(n, m - 1);       ( n &gt; m )</div></pre></td></tr></table></figure></p>
<p>代码如下</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;
int equationCount(int n,int m)
{
    if(n==1||m==1)
        return 1;
    else if(n&lt;m)
        return equationCount(n,n);
    else if(n==m)
        return 1+equationCount(n,n-1);
    else
        return equationCount(n,m-1)+equationCount(n-m,m);
}

int main(void)
{
    int n;
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF&amp;&amp;(n&gt;=1&amp;&amp;n&lt;=120))
    {
        printf(&quot;%d\n&quot;,equationCount(n,n));
    }
    return 0;
}
</code></pre><h1 id="问题的变种"><a href="#问题的变种" class="headerlink" title="问题的变种"></a>问题的变种</h1><h2 id="要求1-2-3-4-m中每个数只允许使用一次的时？"><a href="#要求1-2-3-4-m中每个数只允许使用一次的时？" class="headerlink" title="要求1,2,3,4..,m中每个数只允许使用一次的时？"></a>要求1,2,3,4..,m中每个数只允许使用一次的时？</h2><p>Todo</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-3-排列问题]]></title>
      <url>http://blog.acbingo.cn/2015/11/19/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>设R={r1,r2,……,rn}是要进行排列的n个元素，Ri=R-{ri}。集合x中元素的全排列记为Perm(X).(ri)Perm(X)表示在全排列Perm(X)的每一个排列前加上前缀ri得到的排列。R的全排列可归纳定义如下：<br>当N=1时，Perm(R)=(r),其中r是集合R中唯一的元素;<br>当N&gt;1时，Perm(R)由(r1)Perm(R1),(r2)Perm(R2),……,(rn)Perm(Rn)构成。<br><a id="more"></a><br>todo<br>题都没看到撒= =</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-2-递归的概念]]></title>
      <url>http://blog.acbingo.cn/2015/11/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%80%92%E5%BD%92%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>阶乘函数、Fibonacci数列、Ackerman函数<br><a id="more"></a><br>本来想用Mathjax实现公式的输入的= =，尝试了半天，没成功，算了，以后再说吧</p>
<h1 id="阶乘函数"><a href="#阶乘函数" class="headerlink" title="阶乘函数"></a>阶乘函数</h1><p>利用函数实现阶乘，没啥好说的。来遍代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-22 11:18</div><div class="line"> * Filename: t.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int factorial(int n)&#123;</div><div class="line">    if (n==0) return 1;</div><div class="line">    return n*factorial(n-1);</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    cout&lt;&lt;factorial(n)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h1><p>无穷数列1,1,2,3,5,8,12,34……成为Fibonacci数列，其第n项的值为前两项之和<br>朴素求法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-22 11:18</div><div class="line"> * Filename: t.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int fibonacci(int n)&#123;</div><div class="line">    if (n&lt;=1) return 1;</div><div class="line">    return fibonacci(n-1)+fibonacci(n-2);</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    cout&lt;&lt;&quot;第&quot;&lt;&lt;n&lt;&lt;&quot;个Fibonacci数是&quot;&lt;&lt;fibonacci(n)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ACM中关于fibonacci的有很多有趣的题目，大部分的题目用朴素的方法求值是不可行的。有的还需要用到高精度来存数。以后碰到了另谈。</p>
<h1 id="Ackerman函数"><a href="#Ackerman函数" class="headerlink" title="Ackerman函数"></a>Ackerman函数</h1><p>这个函数还是第一次碰到。<br>这是一个双递归函数。<br><a href="http://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8" target="_blank" rel="external">在wikipedia上的解释</a><br>阿克曼函数是非原始递归函数的例子；它需要两个自然数作为输入值，输出一个自然数。它的输出值增长速度非常高，仅是(4,3)的输出已大得不能准确计算。</p>
<p>1920年代后期，数学家大卫·希尔伯特的学生Gabriel Sudan和威廉·阿克曼，当时正研究计算的基础。Sudan发明了一个递归却非原始递归的Sudan函数。1928年，阿克曼又独立想出了另一个递归却非原始递归的函数。他最初的念头是一个三个变量的函数A(m,n,p)，使用康威链式箭号表示法是m→n→p。阿克曼证明了它是递归函数。希尔伯特在On the Infinite猜想这个函数不是原始递归。阿克曼在On Hilbert’s Construction of the Real Numbers证明了这点。后来Rozsa Peter和Raphael Robinson定义了一个类似的函数，但只用两个变量。</p>
<p>定义：</p>
<pre><code>{ n+1;                       m=0,n&gt;0
</code></pre><p>  A(m,n) = { A(m-1,1);                  n=0,m&gt;0<br>           { A(m-1,A(m,n-1))            n&gt;0,m&gt;0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author: Bingo</div><div class="line"> * Created Time: 2015-11-22 11:18</div><div class="line"> * Filename: t.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int factorial(int n)&#123;</div><div class="line">    if (n==0) return 1;</div><div class="line">    return n*factorial(n-1);</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    cout&lt;&lt;factorial(n)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera_标准模板库STL]]></title>
      <url>http://blog.acbingo.cn/2015/11/17/coursera_%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/</url>
      <content type="html"><![CDATA[<p>STL<br><a id="more"></a><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ey42t7by0cj30qx0emabf.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey43yd642qj30qs0etwfa.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey43zvgi1pj30qt0esmy5.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey441ky7euj30qm0ep75e.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey6j7l4uktj30rd0f7dgw.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6ja220u9j30rf0e2gm9.jpg" alt=""><br>关联容器<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6jalg2nlj30r80fj769.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6je85phbj30qz0exq3y.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ey6jflk0wuj30rl0fkgm9.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey6jfvs5wvj30re0ey3yz.jpg" alt=""></p>
<p>成员函数<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey6ji7459bj30qq0f5myk.jpg" alt=""><br>end是指向最后一个元素<strong>后面</strong>的位置<br>同理，rend也是</p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6jjsqe2ej30ql0exdh4.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey6jlbfuxij30r00f73zd.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey6jln3zf9j30qr0epaau.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey6jmqs1xdj30qv0faq3u.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ey6jnmh0vcj30r20f3wfm.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ey6jorgajjj30ql0eywfe.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey6jqh9u9mj30rg0ej0tl.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6jroilzrj30qv0eq3zm.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey6k4owuuqj30rd0f7mxw.jpg" alt=""><br>随机访问迭代器<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ey6k7rzuk9j30qy0f7my8.jpg" alt=""><br>双向访问迭代器<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ey6k90imyrj30qf0ekaav.jpg" alt=""></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey6k9p21e1j30r70ehtad.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ey7otmytzsj30qw0ehq4b.jpg" alt=""><br>大小的概念可以自定义<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ey7ozxox98j30rm0ev3zo.jpg" alt=""></p>
<p>注意，有时候相等的概念有点特殊：<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f057revyzkj30qy0ergo8.jpg" alt=""><br>下面相等的概念演示:<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1f057t0lz9uj30qu0f1acg.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1f057tca131j30qs0ez40f.jpg" alt=""><br>==号并没有被调用，只是调用了&lt;号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-0-序]]></title>
      <url>http://blog.acbingo.cn/2015/11/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-0-%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>我也不知道用序这个字当标题合不合适= =<br>这里是对我们正在学的一本书《计算机算法设计与分析-第4版-王晓东》里面提到的每一种算法进行详细的分析与实现。没错，我就是认为我们老师讲的太差了= =。<br>争取每天一篇高质量的博文，一篇博文写一种算法。不知道能不能在课程结束的时候写完。<br><a id="more"></a><br>有时候某种算法比较复杂的时候保证三天两篇。<br>对发出来的每一种算法，做到理解，掌握，并能独立的用代码实现出来。<br>精力有限的话，对算法做一些课程以外的拓展。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法学习笔记-1-NP完全性理论]]></title>
      <url>http://blog.acbingo.cn/2015/11/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-NP%E5%AE%8C%E5%85%A8%E6%80%A7%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>第一章，算法概述。主要写一下对NP完全性理论的见解。<br><a id="more"></a></p>
<h1 id="多项式时间"><a href="#多项式时间" class="headerlink" title="多项式时间"></a>多项式时间</h1><p>在计算复杂度理论中，指的是一个问题的计算时间m(n)不大于问题大小n的多项式倍数。通俗点来说，多项式时间就是指时间复杂度是个多项式，或者说,就是这个程序运行的时间随着数据规模n变化的函数为f(n)，那么,f(n)是个多项式函数,那么就可以说是控制在多项式之内。举个例子，现在从n阶图中找两点的最短路径，复杂度为n^2级别（即O(n^2)，O是大写欧），而n^2对于n是多项式（单项式当然也算），这就称为是多项式复杂度，或者多项式时间，其中问题（算法）的规模是n。如果某一个算法的规模是n，但是复杂度比如是2^n，写不成n的多项式，那就不是多项式时间。</p>
<h1 id="p类问题"><a href="#p类问题" class="headerlink" title="p类问题"></a>p类问题</h1><p>所有可以在多项式时间内求解的判定问题构成P类问题。</p>
<h1 id="判断问题"><a href="#判断问题" class="headerlink" title="判断问题"></a>判断问题</h1><p>判定问题：判断是否有一种能够解决某一类问题的能行算法的研究课题。</p>
<h1 id="NP类问题："><a href="#NP类问题：" class="headerlink" title="NP类问题："></a>NP类问题：</h1><p>所有的非确定性多项式时间可解的判定问题构成NP类问题。非确定性算法：非确定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。设算法A是解一个判定问题Q的非确定性算法，如果A的验证阶段能在多项式时间内完成，则称A是一个多项式时间非确定性算法。有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大质数的问题。有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的。再比如，大的合数分解质因数的问题，有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式。这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是非确定性问题。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式（polynomial）时间内算出来，就叫做多项式非确定性问题。<br><img src="http://img.my.csdn.net/uploads/201301/07/1357527069_5610.jpg" alt=""><img src="http://img.my.csdn.net/uploads/201301/07/1357527069_5610.jpg" alt=""></p>
<h1 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h1><p>NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。</p>
<blockquote>
<p>P类问题，NP类问题，NPC之间的关系可有下图（此图正确性有待证明）表示：</p>
</blockquote>
<p><img src="http://img.my.csdn.net/uploads/201301/07/1357528786_9409.jpg" alt=""><br>是可以在多项式时间内解决的，polynomial problem。<br>NP类问题，可以在多项式的时间里验证一个解的问题，non deterministic polynomial<br>NPC问题，最不可能转换为p决定的问题的集合，np complete </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文件操作和模板_编程作业]]></title>
      <url>http://blog.acbingo.cn/2015/11/14/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF_%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>实现一个三维数组模版CArray3D，可以用来生成元素为任意类型变量的三维数组，使得下面程序输出结果是：</p>
<p>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,</p>
<p>注意，只能写一个类模版，不能写多个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    CArray3D&lt;int&gt; a(3,4,5);</div><div class="line">    int No = 0;</div><div class="line">    for( int i = 0; i &lt; 3; ++ i )</div><div class="line">        for( int j = 0; j &lt; 4; ++j )</div><div class="line">            for( int k = 0; k &lt; 5; ++k )</div><div class="line">                a[i][j][k] = No ++;</div><div class="line">    for( int i = 0; i &lt; 3; ++ i )</div><div class="line">        for( int j = 0; j &lt; 4; ++j )</div><div class="line">            for( int k = 0; k &lt; 5; ++k )</div><div class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; &quot;,&quot;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>无</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,</p>
<h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><p>无</p>
<h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><p>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>提示：类里面可以定义类，类模版里面也可以定义类模版。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">    class B &#123;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template </div><div class="line">class S</div><div class="line">&#123;</div><div class="line">    T x;</div><div class="line">    class K &#123;</div><div class="line">        T a;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题一开始没有看到提示，一看到三维的数组，想半天，这尼玛怎么实现啊。。。<br>看到提示后，奥，还阔以这样~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">中括号的本质不就是指针嘛，比如p[i],就是*(p+i)</div><div class="line">p[i][j]就是*(*(p+i)+j)</div><div class="line">以此类推。。。</div></pre></td></tr></table></figure></p>
<p>一层一层的往下就行。<br>由于只用到了一个模板参数，所以只需对最外面的模板使用类模板即可，CArray2D和CArray3D则不必，省得跟网上一样绕来绕去把自己绕晕了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">class CArray3D&#123;</div><div class="line">    public:</div><div class="line">        class CArray2D&#123;</div><div class="line">            public:</div><div class="line">                class CArray1D&#123;</div><div class="line">                    private:</div><div class="line">                        T *p;</div><div class="line">                    public:</div><div class="line">                        CArray1D():p(NULL)&#123;&#125;</div><div class="line">                        void init(int c)&#123;</div><div class="line">                            p=new T[c];</div><div class="line">                        &#125;</div><div class="line">                        T &amp; operator[](int k)&#123;</div><div class="line">                            return p[k];</div><div class="line">                        &#125;</div><div class="line">                        ~CArray1D()&#123;</div><div class="line">                            delete []p;</div><div class="line">                        &#125;</div><div class="line">                &#125;;</div><div class="line">                CArray2D():p(NULL)&#123;&#125;</div><div class="line">                void init(int b,int c)&#123;</div><div class="line">                    p=new CArray1D[b];</div><div class="line">                    for (int i=0;i&lt;b;i++)&#123;</div><div class="line">                        p[i].init(c);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                CArray1D &amp;operator[](int k)&#123;</div><div class="line">                    return p[k];</div><div class="line">                &#125;</div><div class="line">                ~CArray2D()&#123;</div><div class="line">                    delete []p;</div><div class="line">                &#125;</div><div class="line">            private:</div><div class="line">                CArray1D *p;</div><div class="line">                T _b;</div><div class="line">        &#125;;</div><div class="line">        CArray3D():p(NULL)&#123;&#125;</div><div class="line">        CArray3D(T a,T b,T c)&#123;</div><div class="line">            p=new CArray2D[a];</div><div class="line">            for (int i=0;i&lt;a;i++)&#123;</div><div class="line">                p[i].init(b,c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        CArray2D &amp;operator[](int k) const&#123;</div><div class="line">            return p[k];</div><div class="line">        &#125;</div><div class="line">        ~CArray3D()&#123;</div><div class="line">            delete []p;</div><div class="line">        &#125;</div><div class="line">    private:</div><div class="line">        CArray2D *p;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    CArray3D&lt;int&gt; a(3,4,5);</div><div class="line">    int No = 0;</div><div class="line">    for( int i = 0; i &lt; 3; ++ i )</div><div class="line">        for( int j = 0; j &lt; 4; ++j )</div><div class="line">            for( int k = 0; k &lt; 5; ++k )</div><div class="line">                a[i][j][k] = No ++;</div><div class="line">    for( int i = 0; i &lt; 3; ++ i )</div><div class="line">        for( int j = 0; j &lt; 4; ++j )</div><div class="line">            for( int k = 0; k &lt; 5; ++k )</div><div class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; &quot;,&quot;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃4：-字符串操作"><a href="#编程题＃4：-字符串操作" class="headerlink" title="编程题＃4： 字符串操作"></a>编程题＃4： 字符串操作</h1><h1 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h1><p>给定n个字符串（从1开始编号），每个字符串中的字符位置从0开始编号，长度为1-500，现有如下若干操作：<br>copy N X L：取出第N个字符串第X个字符开始的长度为L的字符串。<br>add S1 S2：判断S1，S2是否为0-99999之间的整数，若是则将其转化为整数做加法，若不是，则作字符串加法，返回的值为一字符串。<br>find S N：在第N个字符串中从左开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。<br>rfind S N：在第N个字符串中从右开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。<br>insert S N X：在第N个字符串的第X个字符位置中插入S字符串。<br>reset S N：将第N个字符串变为S。<br>print N：打印输出第N个字符串。<br>printall：打印输出所有字符串。<br>over：结束操作。<br>其中N，X，L可由find与rfind操作表达式构成，S，S1，S2可由copy与add操作表达式构成。</p>
<h1 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h1><p>第一行为一个整数n（n在1-20之间）<br>接下来n行为n个字符串，字符串不包含空格及操作命令等。<br>接下来若干行为一系列操作，直到over结束。</p>
<h1 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h1><p>根据操作提示输出对应字符串。</p>
<h1 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h1><p>3<br>329strjvc<br>Opadfk48<br>Ifjoqwoqejr<br>insert copy 1 find 2 1 2 2 2<br>print 2<br>reset add copy 1 find 3 1 3 copy 2 find 2 2 2 3<br>print 3<br>insert a 3 2<br>printall<br>over</p>
<h1 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h1><p>Op29adfk48<br>358<br>329strjvc<br>Op29adfk48<br>35a8</p>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>这题可够麻烦的。<br>不过A过这题可对你的string类的使用大有提升<br>犯了几个粗心的错误导致debug了好久= =<br>stringstream每次往里面输入数据的时候记得先ss.clear()啊。。。不要会出现奇怪的现象的<br>操作部分基本套用的string类中的函数，看代码一眼就懂了，没啥可说的。<br>关键是在fun函数部分。我将一整行数据看作一个操作单位。每种操作对应的操作参数的个数一定，所以利用递归的思想，将操作的返回值当成上一层操作的参数。递归函数为getst().<br>嘿嘿，我要是在北大上学，这代码是不是能拿优等呀^_^</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">using namespace std;</div><div class="line">string s[100];</div><div class="line">int tot;</div><div class="line">string copy(string n,string x,string l) &#123;</div><div class="line">    int a,b;</div><div class="line">    stringstream ss;</div><div class="line">    ss&lt;&lt;x;ss&gt;&gt;a;</div><div class="line">    ss.clear();</div><div class="line">    ss&lt;&lt;l;ss&gt;&gt;b;</div><div class="line">    return s[n[0]-&apos;0&apos;].substr(a,b);</div><div class="line">&#125;</div><div class="line">bool is_num(string a)&#123;</div><div class="line">    for (int i=0;i&lt;a.size();i++)&#123;</div><div class="line">        if (!(a[i]&gt;=&apos;0&apos;&amp;&amp;a[i]&lt;=&apos;9&apos;)) return 0;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">string add(string s1,string s2)&#123;</div><div class="line">    stringstream ss;</div><div class="line">    if (s1.size()&lt;6&amp;&amp;s2.size()&lt;6)</div><div class="line">        if (is_num(s1)&amp;&amp;is_num(s2))&#123;</div><div class="line">            int a;ss&lt;&lt;s1;ss&gt;&gt;a;</div><div class="line">            ss.clear();</div><div class="line">            int b;ss&lt;&lt;s2;ss&gt;&gt;b;</div><div class="line">            ss.clear();</div><div class="line">            ss&lt;&lt;a+b;</div><div class="line">            string tt;</div><div class="line">            ss&gt;&gt;tt;</div><div class="line">            return tt;</div><div class="line">        &#125;</div><div class="line">    return s1+s2;</div><div class="line">&#125;</div><div class="line">string find(string st,string n)&#123;</div><div class="line">    int t;</div><div class="line">    if(s[n[0]-&apos;0&apos;].find(st)==string::npos) t=s[n[0]-&apos;0&apos;].size();</div><div class="line">    else t=s[n[0]-&apos;0&apos;].find(st);</div><div class="line">    string tt;</div><div class="line">    stringstream ss;</div><div class="line">    ss&lt;&lt;t;ss&gt;&gt;tt;</div><div class="line">    return tt;</div><div class="line">&#125;</div><div class="line">string rfind(string st,string n)&#123;</div><div class="line">    int t;</div><div class="line">    if(s[n[0]-&apos;0&apos;].rfind(st)==string::npos) t=s[n[0]-&apos;0&apos;].size();</div><div class="line">    else t=s[n[0]-&apos;0&apos;].rfind(st);</div><div class="line">    string tt;</div><div class="line">    stringstream ss;</div><div class="line">    ss&lt;&lt;t;ss&gt;&gt;tt;</div><div class="line">    return tt;</div><div class="line">&#125;</div><div class="line">void insert(string st,string n,string x)&#123;</div><div class="line">    s[n[0]-&apos;0&apos;].insert(x[0]-&apos;0&apos;,st);</div><div class="line">&#125;</div><div class="line">void reset(string st,string n)&#123;</div><div class="line">    s[n[0]-&apos;0&apos;]=st;</div><div class="line">&#125;</div><div class="line">void print(string n)&#123;</div><div class="line">    cout&lt;&lt;s[n[0]-&apos;0&apos;]&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">void printall()&#123;</div><div class="line">    for (int i=1;i&lt;=tot;i++)</div><div class="line">        cout&lt;&lt;s[i]&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">stringstream ss;</div><div class="line">string getst()&#123;</div><div class="line">    string t;</div><div class="line">    string s1,s2,s3;</div><div class="line">    ss&gt;&gt;t;</div><div class="line">    if (t==&quot;find&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        return find(s1,s2);</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;rfind&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        return rfind(s1,s2);</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;copy&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();s3=getst();</div><div class="line">        return copy(s1,s2,s3);</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;add&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        return add(s1,s2);</div><div class="line">    &#125;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line">int fun(string t)&#123;</div><div class="line">    ss.clear();</div><div class="line">    ss&lt;&lt;t;</div><div class="line">    string s1,s2,s3;</div><div class="line">    ss&gt;&gt;t;</div><div class="line">    if (t==&quot;copy&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();s3=getst();</div><div class="line">        copy(s1,s2,s3);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;add&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();  </div><div class="line">        add(s1,s2);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;find&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        find(s1,s2);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;rfind&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        rfind(s1,s2);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;reset&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();</div><div class="line">        reset(s1,s2);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;insert&quot;)&#123;</div><div class="line">        s1=getst();s2=getst();s3=getst();</div><div class="line">        insert(s1,s2,s3);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;print&quot;)&#123;</div><div class="line">        s1=getst();</div><div class="line">        print(s1);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;printall&quot;)&#123;</div><div class="line">        printall();</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if (t==&quot;over&quot;)&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    cin&gt;&gt;tot;</div><div class="line">    for (int i=1;i&lt;=tot;i++)</div><div class="line">        cin&gt;&gt;s[i];</div><div class="line">    string t;</div><div class="line">    cin.get();</div><div class="line">    getline(cin,t);</div><div class="line">    while (fun(t))&#123;</div><div class="line">        getline(cin,t);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下安装最新的nodejs(v4.2.2)]]></title>
      <url>http://blog.acbingo.cn/2015/11/11/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84nodejs(v4.2.2)/</url>
      <content type="html"><![CDATA[<p>nodejs好像在15年下半年更新了nodejs在linux上安装方法，版本号也从v0.10.x.x换成了v4.x.x。我写这篇文章时官方网站的LTS版本号时4.2.2,Stable版为5.1.0.<br>网上介绍的linux安装方法通通不适用了。<br><a id="more"></a></p>
<ol>
<li>nodejs要求你已经安装好python环境，最好是python25-3.0</li>
<li>去官网下载最新版本。我们选择Linux Binaries (.tar.gz)<br><a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></li>
<li>将下载文件解压至任意文件夹。哪都行，我放在了我的用户文件夹下，/home/bingo/node</li>
<li>将其目录下的bin目录加入环境变量。<br>我的是/home/bingo/node/bin<br>我选中把其加入到最近的环境变量，也就是～/.bashrc中去。<br>gedit ～/.bashrc<br>在文件末尾加入这一行<br>export PATH=/home/bingo/node/bin:$PATH<br>保存退出，并重启Terminal</li>
<li>测试命令<br>node -v</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu14.04的环境变量]]></title>
      <url>http://blog.acbingo.cn/2015/11/11/ubuntu14.04%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>/etc/profile —— 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置；</p>
<p>/etc/environment —— 在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量；</p>
<p>/etc/bashrc —— 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取；</p>
<p>~/.profile —— 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次！默认情况下,它设置一些环境变量,执行用户的.bashrc文件；</p>
<p>~/.bashrc —— 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取；<br><a id="more"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记_文件操作和模板]]></title>
      <url>http://blog.acbingo.cn/2015/11/01/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>文件操作与模板<br><a id="more"></a></p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extcqvwc3aj30qv0f975m.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extczl9qlbj30rn0ff0u6.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extd0m34z7j30qx0fj0u4.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extdbwka13j30qw0fkq4k.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extdc82k96j30r50fegn3.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extdeic0jjj30r20fcgmp.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extdfdg1rdj30r30ezmy7.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extdfxnt6yj30rd0f6aax.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extdkabntwj30r20fdabn.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extdl85vqyj30qw0fh0ti.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extdlmzgj6j30qz0f9ab3.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extdtsjhpuj30qy0fgq4b.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extdvv7lplj30r30femye.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extdy1xanwj30qn0eydgr.jpg" alt=""></p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exte8juh8vj30rc0fm752.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extjl9xp3xj30r60f2ta4.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extjlntbs4j30rx0fr759.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extjs2zc1wj30qt0f4q3z.jpg" alt=""><br>函数模板也可以重载<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extjw1rnjwj30qz0f8q3x.jpg" alt=""><br>编译器寻找次序<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extjy6lp7ij30qs0f53zu.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extk2ptq3wj30qv0foaaz.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extk2w0zxhj30qu0fgdgu.jpg" alt=""><br>二义性<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extk7i53z5j30qx0f3wfn.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extk7ygu40j30r90fa0tw.jpg" alt=""></p>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extun4xhu3j30rb0fgjsp.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extuxl2twmj30qo0fljst.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extuy8wl0gj30ql0ey757.jpg" alt=""><br>非类型参数不一致，也是两个不一样的类</p>
<p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extuz7s82gj30qt0fjabm.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extuzk8uezj30qq0ffq3r.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extv20sibbj30r90fd0u1.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extv36e5alj30rm0fdgmv.jpg" alt=""></p>
<h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extvf6v9m2j30qv0f0dgk.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extvfiyslzj30rn0fgwfw.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extvhsefgej30qp0f0jse.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extvixtsqkj30qp0f2jsg.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extvk6rlhnj30r20f575k.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extvl0n5dwj30qt0fhgmz.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extvmphon7j30qu0fcab4.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extvmphon7j30qu0fcab4.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extvqxg5o4j30qz0ffmyt.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extvs0w666j30qr0f6403.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extvsbhpkfj30qs0f90uh.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extw0689akj30qw0f9wfd.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extw0y7runj30qx0f5my0.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extw1zcnsnj30qw0f9mxv.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extw30js5yj30r00fhgmr.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extw3zl5nkj30rf0f10u4.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extw4xbd4ij30qx0fagmh.jpg" alt=""></p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extwf864blj30q40ejdga.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1extwfod4pbj30r50eojs7.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extwgk5enzj30qr0f0q4l.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extwhch8zjj30r20fk3zg.jpg" alt=""><br>这个很好用呀，利用cerr输出调试信息<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extwn9nagsj30qo0eldgj.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1extwo9srpyj30qx0f4js9.jpg" alt=""><br>为什么可以用cin&gt;&gt;X来判断输入流是否结束了呢。<br>实际上有一个强制类型转换的重载，把该值转换成了一个布尔类型的值</p>
<p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extwvl6t6oj30qi0emabn.jpg" alt=""><br>几种黑科技函数<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1extx86xouyj30qu0etq3r.jpg" alt=""><br>peek()函数好像很好用啊</p>
<p>getline函数的一些问题<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1extxaboa79j30qp0f3js9.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记_多态和虚函数]]></title>
      <url>http://blog.acbingo.cn/2015/10/31/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%A4%9A%E6%80%81%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>多态和虚函数<br><a id="more"></a></p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk3igouwij30tf0hcjsn.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3jil0v7j30re0ftjsk.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3lwmnf1j30s60g00tn.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3mgvrsyj30tp0gxdh9.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk3mvm4l1j30rk0fi3zl.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3qnl993j30sq0huwfo.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk3qx9er2j30rt0fxt9k.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk3sjpy2bj30rv0g0jso.jpg" alt=""></p>
<h1 id="游戏中使用多态的例子"><a href="#游戏中使用多态的例子" class="headerlink" title="游戏中使用多态的例子"></a>游戏中使用多态的例子</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk3vtue71j30sa0g23zx.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1exk3weg30sj30rd0ea400.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3x5qv9sj30rt0ff0tu.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3yc1nffj30s20fdabp.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk3yp8zjuj30rk0emq41.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk3zg03ipj30qf0fadgu.jpg" alt=""><br>dragon需要对每种怪物写一个函数<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk41l604lj30si0gb3zn.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk448qmscj30sf0fdwfp.jpg" alt=""></p>
<h2 id="神奇的多态的实现方法"><a href="#神奇的多态的实现方法" class="headerlink" title="神奇的多态的实现方法"></a>神奇的多态的实现方法</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk44yo3noj318g0p0q5e.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk48fqtp8j30r40f1t9p.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1exk48qqvvfj30t60f3abd.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk48vdk4nj30rc0f4wfu.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk4956twpj318g0p0q5n.jpg" alt=""></p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk5chsckmj30qy0fb0ty.jpg" alt=""><br>连函数体都没有的纯虚函数（不需要为cshape类编写方法）。<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk5drd7skj30re0faq45.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1exk5hcpl5vj30r70fdmyb.jpg" alt=""><br>用什么方式去存这些几何形体呢。<br>可以用一个基类的指针数组。<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk5hlxqelj30sp0foq3p.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1exk5kaxxosj30rq0eojs4.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk5m64jp9j30qp0f2t9v.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1exk5s16w2zj30r20exabb.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk5stxlq9j30q30e274t.jpg" alt=""></p>
<p>下面的，为何不输出Base:fun2()呢？<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1exk6da4ps7j30rj0epaaw.jpg" alt=""><br>注：this省略与否，效果是相同的。<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1exk6e56yzoj30qs0frwfh.jpg" alt=""><br>执行的那一个fun2()，要看this指针指向的哪一个对象。在main里面pBase-&gt;fun1()的，所以进到base对象中，此时this指针指向的是一个派生类的对象。<br>故得到一个结论:<br><strong>在非构造函数，非析构函数的成员函数中调用虚函数，是多态！！！</strong><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk6jir36gj30r40f6abb.jpg" alt=""></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>注意son中的hello也是虚函数<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1exk6kd1sk5j30t90femz2.jpg" alt=""><br>在这里，son相当于grandson的基类。<br><img src="http://ww1.sinaimg.cn/large/deed93fejw1exkc7d9vixj218g0p0jvf.jpg" alt=""></p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkcgutuhyj20qy0fajsi.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/deed93fejw1exkci0kxdmj20s10fvab3.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/deed93fejw1exkcib0nzcj20s00esgmu.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkclg7jgnj20r70fidh9.jpg" alt=""></p>
<h3 id="多态的代价"><a href="#多态的代价" class="headerlink" title="多态的代价"></a>多态的代价</h3><p>额外的空间和时间上的开销。<br>每一个对象多4个字节，用来存放虚函数的地址。<br>而创建和查虚函数表花费的时间就是额外的时间。</p>
<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><p><img src="http://ww2.sinaimg.cn/large/deed93fejw1exkcqmzi1rj20rs0fmq3o.jpg" alt=""></p>
<p>如图，CGrandson并没有被析构<br><img src="http://ww1.sinaimg.cn/large/deed93fejw1exkdabw2l1j218g0o4goa.jpg" alt=""><br>因为，在delete的时候，p是基类的指针，所以会去调用基类的析构函数。编译器并不知道还需要调用派生类的析构函数，所以会造成一些错误。<br><img src="http://ww4.sinaimg.cn/large/deed93fejw1exkdfqxx0mj20sg0fkmyc.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkdgzh85jj20rs0fltac.jpg" alt=""><br>例子<br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkdh9zr73j20rd0fdt9h.jpg" alt=""><br>运行结果，只输出了bye from son<br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkdjt0yqqj20rt0gegmx.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkdlwtvurj218g0o40vp.jpg" alt=""></p>
<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkdzcflcnj20s40ff751.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/deed93fejw1exkelcx0g6j20ri0fnq4g.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkepenkezj20r40fadh7.jpg" alt=""><br>即便是只是添加了一个空的大括号，也可以认为是实现化。<br><img src="http://ww3.sinaimg.cn/large/deed93fejw1exkerd2fswj20qs0fjwf7.jpg" alt=""><br>在A的构造函数中，是不能调用f()的，在成员函数中调用是可以的</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coursera_程序设计与晋级_继承与派生_编程作业]]></title>
      <url>http://blog.acbingo.cn/2015/10/28/Coursera_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%99%8B%E7%BA%A7_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F_%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<h1 id="编程题＃1"><a href="#编程题＃1" class="headerlink" title="编程题＃1"></a>编程题＃1</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB<br><a id="more"></a><br>描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">写一个MyString 类，使得下面程序的输出结果是：</div><div class="line"></div><div class="line">1. abcd-efgh-abcd-</div><div class="line"></div><div class="line">2. abcd-</div><div class="line"></div><div class="line">3.</div><div class="line"></div><div class="line">4. abcd-efgh-</div><div class="line"></div><div class="line">5. efgh-</div><div class="line"></div><div class="line">6. c</div><div class="line"></div><div class="line">7. abcd-</div><div class="line"></div><div class="line">8. ijAl-</div><div class="line"></div><div class="line">9. ijAl-mnop</div><div class="line"></div><div class="line">10. qrst-abcd-</div><div class="line"></div><div class="line">11. abcd-qrst-abcd- uvw xyz</div><div class="line"></div><div class="line">about</div><div class="line"></div><div class="line">big</div><div class="line"></div><div class="line">me</div><div class="line"></div><div class="line">take</div><div class="line"></div><div class="line">abcd</div><div class="line"></div><div class="line">qrst-abcd-</div></pre></td></tr></table></figure></p>
<p>要求：MyString类必须是从C++的标准类string类派生而来。提示1：如果将程序中所有 “MyString” 用”string” 替换，那么题目的程序中除了最后两条语句编译无法通过外，其他语句都没有问题，而且输出和前面给的结果吻合。也就是说，MyString类对 string类的功能扩充只体现在最后两条语句上面。提示2: string类有一个成员函数 string substr(int start,int length); 能够求从 start位置开始，长度为length的子串</p>
<p>程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int CompareString( const void * e1, const void * e2) &#123;</div><div class="line">    MyString * s1 = (MyString * ) e1;</div><div class="line">    MyString * s2 = (MyString * ) e2;</div><div class="line">    if( *s1 &lt; *s2 ) return -1;</div><div class="line">    else if( *s1 == *s2 ) return 0;</div><div class="line">    else if( *s1 &gt; *s2 ) return 1;</div><div class="line">&#125;</div><div class="line">int main() &#123;</div><div class="line">    MyString s1(&quot;abcd-&quot;),s2,s3(&quot;efgh-&quot;),s4(s1);</div><div class="line">    MyString SArray[4] = &#123;&quot;big&quot;,&quot;me&quot;,&quot;about&quot;,&quot;take&quot;&#125;;</div><div class="line">    cout &lt;&lt; &quot;1. &quot; &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3&lt;&lt; s4&lt;&lt; endl;</div><div class="line">    s4 = s3; s3 = s1 + s3;</div><div class="line">    cout &lt;&lt; &quot;2. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;3. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;4. &quot; &lt;&lt; s3 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;5. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;6. &quot; &lt;&lt; s1[2] &lt;&lt; endl;</div><div class="line">    s2 = s1; s1 = &quot;ijkl-&quot;;</div><div class="line">    s1[2] = &apos;A&apos; ;</div><div class="line">    cout &lt;&lt; &quot;7. &quot; &lt;&lt; s2 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;8. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">    s1 += &quot;mnop&quot;;</div><div class="line">    cout &lt;&lt; &quot;9. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">    s4 = &quot;qrst-&quot; + s2;</div><div class="line">    cout &lt;&lt; &quot;10. &quot; &lt;&lt; s4 &lt;&lt; endl;</div><div class="line">    s1 = s2 + s4 + &quot; uvw &quot; + &quot;xyz&quot;;</div><div class="line">    cout &lt;&lt; &quot;11. &quot; &lt;&lt; s1 &lt;&lt; endl;</div><div class="line">    qsort(SArray,4,sizeof(MyString), CompareString);</div><div class="line">    for( int i = 0;i &lt; 4;++i )</div><div class="line">        cout &lt;&lt; SArray[i] &lt;&lt; endl;</div><div class="line">    //输出s1从下标0开始长度为4的子串</div><div class="line">    cout &lt;&lt; s1(0,4) &lt;&lt; endl;</div><div class="line">    //输出s1从下标为5开始长度为10的子串</div><div class="line">    cout &lt;&lt; s1(5,10) &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输入</p>
<p>无</p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">1. abcd-efgh-abcd-</div><div class="line"></div><div class="line">2. abcd-</div><div class="line"></div><div class="line">3.</div><div class="line"></div><div class="line">4. abcd-efgh-</div><div class="line"></div><div class="line">5. efgh-</div><div class="line"></div><div class="line">6. c</div><div class="line"></div><div class="line">7. abcd-</div><div class="line"></div><div class="line">8. ijAl-</div><div class="line"></div><div class="line">9. ijAl-mnop</div><div class="line"></div><div class="line">10. qrst-abcd-</div><div class="line"></div><div class="line">11. abcd-qrst-abcd- uvw xyz</div><div class="line"></div><div class="line">about</div><div class="line"></div><div class="line">big</div><div class="line"></div><div class="line">me</div><div class="line"></div><div class="line">take</div><div class="line"></div><div class="line">abcd</div><div class="line"></div><div class="line">qrst-abcd-</div><div class="line"></div><div class="line">样例输入</div><div class="line"></div><div class="line">无</div><div class="line">样例输出</div><div class="line"></div><div class="line">1. abcd-efgh-abcd-</div><div class="line">2. abcd-</div><div class="line">3.</div><div class="line">4. abcd-efgh-</div><div class="line">5. efgh-</div><div class="line">6. c</div><div class="line">7. abcd-</div><div class="line">8. ijAl-</div><div class="line">9. ijAl-mnop</div><div class="line">10. qrst-abcd-</div><div class="line">11. abcd-qrst-abcd- uvw xyz</div><div class="line">about</div><div class="line">big</div><div class="line">me</div><div class="line">take</div><div class="line">abcd</div><div class="line">qrst-abcd-</div></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>提示就是答案= =<br>不要想复杂了。。。继承string类就可以了<br>我一开始居然几乎重写了整个string类。。。花了半天居然还写过了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class MyString : public string</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">		MyString():string() &#123;&#125;;</div><div class="line">		MyString( const char * s):string(s)&#123;&#125;;</div><div class="line">    	MyString( const string &amp; s ): string(s)&#123;&#125;;</div><div class="line">    	MyString operator() ( int s, int l)</div><div class="line">		&#123;</div><div class="line">			return this-&gt;substr(s,l);</div><div class="line">		&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：-魔兽世界之二：装备"><a href="#编程题＃2：-魔兽世界之二：装备" class="headerlink" title="编程题＃2： 魔兽世界之二：装备"></a>编程题＃2： 魔兽世界之二：装备</h1><p>来源: POJ (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)</p>
<p>注意： 总时间限制: 1000ms 内存限制: 65536kB</p>
<p>描述</p>
<p>魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市。</p>
<p>红司令部，City 1，City 2，……，City n，蓝司令部</p>
<p>两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值这两种属性。</p>
<p>有的武士可以拥有武器。武器有三种，sword, bomb,和arrow，编号分别为0,1,2。</p>
<p>双方的武士编号都是从1开始计算。红方制造出来的第 n 个武士，编号就是n。同样，蓝方制造出来的第 n 个武士，编号也是n。</p>
<p>不同的武士有不同的特点。</p>
<p>dragon 可以拥有一件武器。编号为n的dragon降生时即获得编号为 n%3 的武器。dragon还有“士气”这个属性，是个浮点数，其值为它降生后其司令部剩余生命元的数量除以造dragon所需的生命元数量。</p>
<p>ninjia可以拥有两件武器。编号为n的ninjia降生时即获得编号为 n%3 和 (n+1)%3的武器。</p>
<p>iceman有一件武器。编号为n的iceman降生时即获得编号为 n%3 的武器。</p>
<p>lion 有“忠诚度”这个属性，其值等于它降生后其司令部剩余生命元的数目。</p>
<p>wolf没特点。</p>
<p>请注意，在以后的题目里，武士的士气，生命值，忠诚度在其生存期间都可能发生变化，都有作用，武士手中的武器随着使用攻击力也会发生变化。</p>
<p>武士在刚降生的时候有一个生命值。</p>
<p>在每个整点，双方的司令部中各有一个武士降生。</p>
<p>红方司令部按照 iceman、lion、wolf、ninja、dragon 的顺序循环制造武士。</p>
<p>蓝方司令部按照 lion、dragon、ninja、iceman、wolf 的顺序循环制造武士。</p>
<p>制造武士需要生命元。</p>
<p>制造一个初始生命值为 m 的武士，司令部中的生命元就要减少 m 个。</p>
<p>如果司令部中的生命元不足以制造某个按顺序应该制造的武士，那么司令部就试图制造下一个。如果所有武士都不能制造了，则司令部停止制造武士。</p>
<p>给定一个时间，和双方司令部的初始生命元数目，要求你将从0点0分开始到双方司令部停止制造武士为止的所有事件按顺序输出。</p>
<p>一共有两种事件，其对应的输出样例如下：</p>
<p>1) 武士降生</p>
<p>输出样例： 004 blue lion 5 born with strength 5,2 lion in red headquarter</p>
<p>表示在 4点整，编号为5的蓝魔lion武士降生，它降生时生命值为5,降生后蓝魔司令部里共有2个lion武士。(为简单起见，不考虑单词的复数形式)注意，每制造出一个新的武士，都要输出此时司令部里共有多少个该种武士。</p>
<p>如果造出的是dragon，那么还要输出一行，例：</p>
<p>It has a arrow,and it’s morale is 23.34</p>
<p>表示该dragon降生时得到了arrow,其士气是23.34（为简单起见，本题中arrow前面的冠词用a,不用an，士气精确到小数点后面2位，四舍五入）</p>
<p>如果造出的是ninjia，那么还要输出一行，例：</p>
<p>It has a bomb and a arrow</p>
<p>表示该ninjia降生时得到了bomb和arrow。</p>
<p>如果造出的是iceman，那么还要输出一行，例：</p>
<p>It has a sword</p>
<p>表示该iceman降生时得到了sword。</p>
<p>如果造出的是lion，那么还要输出一行，例：</p>
<p>It’s loyalty is 24</p>
<p>表示该lion降生时的忠诚度是24。</p>
<p>2) 司令部停止制造武士</p>
<p>输出样例： 010 red headquarter stops making warriors</p>
<p>表示在 10点整，红方司令部停止制造武士</p>
<p>输出事件时：</p>
<p>首先按时间顺序输出；</p>
<p>同一时间发生的事件，先输出红司令部的，再输出蓝司令部的。</p>
<p>输入</p>
<p>第一行是一个整数,代表测试数据组数。</p>
<p>每组测试数据共两行。</p>
<p>第一行，一个整数M。其含义为： 每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)</p>
<p>第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000</p>
<p>输出</p>
<p>对每组测试数据，要求输出从0时0分开始，到双方司令部都停止制造武士为止的所有事件。</p>
<p>对每组测试数据，首先输出“Case:n” n是测试数据的编号，从1开始</p>
<p>接下来按恰当的顺序和格式输出所有事件。每个事件都以事件发生的时间开头，时间以小时为单位，有三位。</p>
<p>样例输入</p>
<p>1<br>20<br>3 4 5 6 7<br>样例输出</p>
<p>Case:1<br>000 red iceman 1 born with strength 5,1 iceman in red headquarter<br>It has a bomb<br>000 blue lion 1 born with strength 6,1 lion in blue headquarter<br>It’s loyalty is 14<br>001 red lion 2 born with strength 6,1 lion in red headquarter<br>It’s loyalty is 9<br>001 blue dragon 2 born with strength 3,1 dragon in blue headquarter<br>It has a arrow,and it’s morale is 3.67<br>002 red wolf 3 born with strength 7,1 wolf in red headquarter<br>002 blue ninja 3 born with strength 4,1 ninja in blue headquarter<br>It has a sword and a bomb<br>003 red headquarter stops making warriors<br>003 blue iceman 4 born with strength 5,1 iceman in blue headquarter<br>It has a bomb<br>004 blue headquarter stops making warriors<br>How to submit<br>When you’re ready to submit, you can upload files for each part of the assignment on the “My submission” tab.</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>c++基本功啊！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">char st[][10]=&#123;&quot;dragon&quot;,&quot;ninja&quot;,&quot;iceman&quot;,&quot;lion&quot;,&quot;wolf&quot;&#125;;</div><div class="line">string wp[]=&#123;&quot;sword&quot;,&quot;bomb&quot;,&quot;arrow&quot;&#125;;</div><div class="line">class Weapon &#123;</div><div class="line">    private:</div><div class="line">        string s;</div><div class="line">    public:</div><div class="line">        Weapon(string t)&#123;</div><div class="line">            s=t;</div><div class="line">        &#125;</div><div class="line">        string getName()&#123;</div><div class="line">            return s;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">class Soldier&#123;</div><div class="line">    private:</div><div class="line">        int id;</div><div class="line">        int type;</div><div class="line">        double morale;</div><div class="line">        int wpon[10];</div><div class="line">        int loyalty;</div><div class="line">    public:</div><div class="line">        Soldier(int num,int b,int c,int d)&#123;</div><div class="line"></div><div class="line">            id=num;</div><div class="line">            type=b;</div><div class="line">            if (b==3) loyalty=c;</div><div class="line">            if (b==0) &#123;</div><div class="line">                wpon[0]=1;</div><div class="line">                wpon[1]=num%3;</div><div class="line">                morale=(double)c/d;</div><div class="line">            &#125;</div><div class="line">            if (b==1)&#123;</div><div class="line">                wpon[0]=2;</div><div class="line">                wpon[1]=num%3;</div><div class="line">                wpon[2]=(num+1)%3;</div><div class="line">            &#125;</div><div class="line">            if (b==2)&#123;</div><div class="line">                wpon[0]=1;</div><div class="line">                wpon[1]=num%3;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        double getMorale()&#123;</div><div class="line">            return morale;</div><div class="line">        &#125;</div><div class="line">        int getLoyalty()&#123;</div><div class="line">            return loyalty;</div><div class="line">        &#125;</div><div class="line">        int getWpon1()&#123;</div><div class="line">            return wpon[1];</div><div class="line">        &#125;</div><div class="line">        int getWpon2()&#123;</div><div class="line">            return wpon[2];</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">char typeName[2][10]=&#123;&quot;red&quot;,&quot;blue&quot;&#125;;</div><div class="line">class Camp&#123;</div><div class="line">    private:</div><div class="line">        static int k[10];//soldiers&apos; life</div><div class="line">        int type;//red 0,blue 1;</div><div class="line">        int cnt[10];//count for soldier</div><div class="line">        int blood;</div><div class="line">        int num;//soldier id</div><div class="line">        int cnum;//creat num</div><div class="line">    public:</div><div class="line">        static void setK(int *p)&#123;</div><div class="line">            for (int i=0;i&lt;5;i++)</div><div class="line">                k[i]=p[i];</div><div class="line">        &#125;</div><div class="line">        Camp(int i,int b)&#123;//i:red or blue,b:blood</div><div class="line">            if (i==0) type=0;</div><div class="line">            else type=1;</div><div class="line">            memset(cnt,0,sizeof(cnt));</div><div class="line">            blood=b;</div><div class="line">            num=0;cnum=0;</div><div class="line">        &#125;</div><div class="line">        int getCamp()&#123;</div><div class="line">            return type;</div><div class="line">        &#125;</div><div class="line">        string getName()&#123;</div><div class="line">            if (type==0) return &quot;red&quot;;</div><div class="line">            else return &quot;blue&quot;;</div><div class="line">        &#125;</div><div class="line">        int getTypeNum(int n)&#123;</div><div class="line">            if (type==0)&#123;</div><div class="line">                switch (n%5)&#123;</div><div class="line">                    case 0:return 2;</div><div class="line">                    case 1:return 3;</div><div class="line">                    case 2:return 4;</div><div class="line">                    case 3:return 1;</div><div class="line">                    case 4:return 0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                switch (n%5)&#123;</div><div class="line">                    case 0:return 3;</div><div class="line">                    case 1:return 0;</div><div class="line">                    case 2:return 1;</div><div class="line">                    case 3:return 2;</div><div class="line">                    case 4:return 4;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int getNextSoldier()&#123;</div><div class="line">            int tmp=getTypeNum(cnum);</div><div class="line">            blood-=k[tmp];</div><div class="line">            int i;</div><div class="line">            if (blood&lt;0)&#123;</div><div class="line">                blood+=k[tmp];</div><div class="line">                for (i=1;i&lt;5;i++)&#123;</div><div class="line">                    tmp=getTypeNum(cnum+i);</div><div class="line">                    if (blood&gt;=k[tmp])&#123;</div><div class="line">                        cnum+=i;</div><div class="line">                        blood-=k[tmp];</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (i==5) return 0;</div><div class="line">            Soldier t(num+1,tmp,blood,k[0]);</div><div class="line">            cnt[tmp]++;</div><div class="line">            printf(&quot;%s %s %d born with strength %d,%d %s in %s headquarter\n&quot;,typeName[type],st[tmp],num+1,k[tmp],cnt[tmp],st[tmp],typeName[type]);</div><div class="line">            if (tmp==0) printf(&quot;It has a %s,and it&apos;s morale is %.2lf\n&quot;,wp[t.getWpon1()].c_str(),t.getMorale());</div><div class="line">            if (tmp==1) printf(&quot;It has a %s and a %s\n&quot;,wp[t.getWpon1()].c_str(),wp[t.getWpon2()].c_str());</div><div class="line">            if (tmp==2) printf(&quot;It has a %s\n&quot;,wp[t.getWpon1()].c_str());</div><div class="line">            if (tmp==3) printf(&quot;It&apos;s loyalty is %d\n&quot;,t.getLoyalty());</div><div class="line">            num++;cnum++;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">int Camp::k[10]=&#123;0&#125;;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    int T;</div><div class="line">    cin&gt;&gt;T;</div><div class="line">    for (int i=1;i&lt;=T;i++)&#123;</div><div class="line">        int ti=0;</div><div class="line">        cout&lt;&lt;&quot;Case:&quot;&lt;&lt;i&lt;&lt;endl;</div><div class="line">        int b;cin&gt;&gt;b;</div><div class="line">        Camp red(0,b),blue(1,b);</div><div class="line">        int p[10];</div><div class="line">        for (int i=0;i&lt;5;i++)</div><div class="line">            cin&gt;&gt;p[i];</div><div class="line">        Camp::setK(p);</div><div class="line">        int f1=0,f2=0;</div><div class="line">        while (1)&#123;</div><div class="line">            if (!f1)printf(&quot;%03d &quot;,ti);</div><div class="line">            if(!f1&amp;&amp;red.getNextSoldier()==0) &#123;cout&lt;&lt;&quot;red headquarter stops making warriors&quot;&lt;&lt;endl;f1=1;&#125;</div><div class="line">            if (!f2)printf(&quot;%03d &quot;,ti);</div><div class="line">            if(!f2&amp;&amp;blue.getNextSoldier()==0) &#123;cout&lt;&lt;&quot;blue headquarter stops making warriors&quot;&lt;&lt;endl;f2=1;&#125;</div><div class="line">            if (f1&amp;&amp;f2) break;</div><div class="line">            ti++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科大OJ-数据结构-DNA序列]]></title>
      <url>http://blog.acbingo.cn/2015/10/22/%E7%A7%91%E5%A4%A7OJ-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-DNA%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>现有一个项目旨在从成千上万捐献的DNA分析地球上人类是如何繁衍的。该项目邀请你写一个程序找出给定的DNA片段之间的相同之处，使得对个体的调查相关联。一个DNA碱基序列是指把分子中发现的氮基的序列给罗列出来。有四种氮基：腺嘌呤（A）、胸腺嘧啶（T）、鸟嘌呤（G）和胞嘧啶（C），例如，一个6碱基DNA序列可以表示为TAGACC。给出一个DNA碱基序列的集合，确定在所有序列中都出现的最长的字典序最小的碱基序列。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行是一个整数，代表数据组数。每组数据第一行为一个整数n（2&lt;=n&lt;=60），代表有n个DNA串，接下来n行每行一个长度不超过500的字符串（每组数据中的字符串长度相同），代表DNA序列。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>每组数据输出一行，如果在所有序列都出现的最长碱基序列长度不小于3，输出这个最长碱基序列，否则输出“no significant commonalities”。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>2<br>GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA<br>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br>3<br>GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA<br>GATACTAGATACTAGATACTAGATACTAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA<br>GATACCAGATACCAGATACCAGATACCAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA<br>3<br>CATCATCATCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>ACATCATCATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br>AACATCATCATTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</p>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>no significant commonalities<br>AGATAC<br>CATCATCAT<br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>感觉这题数据卡的毫无意义！<br>一开始总以为如此规模，可能要自己改kmp，不深入理解kmp算法这题没得做啊= =<br>然而，好像并不是。<br>枚举某条串的子串，然后若该子串也出现在其他串中，则该子串符合条件。<br>因为要求取字典最大的最长串，所以可以从长往短枚举。</p>
<p>说白了这充其量就是个求 最长公共子串 问题嘛。</p>
<p>注意要找字典最大的串，所以不要急着break输出结果判，要先搜索完所有该长度的子串确认一下。</p>
<p>代码中加了几点小优化。。oj测试仍TLE75%(25%的数据没有过？)，慢在了string上，改成char[]肯定就能过了，但是我懒得改了= =。<br>AC代码先不贴了，看着丑。kmp代码部分直接套用其他的<a href="http://www.cnblogs.com/dolphin0520/archive/2011/08/24/2151846.html" target="_blank" rel="external">模板</a>。</p>
<p>另外，感觉这题用<a href="http://zyj177484.blog.163.com/blog/static/1837942312012981162390/" target="_blank" rel="external">后缀树</a>来做更好一点。<br>改天有时间好好研究研究</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">map&lt;string,int&gt; mp;</div><div class="line">void getNext(const char *p,int *next)</div><div class="line">&#123;</div><div class="line">    int j,k;</div><div class="line">    next[0]=-1;</div><div class="line">    j=0;</div><div class="line">    k=-1;</div><div class="line">    while(j&lt;strlen(p)-1)</div><div class="line">    &#123;</div><div class="line">        if(k==-1||p[j]==p[k])    //匹配的情况下,p[j]==p[k]</div><div class="line">        &#123;</div><div class="line">            j++;</div><div class="line">            k++;</div><div class="line">            next[j]=k;</div><div class="line">        &#125;</div><div class="line">        else                   //p[j]!=p[k]</div><div class="line">            k=next[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int KMPMatch(const char *s,const char *p)</div><div class="line">&#123;</div><div class="line">    int next[550];</div><div class="line">    int i,j;</div><div class="line">    i=0;</div><div class="line">    j=0; </div><div class="line">    getNext(p,next);</div><div class="line">    while(i&lt;strlen(s))</div><div class="line">    &#123;</div><div class="line">        if(j==-1||s[i]==p[j])</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            j=next[j];       //消除了指针i的回溯</div><div class="line">        &#125;</div><div class="line">        if(j==strlen(p))</div><div class="line">            return i-strlen(p);</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div><div class="line">string getp(string s,int len,int k)&#123;</div><div class="line">    string tmp;</div><div class="line">    for (int i=0;i&lt;len;i++)&#123;</div><div class="line">        tmp+=s[i+k];</div><div class="line">    &#125;</div><div class="line">    return tmp;</div><div class="line">&#125;</div><div class="line">string anss;</div><div class="line">int cnt;</div><div class="line">string s[65];</div><div class="line">int fun(string p)&#123;</div><div class="line">    if (mp[p]) return 0;</div><div class="line">    if (anss&gt;p) return 0;</div><div class="line">    for (int i=1;i&lt;cnt;i++)&#123;</div><div class="line">         if (KMPMatch(s[i].c_str(),p.c_str())==-1) return 0;</div><div class="line">    &#125;</div><div class="line">    mp[p]=1;</div><div class="line">    anss=p;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">int tmp(string a,string b)&#123;</div><div class="line">    return a.size()&lt;b.size();</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);//流加速</div><div class="line">    int t;</div><div class="line">    cin&gt;&gt;t;</div><div class="line">    while (t--) &#123;</div><div class="line">        cin&gt;&gt;cnt;</div><div class="line">        mp.clear();</div><div class="line">        anss=&quot;&quot;;</div><div class="line">        for (int i=0;i&lt;cnt;i++)&#123;</div><div class="line">            cin&gt;&gt;s[i];</div><div class="line">        &#125;</div><div class="line">        int t=500,k;</div><div class="line">        for (int i=0;i&lt;cnt;i++)&#123;</div><div class="line">            if (t&gt;s[i].size())   &#123;</div><div class="line">                t=s[i].size();</div><div class="line">                k=i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap(s[0],s[k]);</div><div class="line">        string p;</div><div class="line">        int len=0;</div><div class="line">        int anslen=0;</div><div class="line">        int f=0;</div><div class="line">        for (len=s[0].size();len&gt;=3;len--)&#123;</div><div class="line">            mp.clear();</div><div class="line">            for (int i=0;i+len&lt;=s[0].size();i++)&#123;</div><div class="line">                p=getp(s[0],len,i);</div><div class="line">                if (fun (p))&#123;</div><div class="line">                    anss=p;</div><div class="line">                    f=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (f)&#123;</div><div class="line">                cout&lt;&lt;anss&lt;&lt;endl;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!f) cout&lt;&lt;&quot;no significant commonalities&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科大OJ-数据结构-求表达式串的后缀表达式和值]]></title>
      <url>http://blog.acbingo.cn/2015/10/20/%E7%A7%91%E5%A4%A7OJ-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%B2%E7%9A%84%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%80%BC/</url>
      <content type="html"><![CDATA[<h1 id="求表达式串的后缀表达式和值"><a href="#求表达式串的后缀表达式和值" class="headerlink" title="求表达式串的后缀表达式和值"></a>求表达式串的后缀表达式和值</h1><p>Time Limit: 2 Sec  Memory Limit: 2 MB<br>Submit: 182  Solved: 35<br>[Submit][Status][Web Board]</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>基于任意给定的表达式串（包含的运算有加(+)、减(-)、乘(<em>)、除(/)、圆括号等，例如：输入3.4+5.6</em>(4.2-1），求其后缀表达式，并求表达式的计算结果。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>有多组输入数据，每一行一组输入，请处理到文件结束（EOF）。<br>每行一个表达式串（最多1000个字符），中间没有空格等其他无关字符。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出为三行。第一行输出每组的case，第二行是所求的后缀表达式，第三行是所求的表达式的值。只有每个数字后面会有空格，没有多余空格输出，后缀表达式中的数字按给出字符串中的数字原样输出，表达式的值中不要有无意义的0出现，每组输出后边都有一个空行。格式见Sample。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5+10<em>(5+6)-10<br>5.0+10.00</em>(5+6.000)-10.00000<br>Sample Output</p>
<p>Case #1:<br>5 10 5 6 +*+10 -<br>The answer is 105.</p>
<p>Case #2:<br>5.0 10.00 5 6.000 +*+10.00000 -<br>The answer is 105.</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>考察知识点：栈, 时间复杂度O(n)，空间复杂度O(n)<br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>懒，就没有去自己实现栈。直接用的stl的。。。</p>
<p>先对表达式进行下预处理。将数值与操作数分离出来。具体实现参看init().</p>
<p>关于中缀表达式如何转换后缀表达式，建议去参考下这两篇文章，写的挺好的。<br><a href="http://www.nowamagic.net/librarys/veda/detail/2307" target="_blank" rel="external">将中缀表达式转化为后缀表达式</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/2306" target="_blank" rel="external">图解后缀表达式的计算过程</a><br>另外，文中描述的比较粗，有些细节还没说。<br>比如对于表达式 -3+4 。前面的符号正常处理，其对应的后缀表达式是3-4+ 。<br>而在后缀表达式的计算中，要注意取栈顶的两个数，当栈空时，再取数是会出错的。所以在这种情况下，取出的两个数分别是0和3.</p>
<p>因为忘记输出换行PE了一次，也算是1A吧= =</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">using namespace std;</div><div class="line">struct Node &#123;</div><div class="line">    /* data */</div><div class="line">    bool type;//0为数值，1为操作数</div><div class="line">    char opt;//操作数</div><div class="line">    string snum;//操作数的原样</div><div class="line">    double num;//数值</div><div class="line">&#125;;</div><div class="line">vector &lt;Node&gt; st;//中缀表达式</div><div class="line">vector &lt;Node&gt; st2;//后缀表达式</div><div class="line">void fun(string s,int &amp;i)&#123;</div><div class="line">    if (s[i]==&apos;(&apos;||s[i]==&apos;)&apos;||s[i]==&apos;+&apos;||s[i]==&apos;-&apos;||s[i]==&apos;*&apos;||s[i]==&apos;/&apos;)&#123;</div><div class="line">        Node t;</div><div class="line">        t.type=1;t.opt=s[i];</div><div class="line">        st.push_back(t);</div><div class="line">        i++;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    Node t;</div><div class="line">    double k;</div><div class="line">    string tmp=&quot;&quot;;</div><div class="line">    while ((s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;)||(s[i]==&apos;.&apos;))&#123;</div><div class="line">        tmp+=s[i];</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    stringstream ss(tmp);</div><div class="line">    ss&gt;&gt;k;</div><div class="line">    t.type=0;t.num=k;t.snum=tmp;</div><div class="line">    st.push_back(t);</div><div class="line">    return ;</div><div class="line">&#125;</div><div class="line">void init(string s)&#123;</div><div class="line">    st.clear();</div><div class="line">    int i=0;</div><div class="line">    while (i&lt;s.size())&#123;</div><div class="line">        fun(s,i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void infix2suffix()&#123;</div><div class="line">    stack&lt;char&gt; opt;</div><div class="line">    for (int i=0;i&lt;st.size();i++)&#123;</div><div class="line">        Node t;</div><div class="line">        if (opt.empty()&amp;&amp;st[i].type==1) &#123;opt.push(st[i].opt);continue;&#125;//栈为空时，遇到运算符，直接入栈</div><div class="line">        if (st[i].type==0) st2.push_back(st[i]);//遇到操作数：直接输出（添加到后缀表达式中）</div><div class="line">        if (st[i].type==1)&#123;</div><div class="line">            char c=st[i].opt;</div><div class="line">            if (c==&apos;(&apos;) opt.push(st[i].opt);//遇到左括号：将其入栈</div><div class="line">            else if (c==&apos;)&apos;)&#123;</div><div class="line">                char ch=opt.top();opt.pop();</div><div class="line">                while (ch!=&apos;(&apos;)&#123;</div><div class="line">                    Node t;</div><div class="line">                    t.type=1;t.opt=ch;</div><div class="line">                    st2.push_back(t);</div><div class="line">                    ch=opt.top();opt.pop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (c==&apos;*&apos;||c==&apos;/&apos;)&#123;</div><div class="line">                while ((!opt.empty()&amp;&amp;opt.top()!=&apos;(&apos;)&amp;&amp;(opt.top()==&apos;*&apos;||opt.top()==&apos;/&apos;))&#123;</div><div class="line">                    Node t;</div><div class="line">                    t.type=1;t.opt=opt.top();opt.pop();</div><div class="line">                    st2.push_back(t);</div><div class="line">                &#125;</div><div class="line">                opt.push(c);</div><div class="line">            &#125;</div><div class="line">            else if (c==&apos;+&apos;||c==&apos;-&apos;)&#123;</div><div class="line">                while ((!opt.empty()&amp;&amp;opt.top()!=&apos;(&apos;))&#123;</div><div class="line">                    Node t;</div><div class="line">                    t.type=1;t.opt=opt.top();opt.pop();</div><div class="line">                    st2.push_back(t);</div><div class="line">                &#125;</div><div class="line">                opt.push(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (!opt.empty()) &#123;</div><div class="line">        Node t;</div><div class="line">        t.type=1;t.opt=opt.top();</div><div class="line">        st2.push_back(t);</div><div class="line">        opt.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void print(vector&lt;Node&gt; v)&#123;</div><div class="line">    for (int i=0;i&lt;v.size();i++)&#123;</div><div class="line">        if (v[i].type==0) cout&lt;&lt;v[i].snum&lt;&lt;&quot; &quot;;</div><div class="line">        else cout&lt;&lt;v[i].opt;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">double get_answer(vector&lt;Node&gt; v)&#123;</div><div class="line">    stack &lt;double&gt; s;</div><div class="line">    for (int i=0;i&lt;v.size();i++)&#123;</div><div class="line">        if (v[i].type==0) &#123;s.push(v[i].num);continue;&#125;</div><div class="line">        double a=0,b=0;</div><div class="line">        b=s.top();s.pop();</div><div class="line">        if (!s.empty())&#123;</div><div class="line">            a=s.top();s.pop();</div><div class="line">        &#125;</div><div class="line">        double c=0;</div><div class="line">        switch (v[i].opt)&#123;</div><div class="line">            case &apos;+&apos;:c=a+b;break;</div><div class="line">            case &apos;-&apos;:c=a-b;break;</div><div class="line">            case &apos;*&apos;:c=a*b;break;</div><div class="line">            case &apos;/&apos;:c=a/b;break;</div><div class="line">        &#125;</div><div class="line">        s.push(c);</div><div class="line">    &#125;</div><div class="line">    return s.top();</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    string s;</div><div class="line">    int c=0;</div><div class="line">    while (cin&gt;&gt;s)&#123;</div><div class="line">        st.clear();st2.clear();</div><div class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;++c&lt;&lt;&quot;:&quot;&lt;&lt;endl;</div><div class="line">        init(s);//处理s,将其数值与操作数分离开来</div><div class="line">        infix2suffix();//中缀转后缀</div><div class="line">        print(st2);</div><div class="line">        cout&lt;&lt;&quot;The answer is &quot;;</div><div class="line">        cout&lt;&lt;get_answer(st2)&lt;&lt;&quot;.&quot;&lt;&lt;endl;</div><div class="line">        cout&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科大OJ-数据结构-击鼓传花]]></title>
      <url>http://blog.acbingo.cn/2015/10/01/%E7%A7%91%E5%A4%A7OJ-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%87%BB%E9%BC%93%E4%BC%A0%E8%8A%B1/</url>
      <content type="html"><![CDATA[<h1 id="击鼓传花"><a href="#击鼓传花" class="headerlink" title="击鼓传花"></a>击鼓传花</h1><p>Time Limit: 1 Sec  Memory Limit: 2 MB</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>设有N个人围成一个圈，每人手里都握着一个令牌写明一个数字（随机生成的）。从第一个人开始玩“击鼓传花”游戏，第一个击的次数为其令牌上写明的数字数（假设为m1）。第m1个人出列。下次再从第m1+1个人开始新的“击鼓传花”击的次数也为其令牌上写明的次数，等于该次数的人出列。重复以上过程直到所有人都出列为止。<br><a id="more"></a></p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入第一行为测试数据组数。每组测试数据2行，第1行一个整数n（1&lt;=n&lt;=10000），代表人数，第2行有n个空格隔开的整数代表mi（1&lt;=mi&lt;=5000）。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对每组测试数据输出2行，第1行为数据组数，第2行为所有人顺序出队的序列，格式见样例。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>5<br>1 2 3 4 5</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Case #1:<br>2 1 3 4</p>
<h2 id="Input2"><a href="#Input2" class="headerlink" title="Input2"></a>Input2</h2><p>1<br>6<br>1 2 3 4 5 6</p>
<h2 id="Output2"><a href="#Output2" class="headerlink" title="Output2"></a>Output2</h2><p>2 6 3 4 5</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><blockquote>
<p>考察知识点：循环链表,时间复杂度O(sum{m})，空间复杂度O(n)<br>从1开始，传1次：1-&gt;2。2出列。<br>从3开始，传3次：3-&gt;4-&gt;5-&gt;1。1出列。<br>从3开始，传3次：3-&gt;4-&gt;5-&gt;3。3出列。<br>从4开始，传4次：4-&gt;5-&gt;4-&gt;5-&gt;4。4出列。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>同样利用的上一题写的链表了来做的。不同的是，数据域增加了id元素，用来记录数的坐标。<br>增加了deleteList()，clearList()函数。</p>
<p>此题若是用<strong>循环链表</strong>来做思路应该会更清晰点。即，链表creat完成后，尾节点的指针指向头节点（这里的头节点指的是pHead-&gt;next，非pHead）。</p>
<p>在code的过程中出现了几个细节上的错误，代码中已注明。</p>
<ol>
<li>数据的3种存储方式<ul>
<li>静态区：  全局变量。</li>
<li>堆：      程序执行是分配的内存</li>
<li>栈：      函数调用，局部变量。<br>new出来的内存就是分配到堆上的。程序执行完以后，堆上分配的内存不会被操作系统自动回收，所以你不delete掉的话，操作系统不回收，那块内存就成了没爹没娘的无业    有民了，这个就叫内存泄露。<br>所以以后code的时候要注意内存泄漏问题。</li>
</ul>
</li>
<li>边缘细节问题。<br>由于我并没有将尾节点与头节点接到一块，而是手动的模拟循环。所以导致在处理最后一个节点与第一个节点的时候容易出现问题，浪费了我大量的时间用来debug啊= =，20分钟思考&amp;code完的，然后debug了一个半小时！</li>
<li>有个小优化<br> 若此时链表长度为3，而要传花5000次！<br> 那么有5000-5000%3次遍历是没有必要的，可以处理掉。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">struct SeqList&#123;</div><div class="line">    int data,id;</div><div class="line">    struct SeqList* next;</div><div class="line">&#125;;//head为头指针,head-&gt;data用来存该条链表的长度</div><div class="line">void creatList(SeqList* pHead)&#123;</div><div class="line">//按照格式读入一个链表</div><div class="line">    SeqList *now=new SeqList;</div><div class="line">    SeqList *last=new SeqList;</div><div class="line">    last=pHead;</div><div class="line">    int N,i=0;</div><div class="line">    scanf(&quot;%d&quot;,&amp;N);</div><div class="line">    pHead-&gt;data=N;</div><div class="line">    while (N--)&#123;</div><div class="line">        now=new SeqList;</div><div class="line">        //cout&lt;&lt;&amp;now&lt;&lt;endl;</div><div class="line">        scanf(&quot;%d&quot;,&amp;now-&gt;data);</div><div class="line">        now-&gt;id=++i;//序号</div><div class="line">        now-&gt;next=NULL;</div><div class="line">        last-&gt;next=now;</div><div class="line">        last=now;    </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void print(SeqList* pHead)&#123;</div><div class="line">//按照格式输出一个链表</div><div class="line">    SeqList* p=pHead-&gt;next;</div><div class="line">    int flag=0;</div><div class="line">    while (p)&#123;</div><div class="line">        if (flag) printf(&quot; &quot;); else flag=1;</div><div class="line">        printf(&quot;%d&quot;,p-&gt;data);</div><div class="line">        p=p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line">SeqList* deleteList(SeqList* p,SeqList* pHead)&#123;//删除p节点,并返回下一个节点的地址。</div><div class="line">    if (p==NULL) p=pHead-&gt;next;</div><div class="line">    SeqList *t=pHead;</div><div class="line">    while (t-&gt;next!=p) t=t-&gt;next;</div><div class="line">    t-&gt;next=p-&gt;next;</div><div class="line">    delete(p);//结点是new出来的，系统不会自动回收，所以必须delete掉。</div><div class="line">    pHead-&gt;data--;</div><div class="line">    if (t-&gt;next==NULL) return pHead-&gt;next;//update。若是没有这一句。当删除最后一个节点的时候，应该返回第一个节点的地址，而不是NULL。(因为这个RE了好久)</div><div class="line">    return t-&gt;next;</div><div class="line">&#125;</div><div class="line">void fun(SeqList* pHead)&#123;</div><div class="line">    int cnt=0,t=0,f=0;</div><div class="line">    SeqList *p=pHead-&gt;next;//优化</div><div class="line">    t=p-&gt;data%pHead-&gt;data;</div><div class="line">    while (pHead-&gt;data&gt;1)&#123;</div><div class="line">        if (cnt==t) &#123;</div><div class="line">            if (f) printf(&quot; &quot;);else f=1;</div><div class="line">            printf(&quot;%d&quot;,p-&gt;id);</div><div class="line">            if (p-&gt;next) </div><div class="line">                t=p-&gt;next-&gt;data;</div><div class="line">            else t=pHead-&gt;next-&gt;data;</div><div class="line">            p=deleteList(p,pHead);//若p不重置为下一个节点的地址就会出错</div><div class="line">            cnt=0;</div><div class="line">            t%=pHead-&gt;data;//优化</div><div class="line">            //cout&lt;&lt;t&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">       else&#123;</div><div class="line">            cnt++;</div><div class="line">            if (p==NULL) p=pHead;</div><div class="line">            p=p-&gt;next;</div><div class="line">            if (p==NULL) p=pHead-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void clearList(SeqList* pHead)&#123;//完全释放链表pHead</div><div class="line">    SeqList *p=pHead;</div><div class="line">    while (p) &#123;</div><div class="line">        SeqList *t=p;</div><div class="line">        p=p-&gt;next;</div><div class="line">        delete(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int T,c=0;</div><div class="line">    cin&gt;&gt;T;</div><div class="line">    while(T--)&#123;</div><div class="line">        SeqList *pHead=new SeqList;</div><div class="line">        creatList(pHead);</div><div class="line">        printf(&quot;Case #%d:\n&quot;,++c);</div><div class="line">        fun(pHead);</div><div class="line">        clearList(pHead);</div><div class="line">        printf(&quot;\n&quot;);</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科大OJ-数据结构-求集合的交并补集]]></title>
      <url>http://blog.acbingo.cn/2015/09/30/%E7%A7%91%E5%A4%A7OJ-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B1%82%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E5%B9%B6%E8%A1%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本代码仅供参考。</p>
<p>请勿直接copy来应付作业。(老师所迫，对于AC代码楼主会删掉某关键一行= =。而且你copy我代码只会害了你，还不如不做)</p>
<p>我会尽量在文中或是代码中给出解题思路。<br>若你有其它疑惑你可以在下方给我留言，我有时间一定回复。</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>任意给定两个包含1-30000个元素的集合A,B（集合中元素类型为任意整型数，且严格递增排列），求A交B、A并B、A-B和B-A集合。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入第一行为测试数据组数。每组测试数据两行，分别为集合A、B。每行第一个数n（1&lt;=n&lt;=30000）为元素数量，后面有n个严格递增的绝对值小于2^31代表集合中包含的数。<br><a id="more"></a></p>
<h1 id="Out"><a href="#Out" class="headerlink" title="Out"></a>Out</h1><p>对每组测试数据输出5行，第1行为数据组数，后4行分别为按升序输出两个集合的A交B、A并B、A-B和B-A集合。格式见样例。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>1<br>3 1 2 5<br>4 2 3 5 8</p>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>Case #1:<br>2 5<br>1 2 3 5 8<br>1<br>3 8</p>
<h1 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">struct SeqList&#123;</div><div class="line">    int data;</div><div class="line">    struct SeqList* next;</div><div class="line">&#125;;//head为头指针,head-&gt;data用来存该条链表的长度</div><div class="line">void creatList(SeqList* pHead)&#123;</div><div class="line">//按照格式读入一个链表</div><div class="line">    SeqList *now=new SeqList;</div><div class="line">    SeqList *last=new SeqList;</div><div class="line">    last=pHead;</div><div class="line">    int N;</div><div class="line">    scanf(&quot;%d&quot;,&amp;N);</div><div class="line">    pHead-&gt;data=N;</div><div class="line">    while (N--)&#123;</div><div class="line">        now=new SeqList;</div><div class="line">        scanf(&quot;%d&quot;,&amp;now-&gt;data);</div><div class="line">        now-&gt;next=NULL;</div><div class="line">        last-&gt;next=now;</div><div class="line">        last=now;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void print(SeqList* pHead)&#123;</div><div class="line">//按照格式输出一个链表</div><div class="line">    SeqList* p=pHead-&gt;next;</div><div class="line">    int flag=0;</div><div class="line">    while (p)&#123;</div><div class="line">        if (flag) printf(&quot; &quot;); else flag=1;</div><div class="line">        printf(&quot;%d&quot;,p-&gt;data);</div><div class="line">        p=p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line">void listPushBack(SeqList* pHead,int x)&#123;</div><div class="line">//添加元素x至链表pHead的尾部</div><div class="line">    pHead-&gt;data++;</div><div class="line">    SeqList *p=pHead;</div><div class="line">    SeqList *tmp=new SeqList;</div><div class="line">    tmp-&gt;data=x;tmp-&gt;next=NULL;</div><div class="line">    while (p-&gt;next) p=p-&gt;next;</div><div class="line">    p-&gt;next=tmp;</div><div class="line">    //cout&lt;&lt;&quot;Success&quot;&lt;&lt;x&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">SeqList* unionList(SeqList* pHead,SeqList* qHead)&#123;</div><div class="line">//求集合的并，保证升序</div><div class="line">    SeqList *p=pHead-&gt;next,*q=qHead-&gt;next;</div><div class="line">    SeqList *tHead=new SeqList;</div><div class="line">    tHead-&gt;data=0;</div><div class="line">    tHead-&gt;next=NULL;//原来new不对元素进行初始化呀。。。尼玛没写这一行调bug调了好长时间才发现= =。</div><div class="line">    while (1)&#123;</div><div class="line">        if (p==0)&#123;</div><div class="line">            while (q)&#123;</div><div class="line">                listPushBack(tHead,q-&gt;data);</div><div class="line">                q=q-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (q==0)&#123;</div><div class="line">            while (p)&#123;</div><div class="line">                listPushBack(tHead,p-&gt;data);</div><div class="line">                p=p-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (p==0&amp;&amp;q==0) break;</div><div class="line">        int x=p-&gt;data,y=q-&gt;data;</div><div class="line">        if (x&lt;y)&#123;</div><div class="line">            listPushBack(tHead,x);</div><div class="line">            p=p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x==y)&#123;</div><div class="line">            listPushBack(tHead,x);</div><div class="line">            p=p-&gt;next; q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x&gt;y)&#123;</div><div class="line">            listPushBack(tHead,y);</div><div class="line">            q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tHead;</div><div class="line">&#125;</div><div class="line">SeqList* interList(SeqList *pHead,SeqList *qHead)&#123;</div><div class="line">    SeqList *p=pHead-&gt;next,*q=qHead-&gt;next;</div><div class="line">    SeqList *tHead=new SeqList;</div><div class="line">    tHead-&gt;data=0;tHead-&gt;next=NULL;</div><div class="line">    while (1)&#123;</div><div class="line">        if (p==0||q==0) break;</div><div class="line">        int x=p-&gt;data,y=q-&gt;data;</div><div class="line">        if (x&lt;y)&#123;</div><div class="line">            p=p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x&gt;y)&#123;</div><div class="line">            q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x==y)&#123;</div><div class="line">            listPushBack(tHead,x);</div><div class="line">            p=p-&gt;next; q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tHead;</div><div class="line">&#125;</div><div class="line">SeqList* compleList(SeqList *pHead,SeqList *qHead)&#123;</div><div class="line">    SeqList *p=pHead-&gt;next,*q=qHead-&gt;next;</div><div class="line">    SeqList *tHead=new SeqList;</div><div class="line">    tHead-&gt;data=0;tHead-&gt;next=NULL;</div><div class="line">    while (1)&#123;</div><div class="line">        if (q==0) &#123;</div><div class="line">            while (p)&#123;</div><div class="line">               listPushBack(tHead,p-&gt;data);</div><div class="line">               p=p-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (p==0) break;</div><div class="line">        int x=p-&gt;data,y=q-&gt;data;</div><div class="line">        if (x&lt;y)&#123;</div><div class="line">            listPushBack(tHead,x);</div><div class="line">            p=p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x==y)&#123;</div><div class="line">            p=p-&gt;next;</div><div class="line">            q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">        else if (x&gt;y)&#123;</div><div class="line">            q=q-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tHead;</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int t;</div><div class="line">    cin&gt;&gt;t;</div><div class="line">    int c=0; </div><div class="line">    while (t--)&#123;</div><div class="line">        c++;</div><div class="line">        printf(&quot;Case #%d:\n&quot;,c);</div><div class="line">        SeqList *aHead=new SeqList;</div><div class="line">        SeqList *bHead=new SeqList;</div><div class="line">        SeqList *cHead=new SeqList;</div><div class="line">        SeqList *dHead=new SeqList;</div><div class="line">        SeqList *eHead=new SeqList;</div><div class="line">        SeqList *fHead=new SeqList;</div><div class="line">        creatList(aHead);</div><div class="line">        creatList(bHead);</div><div class="line">        //print(aHead);</div><div class="line">        //print(bHead);</div><div class="line">        cHead=interList(aHead,bHead);//A交B</div><div class="line">        print(cHead);</div><div class="line">        dHead=unionList(aHead,bHead);//A并B</div><div class="line">        print(dHead);</div><div class="line">        eHead=compleList(aHead,bHead);//A-B</div><div class="line">        print(eHead);</div><div class="line">        fHead=compleList(bHead,aHead);//B-A</div><div class="line">        print(fHead);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="然而用链表并不能AC"><a href="#然而用链表并不能AC" class="headerlink" title="然而用链表并不能AC"></a>然而用链表并不能AC</h1><p>链表虽然是对空间的优化，但是在频繁的new时间过慢。<br>而直接声明是申请一块内存池，显然比new每一个元素省不少时间。<br>所以，存在以下速度关系<br>直接声明&gt;malloc&gt;new</p>
<p>辛辛苦苦敲的链表居然不能过= =，伤心啊<br>用数组简单实现一下吧。思路基本一样</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">int a[30005],b[30005],c[60005];</div><div class="line">void print(int l)&#123;</div><div class="line">    if (l) printf(&quot;%d&quot;,c[0]);</div><div class="line">    for (int i=1;i&lt;l;i++)</div><div class="line">        printf(&quot; %d&quot;,c[i]);</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int t,ca=0;</div><div class="line">    cin&gt;&gt;t;</div><div class="line">    while (t--)&#123;</div><div class="line">        ca++;</div><div class="line">        printf(&quot;Case #%d:\n&quot;,ca);</div><div class="line">        int lena,lenb;</div><div class="line">        scanf(&quot;%d&quot;,&amp;lena);</div><div class="line">        for(int i=0;i&lt;lena;i++)&#123;</div><div class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        scanf(&quot;%d&quot;,&amp;lenb);</div><div class="line">        for(int i=0;i&lt;lenb;i++)&#123;</div><div class="line">            scanf(&quot;%d&quot;,&amp;b[i]);</div><div class="line">        &#125;</div><div class="line">        int p=0,q=0,l=0;</div><div class="line">        while (1)&#123;</div><div class="line">            if (p==lena) break;</div><div class="line">            if (q==lenb) break;</div><div class="line">            if (a[p]&lt;b[q])&#123;</div><div class="line">                p++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]==b[q])&#123;</div><div class="line">                c[l]=a[p];</div><div class="line">                l++;p++;q++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]&gt;b[q])&#123;</div><div class="line">                q++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(l);</div><div class="line">        l=0;p=0;q=0;</div><div class="line">        while (1)&#123;</div><div class="line">            if (p==lena)&#123;</div><div class="line">                while (q!=lenb)&#123;</div><div class="line">                    c[l]=b[q];l++;q++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (q==lenb)&#123;</div><div class="line">                while (p!=lena)&#123;</div><div class="line">                    c[l]=a[p];l++;p++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (p==lena&amp;&amp;q==lenb) break;</div><div class="line">            if (a[p]&lt;b[q])&#123;</div><div class="line">                c[l]=a[p];l++;</div><div class="line">                p++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]==b[q])&#123;</div><div class="line">                c[l]=a[p];</div><div class="line">                l++;p++;q++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]&gt;b[q])&#123;</div><div class="line">                c[l]=b[q];l++;</div><div class="line">                q++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(l);</div><div class="line">        l=0;p=0;q=0;</div><div class="line">        while (1)&#123;</div><div class="line">            if (q==lenb)&#123;</div><div class="line">                while (p!=lena)&#123;</div><div class="line">                    c[l]=a[p];l++;p++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (p==lena) break;</div><div class="line">            if (a[p]&lt;b[q])&#123;</div><div class="line">                c[l]=a[p];l++;</div><div class="line">                p++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]==b[q])&#123;</div><div class="line">                p++;q++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]&gt;b[q])&#123;</div><div class="line">                q++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(l);</div><div class="line">        l=0;p=0;q=0;</div><div class="line">        while (1)&#123;</div><div class="line">            if (p==lena)&#123;</div><div class="line">                while (q!=lenb)&#123;</div><div class="line">                    c[l]=b[q];l++;q++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (q==lenb) break;</div><div class="line">            if (a[p]&lt;b[q])&#123;</div><div class="line">                p++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]==b[q])&#123;</div><div class="line">                p++;q++;</div><div class="line">            &#125;</div><div class="line">            else if (a[p]&gt;b[q])&#123;</div><div class="line">                c[l]=b[q];l++;</div><div class="line">                q++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(l);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo无法本地访问]]></title>
      <url>http://blog.acbingo.cn/2015/09/27/hexo%E6%97%A0%E6%B3%95%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE/</url>
      <content type="html"><![CDATA[<p>今天早晨来了后，打算deploy下昨天写的文章，结果发现hexo server后，本地打不开网页了。经排查，不是浏览器自身的问题。<br><a id="more"></a></p>
<h1 id="难道端口被占用了？"><a href="#难道端口被占用了？" class="headerlink" title="难道端口被占用了？"></a>难道端口被占用了？</h1><p>git bush执行hexo s没有任何异常啊，但是127.1就是打不开。<br>关闭hexo s命令并执行netstat -ano。<br>发现127.0.0.1:4000端口果然被占用了。</p>
<p>在博客文件夹server模块下找到hexo\node_modules\hexo-server\index.js，然后修改里面的port。比如我从4000改到了5000。保存</p>
<p>然后执行hexo s打开浏览器<br>127.0.0.1:5000</p>
<p>nice!</p>
<p>经百度后发现大家也遇到过同样的问题。而且他查出来了端口是被一个叫做FoxitPortect.exe的进程给占用了。<br>突然想起昨天因为用到pdf所以装了个福昕阅读器。<br>Fuck！<br>浪费了我一上午的时间。<br>果断卸载！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记_继承与派生]]></title>
      <url>http://blog.acbingo.cn/2015/09/26/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>coursera学习笔记_继承与派生<br><a id="more"></a><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewg5beopj6j30ri0fr0vi.jpg" alt=""></p>
<h2 id="注意复合关系的使用"><a href="#注意复合关系的使用" class="headerlink" title="注意复合关系的使用"></a>注意复合关系的使用</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ewg68qxctij30tk0fmacc.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ewg68ypyjhj30rg0fggpd.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ewg69a5ovbj30sl0g2jvv.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewg69dzadjj30tl0g1gq4.jpg" alt=""></p>
<h2 id="基类-派生类同名成员和protected访问范围说明符"><a href="#基类-派生类同名成员和protected访问范围说明符" class="headerlink" title="基类/派生类同名成员和protected访问范围说明符"></a>基类/派生类同名成员和protected访问范围说明符</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ex5ckd4hc1j30lo0dgdip.jpg" alt=""><br>protected相比private要松一点<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ex5cm0b16ej30ln0ccdi1.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ex5cm8k6q4j30lr0cbjt0.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ex5cn6zkt0j30lr0dk0vb.jpg" alt=""></p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>在对基类进行初始化的时候要用初始化列表的形式<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ex5crtvzz5j30lz0cpq63.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ex5cyktxk4j30lp0cdwh3.jpg" alt=""><br>构造与析构的顺序<br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ex5d4crpznj30lq0caq6x.jpg" alt=""></p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ex5d6mze1aj30lp0bzwg7.jpg" alt=""><br>若是继承不是public，那么上诉三条就不成立了</p>
<p>直接基类与间接基类</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数类模板]]></title>
      <url>http://blog.acbingo.cn/2015/09/26/%E5%A4%A7%E6%95%B0%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>网上有不少大数类模板，但是其都没有大数与大数相除算法。<br>在这找到一份有大数相除的代码。<br><a id="more"></a><br><a href="http://blog.csdn.net/zdt3476/article/details/22050177" target="_blank" rel="external">转</a></p>
<p>改天有时间我一定要自己写一份！这个也是我一直想做的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;   </div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">const static int MAXSIZE = 202;</div><div class="line"></div><div class="line">class BigInteger</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	// 构造函数;</div><div class="line">	BigInteger(const char* str);</div><div class="line"></div><div class="line">public:</div><div class="line">	// 运算符重载;</div><div class="line">	BigInteger operator+ (const BigInteger&amp; bi);</div><div class="line">	BigInteger operator- (const BigInteger&amp; bi);</div><div class="line">	BigInteger operator* (const BigInteger&amp; bi);</div><div class="line">	BigInteger operator/ (const BigInteger&amp; bi);</div><div class="line">	BigInteger&amp; operator= (const BigInteger&amp; bi);</div><div class="line">	bool operator&lt; (const BigInteger&amp; bi);</div><div class="line">	bool operator&gt; (const BigInteger&amp; bi);</div><div class="line">	bool operator== (const BigInteger&amp; bi);</div><div class="line">	bool operator!= (const BigInteger&amp; bi);</div><div class="line">	friend ostream&amp; operator&lt;&lt; (ostream&amp; o,const BigInteger&amp; bi);</div><div class="line">	friend istream&amp; operator&gt;&gt; (istream&amp; i, BigInteger&amp; bi);</div><div class="line"></div><div class="line">private:</div><div class="line">	// 成员变量;</div><div class="line">	char str[MAXSIZE];				// 字符型数据;</div><div class="line">	int iVal[MAXSIZE];				// 整型数据;</div><div class="line">	bool bNeg;						// 标记负数;</div><div class="line">	int size;						// 标记位数;</div><div class="line"></div><div class="line">private:</div><div class="line">	// 辅助函数;</div><div class="line">	void intToCahr(BigInteger* bi);	// 将整型数值转换为字符串;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BigInteger::BigInteger(const char* str = &quot;&quot;)</div><div class="line">&#123;</div><div class="line">	// 初始化成员变量;</div><div class="line">	memset(this-&gt;str,0,MAXSIZE*sizeof(char));</div><div class="line">	memset(this-&gt;iVal,0,MAXSIZE*sizeof(int));</div><div class="line">	bNeg = false;</div><div class="line">	this-&gt;size = strlen(str);</div><div class="line">	if(str != &quot;&quot;)	// str如果是空的就不用赋值了;</div><div class="line">	&#123;</div><div class="line">		// 存储字符数组;</div><div class="line">		memcpy(this-&gt;str,str,this-&gt;size);</div><div class="line">		// 逆转字符数组，存储到整型数组中;</div><div class="line">		for (int i=0; i&lt;size; i++)</div><div class="line">		&#123;</div><div class="line">			this-&gt;iVal[i] = static_cast&lt;int&gt;(this-&gt;str[size - i - 1] - &apos;0&apos;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">BigInteger BigInteger::operator+ (const BigInteger &amp;bi)</div><div class="line">&#123;</div><div class="line">	BigInteger biTemp;</div><div class="line">	// 如果两个数都为0则直接返回0;</div><div class="line">	if (!strcmp(this-&gt;str,&quot;0&quot;) &amp;&amp; !strcmp(bi.str,&quot;0&quot;))</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 正整数的和为正数,默认;</div><div class="line">	// 取出两个数的最大长度,可能出现进位，所以取最大值加1;</div><div class="line">	biTemp.size = (this-&gt;size &gt; bi.size ? this-&gt;size : bi.size) + 1;</div><div class="line"></div><div class="line">	// 执行相加操作;</div><div class="line">	for (int i=0; i&lt;biTemp.size; i++)</div><div class="line">	&#123;</div><div class="line">		biTemp.iVal[i] += iVal[i] + bi.iVal[i];</div><div class="line">		// 对进位进行操作;</div><div class="line">		if (i+1 != MAXSIZE)</div><div class="line">		&#123;</div><div class="line">			// 保证进位不越界;</div><div class="line">			biTemp.iVal[i+1] += biTemp.iVal[i]/10;</div><div class="line">		&#125;</div><div class="line">		// 保留小于10的部分;</div><div class="line">		biTemp.iVal[i] = biTemp.iVal[i]%10;</div><div class="line">	&#125;</div><div class="line">	// 转换;</div><div class="line">	intToCahr(&amp;biTemp);</div><div class="line"></div><div class="line">	return biTemp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BigInteger BigInteger::operator- (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	BigInteger biTemp;</div><div class="line">	// 设置标志位，对两个数的大小进行判断;</div><div class="line">	int flag = 0;</div><div class="line">	// 通过长度判断;</div><div class="line">	if (this-&gt;size &gt; bi.size)</div><div class="line">	&#123;</div><div class="line">		flag = 1;</div><div class="line">	&#125;</div><div class="line">	else if (this-&gt;size &lt; bi.size)</div><div class="line">	&#123;</div><div class="line">		flag = -1;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		// 通过大小判断;</div><div class="line">		flag =  strcmp(this-&gt;str,bi.str);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 值相等时直接返回0;</div><div class="line">	if (0 == flag)</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 被减数比减数大;</div><div class="line">	else if(flag &gt; 0)</div><div class="line">	&#123;</div><div class="line">		// 差的长度至少和被减数相同;</div><div class="line">		biTemp.size = this-&gt;size;</div><div class="line">		// 相减;</div><div class="line">		for (int i=0; i&lt;biTemp.size; i++)</div><div class="line">		&#123;</div><div class="line">			biTemp.iVal[i] += this-&gt;iVal[i] - bi.iVal[i];</div><div class="line">			// 如果结果小于0，即转为正数,并向后一位借一;</div><div class="line">			if (biTemp.iVal[i] &lt; 0)</div><div class="line">			&#123;</div><div class="line">				if (i+1 != MAXSIZE)</div><div class="line">				&#123;</div><div class="line">					biTemp.iVal[i+1] -= 1;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				biTemp.iVal[i] += 10;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 被减数小于减数;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		// 取负号;</div><div class="line">		biTemp.bNeg = true;</div><div class="line">		biTemp.size = bi.size;</div><div class="line">		// 相减;</div><div class="line">		for (int i=0; i&lt;bi.size; i++)</div><div class="line">		&#123;</div><div class="line">			biTemp.iVal[i] += bi.iVal[i] - this-&gt;iVal[i];</div><div class="line">			// 如果结果小于0，即转为正数,并向后一位借一;</div><div class="line">			if (biTemp.iVal[i] &lt; 0)</div><div class="line">			&#123;</div><div class="line">				biTemp.iVal[i+1] -= 1;</div><div class="line">				biTemp.iVal[i] += 10;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 如果差为0，则直接返回;</div><div class="line">	// 因为biTemp还未确认长度，所以使用strcmp进行比较</div><div class="line">	if (!strcmp(biTemp.str,&quot;0&quot;))</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 转换;</div><div class="line">	intToCahr(&amp;biTemp);</div><div class="line"></div><div class="line">	return biTemp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BigInteger BigInteger::operator* (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	BigInteger biTemp;</div><div class="line">	// 如果其中一个数为0，直接返回0值;</div><div class="line">	if (!strcmp(this-&gt;str,&quot;0&quot;) || !strcmp(bi.str,&quot;0&quot;))</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 积的长度可能为两个因数的长度加1;</div><div class="line">	biTemp.size = this-&gt;size + bi.size + 1;</div><div class="line">	// 用第一个数的每一位去乘上第二个数的每一位;</div><div class="line">	for (int i=0; i&lt;this-&gt;size; i++)</div><div class="line">	&#123;</div><div class="line">		for (int j=0; j&lt;bi.size; j++)</div><div class="line">		&#123;</div><div class="line">			biTemp.iVal[i+j] += this-&gt;iVal[i] * bi.iVal[j];</div><div class="line">			if (i+j+1 != MAXSIZE)</div><div class="line">			&#123;</div><div class="line">				biTemp.iVal[i+j+1] += biTemp.iVal[i+j] / 10;</div><div class="line">			&#125;</div><div class="line">			biTemp.iVal[i+j] = biTemp.iVal[i+j] % 10;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	intToCahr(&amp;biTemp);</div><div class="line"></div><div class="line">	return biTemp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BigInteger BigInteger::operator/ (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	BigInteger biTemp;</div><div class="line">	// 如果被除数为0，直接返回;</div><div class="line">	if (!strcmp(this-&gt;str,&quot;0&quot;))</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 如果除数为1，返回被除数</div><div class="line">	if (!strcmp(bi.str,&quot;1&quot;))</div><div class="line">	&#123;</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 取得商的长度;</div><div class="line">	biTemp.size = this-&gt;size;</div><div class="line"></div><div class="line">	// 判断被除数和除数的大小;</div><div class="line">	int flag = 0;</div><div class="line">	if (this-&gt;size &gt; bi.size)</div><div class="line">	&#123;</div><div class="line">		flag = 1;</div><div class="line">	&#125;</div><div class="line">	else if (this-&gt;size &lt; bi.size)</div><div class="line">	&#123;</div><div class="line">		flag = -1;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		flag = strcmp(this-&gt;str,bi.str);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 如果被除数小于除数，结果为0;</div><div class="line">	if (flag &lt; 0)</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 被除数等于除数;</div><div class="line">	else if (flag == 0)</div><div class="line">	&#123;</div><div class="line">		return &quot;1&quot;;</div><div class="line">	&#125;</div><div class="line">	// 被除数大于除数,用被除数减去除数;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		BigInteger shang;</div><div class="line">		BigInteger div = *this;</div><div class="line">		BigInteger dr = bi;</div><div class="line">		BigInteger tmp;</div><div class="line">// 效率太低</div><div class="line">// 		while (this-&gt;bNeg == false &amp;&amp; *this != &quot;0&quot;)</div><div class="line">// 		&#123;</div><div class="line">// 			*this = *this - bi;</div><div class="line">// 			biTemp = biTemp + &quot;1&quot;;</div><div class="line">// 		&#125;</div><div class="line">// 		// 多加了1;</div><div class="line">// 		biTemp = biTemp - &quot;1&quot;;</div><div class="line"></div><div class="line">/*</div><div class="line">	采用补足余数位数的方法，提高效率…… 这是我目前能想到的最好方法了……</div><div class="line">**/</div><div class="line">		while (div.size &gt;= dr.size)</div><div class="line">		&#123;</div><div class="line">			tmp = &quot;1&quot;;</div><div class="line">			// 类似 13/12</div><div class="line">			if (div.str[0] &gt;= dr.str[0] &amp;&amp; strcmp(div.str,dr.str) &gt; 0)</div><div class="line">			&#123;</div><div class="line">				int k = div.size - dr.size;</div><div class="line">				for (int i=0; i&lt;k; i++)</div><div class="line">				&#123;</div><div class="line">					tmp = tmp * &quot;10&quot;; </div><div class="line">				&#125;</div><div class="line">				div = div - dr*tmp;</div><div class="line">				shang = shang + tmp;</div><div class="line">			&#125;</div><div class="line">			// 123/12</div><div class="line">			else if (div.str[0] &gt;= dr.str[0] &amp;&amp; div.size - dr.size &gt;= 1)</div><div class="line">			&#123;</div><div class="line">				int k = div.size - dr.size - 1;</div><div class="line">				for (int i=0; i&lt;k; i++)</div><div class="line">				&#123;</div><div class="line">					tmp = tmp * &quot;10&quot;; </div><div class="line">				&#125;</div><div class="line">				div = div - dr*tmp;</div><div class="line">				shang = shang + tmp;</div><div class="line">			&#125;</div><div class="line">			// 类似 1 / 2     12/13</div><div class="line">			else if((div.str[0] &lt; dr.str[0] &amp;&amp; div.size == dr.size)||</div><div class="line">				(div.size == dr.size &amp;&amp; strcmp(div.str,dr.str) &lt; 0)) </div><div class="line">			&#123;</div><div class="line">				return shang;</div><div class="line">			&#125;</div><div class="line">			// 233/33</div><div class="line">			else if (div.str[0] &lt; dr.str[0] &amp;&amp; div.size - dr.size &gt;= 1)</div><div class="line">			&#123;</div><div class="line">				int k = div.size - dr.size - 1;</div><div class="line">				for (int i=0; i&lt;k; i++)</div><div class="line">				&#123;</div><div class="line">					tmp = tmp * &quot;10&quot;; </div><div class="line">				&#125;</div><div class="line">				div = div - dr*tmp;</div><div class="line">				shang = shang + tmp;</div><div class="line">			&#125;</div><div class="line">			else </div><div class="line">			&#123;</div><div class="line">				/*div = div - dr;</div><div class="line">				shang = shang + &quot;1&quot;;*/</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 被除数小于除数，说明已经得到结果</div><div class="line">		return shang;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 商为0时直接返回</div><div class="line">	if (!strcmp(biTemp.str,&quot;0&quot;))</div><div class="line">	&#123;</div><div class="line">		return &quot;0&quot;;</div><div class="line">	&#125;</div><div class="line">	// 转换;</div><div class="line">	intToCahr(&amp;biTemp);</div><div class="line"></div><div class="line">	return biTemp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BigInteger&amp; BigInteger::operator= (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	// 判断是否是本身;</div><div class="line">	if (this == &amp;bi)</div><div class="line">	&#123;</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line">	// 赋值;</div><div class="line">	memset(this-&gt;str,0,MAXSIZE*sizeof(char));</div><div class="line">	memset(this-&gt;iVal,0,MAXSIZE*sizeof(int));</div><div class="line">	this-&gt;size = bi.size;</div><div class="line">	this-&gt;bNeg = bi.bNeg;</div><div class="line">	memcpy(this-&gt;str,bi.str,bi.size);</div><div class="line">	for (int i=0; i&lt;this-&gt;size; i++)</div><div class="line">	&#123;</div><div class="line">		this-&gt;iVal[i] = bi.iVal[i];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool BigInteger::operator== (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	// 判断对比的是否是对象本身;</div><div class="line">	if (this == &amp;bi)</div><div class="line">	&#123;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	// 判断字符串是否相等;</div><div class="line">	if (this-&gt;size &lt; bi.size || this-&gt;size &gt; bi.size)</div><div class="line">	&#123;</div><div class="line">		return false;</div><div class="line">	&#125; </div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		// 长度一样时，字符串大的值大;</div><div class="line">		return strcmp(this-&gt;str,bi.str) == 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool BigInteger::operator!= (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	// == 的否定;</div><div class="line">	return !(*this == bi);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream&amp; operator&lt;&lt; (ostream&amp; o,const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	// 如果是负数就输出负号;</div><div class="line">	if (bi.bNeg)</div><div class="line">	&#123;</div><div class="line">		o&lt;&lt;&quot;-&quot;;</div><div class="line">	&#125;</div><div class="line">	// 输出字符串值;</div><div class="line">	for (int i=0; i&lt;bi.size; i++)</div><div class="line">	&#123;</div><div class="line">		// 因为数组用0初始化，所以不能单纯使用bi.str进行输出;</div><div class="line">		o&lt;&lt;bi.str[i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line"></div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">istream&amp; operator&gt;&gt; (istream&amp; i, BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	// 通过输入的字符串，赋值bi;</div><div class="line">	string str;</div><div class="line">	i&gt;&gt;str;</div><div class="line">	bi = str.c_str();</div><div class="line"></div><div class="line">	return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void BigInteger::intToCahr(BigInteger* biTemp)</div><div class="line">&#123;</div><div class="line">	// 如果整型数组的最高位不是0，则得到真正的整数长度;</div><div class="line">	while (biTemp-&gt;size &gt; 0 &amp;&amp; biTemp-&gt;iVal[biTemp-&gt;size-1] == 0)</div><div class="line">	&#123;</div><div class="line">		biTemp-&gt;size -= 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 将整型数据存储为字符型;</div><div class="line">	for (int i=0; i&lt;biTemp-&gt;size; i++)</div><div class="line">	&#123;</div><div class="line">		biTemp-&gt;str[i] = static_cast&lt;char&gt;(biTemp-&gt;iVal[biTemp-&gt;size - 1 - i] + &apos;0&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool BigInteger::operator&lt; (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	if (this-&gt;size &gt; bi.size)</div><div class="line">	&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	else if (this-&gt;size &lt; bi.size)</div><div class="line">	&#123;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		return strcmp(this-&gt;str,bi.str) &lt; 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool BigInteger::operator&gt; (const BigInteger&amp; bi)</div><div class="line">&#123;</div><div class="line">	if (this-&gt;size &lt; bi.size)</div><div class="line">	&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	else if (this-&gt;size &gt; bi.size)</div><div class="line">	&#123;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		return strcmp(this-&gt;str,bi.str) &gt; 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">	BigInteger b1, b2;</div><div class="line">	string str;</div><div class="line">	cin&gt;&gt;b1&gt;&gt;str&gt;&gt;b2;</div><div class="line">	</div><div class="line">	if (str == &quot;+&quot;)</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;b1+b2&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	else if (str == &quot;-&quot;)</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;b1-b2&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	else if (str == &quot;*&quot;)</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;b1*b2&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;b1/b2&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vimium学习笔记]]></title>
      <url>http://blog.acbingo.cn/2015/09/15/vimium%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>自从用了vim,一直梦想着在使用电脑的时候能像使用vim一样，完全脱离鼠标<br>鼠标使用多了手腕就疼<br>而且一直没有钱买好鼠标= =<br>首先，在chrome上发现了一款神级插件,vimium<br><a id="more"></a><br>简直是吊吊吊<br><a href="http://sspai.com/27723" target="_blank" rel="external">转</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员矩阵]]></title>
      <url>http://blog.acbingo.cn/2015/09/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9F%A9%E9%98%B5/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/xd502djj/archive/2010/07/22/1782657.html" target="_blank" rel="external">转</a><br><a id="more"></a><br>||2n (Level 0)        |    n2 (Level 1)    |     n (Level 2)   |    log(n) (Level 3) |<br>| —— |:——:| ——:|——:|<br>|数据结构|不知道数组和链表的差异|能够解释和使用数组，链表，字典等，并且能够用于实际的编程任务。|了解基本数据结构时间和空间的折中，比如数组vs 链表，能够解释如何实现哈希表和处理冲突，了解优先队列及其实现。|高等的数据结构的知识，比如B-树、二项堆、斐波那契堆、AVL树、红黑树、伸展树、跳跃表以及前缀树等。|</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记_运算符重载]]></title>
      <url>http://blog.acbingo.cn/2015/09/03/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h1 id="浅复制与深复制"><a href="#浅复制与深复制" class="headerlink" title="浅复制与深复制"></a>浅复制与深复制</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evp9sgepmnj30sm0h541b.jpg" alt=""><br><a id="more"></a><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evp9u35mu8j30st0hh779.jpg" alt=""><br>如图，在进行了浅复制之后，s1的指针指向了s2的地址，然后s1本来所指向的地址就会出现没有指针所控制的情况，成为了内存垃圾。<br>然而，当s1和s2同时消亡的时候，s1和s2会被释放两次，这样就会导致内存错误，进而导致程序崩溃。</p>
<h2 id="用深复制解决"><a href="#用深复制解决" class="headerlink" title="用深复制解决"></a>用深复制解决</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evp9xkaxjkj30tn0hn77l.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1evp9y714jnj30tq0hn40x.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evp9z1bxdxj30sm0gxwhe.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evpa2t8e3bj30sa0gh0ut.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evpa337ipaj30rk0fgjtu.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evpa6uti0ej30ty0h9af7.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evpa8sop78j30st0gzwhy.jpg" alt=""></p>
<h2 id="自增自减运算符的重载"><a href="#自增自减运算符的重载" class="headerlink" title="自增自减运算符的重载"></a>自增自减运算符的重载</h2><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewfxt4wg4rj30si0gpq6h.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewfxv5lg5sj30te0g3dj1.jpg" alt=""></p>
<h3 id="类型转换运算符重载"><a href="#类型转换运算符重载" class="headerlink" title="类型转换运算符重载"></a>类型转换运算符重载</h3><p>CDemo d;<br>cout&lt;&lt;d&lt;&lt;end;<br>我除了可以重载流输出符号。也可以对强制类型转换运算符进行重载<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ewfy280sfcj30s70gbn0j.jpg" alt=""></p>
<h1 id="实例-–-长度可变的整型数组类"><a href="#实例-–-长度可变的整型数组类" class="headerlink" title="实例 – 长度可变的整型数组类"></a>实例 – 长度可变的整型数组类</h1><p>考虑到浅拷贝与深拷贝的问题，需要做2、4，注意一下<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ewfz0j13qyj30tl0i97a0.jpg" alt=""></p>
<h2 id="重载-i"><a href="#重载-i" class="headerlink" title="重载[i"></a>重载[i</h2><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewfz3siulgj30sl0hcn1t.jpg" alt=""></p>
<p>返回值为引用，就可以支持a[i]=4这样的语句了<br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1ewfz4ovu8pj30sh0gadk2.jpg" alt=""></p>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><blockquote>
<p>写一个二维数组类 Array2,使得下面程序的输出结果是：<br>0,1,2,3,<br>4,5,6,7,<br>8,9,10,11,<br>next<br>0,1,2,3,<br>4,5,6,7,<br>8,9,10,11,</p>
</blockquote>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">// 在此处补充你的代码</div><div class="line">int main() &#123;</div><div class="line">    Array2 a(3,4);</div><div class="line">    int i,j;</div><div class="line">    for(  i = 0;i &lt; 3; ++i )</div><div class="line">        for(  j = 0; j &lt; 4; j ++ )</div><div class="line">            a[i][j] = i * 4 + j;</div><div class="line">    for(  i = 0;i &lt; 3; ++i ) &#123;</div><div class="line">        for(  j = 0; j &lt; 4; j ++ ) &#123;</div><div class="line">            cout &lt;&lt; a(i,j) &lt;&lt; &quot;,&quot;;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;next&quot; &lt;&lt; endl;</div><div class="line">    Array2 b;     b = a;</div><div class="line">    for(  i = 0;i &lt; 3; ++i ) &#123;</div><div class="line">        for(  j = 0; j &lt; 4; j ++ ) &#123;</div><div class="line">            cout &lt;&lt; b[i][j] &lt;&lt; &quot;,&quot;;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>输入<br>无<br>输出<br>0,1,2,3,<br>4,5,6,7,<br>8,9,10,11,<br>next<br>0,1,2,3,<br>4,5,6,7,<br>8,9,10,11,</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>在网上搜到了北大的ppt，然而我并没有看懂。。。<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1ewg0wvzo9hj30lf0e8gpg.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1ewg0xiiwx6j30kz0e8dhr.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1ewg0xn17vyj30iw0djjvb.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写hexo博客、markdown文章时图床的挑选]]></title>
      <url>http://blog.acbingo.cn/2015/09/01/%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E3%80%81markdown%E6%96%87%E7%AB%A0%E6%97%B6%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%8C%91%E9%80%89/</url>
      <content type="html"><![CDATA[<p>妈妈再也不用愁我找不到即免费又快速还稳定的图床了哈哈哈<br><img src="https://camo.githubusercontent.com/ce381d1400eef2db63f1391a302dae35ea762c29/687474703a2f2f7777332e73696e61696d672e636e2f6c617267652f35666433373831386a77316570396232347a7a616e6732306f793064696e33322e676966" alt=""><br><a id="more"></a><br>学会用markdown编写博客后，图片若是存在本地，会被同步到github上，大家都知道，github的网速是在国内并不咋地，所以会导致文章内图片加载缓慢或是干脆加载不出来。<br>所以，将图片放在国内的图床上，然后引用外链是个好的解决办法。<br>国内口碑比较好的有啥七牛云存储。我跑去注册居然还要我实名认证，把本人照片传上去。哥这惊天动地的长相，传上去把你们服务器炸掉怎么办。想想也是后怕，这家图床用不得。<br>之后一直是从网页上把图传到某云盘里，然后点击上传，再找出超链接，再复制过来写在文章里，麻烦死了。<br>后来找到一个好东西。<br>chrome的插件：微博是个好图床。原理是把图片帮你传到新浪微博里，直接返回图片地址。。然后一个外链就生成了，简单三步走。<br>装上之后爽了几天，后来chrome以不是官方插件的理由给我禁掉了。把我气的。。找半天找不到怎么打开。。。<br>于是乎，在chrome商店搜到了这么个好东西：<br><img src="https://camo.githubusercontent.com/ce381d1400eef2db63f1391a302dae35ea762c29/687474703a2f2f7777332e73696e61696d672e636e2f6c617267652f35666433373831386a77316570396232347a7a616e6732306f793064696e33322e676966" alt=""><br><a href="https://github.com/Suxiaogang/WeiboPicBed" target="_blank" rel="external">下载地址</a><br>或是直接在商店里搜新浪微博图床</p>
<p>提高生产力的好东西，给作者赞一个！<br>enjoy</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[coursera学习笔记-c++程序设计]]></title>
      <url>http://blog.acbingo.cn/2015/08/31/coursera%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>记录一些不熟悉的或是以前不知道的知识点<br><a id="more"></a></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evlvvvrp20j318g0p07bb.jpg" alt=""><br>如图，new一个对象的初始化</p>
<h1 id="用new动态创建对象时，除了需要最后释放存储空间，它与普通创建对象的主要区别是什么？"><a href="#用new动态创建对象时，除了需要最后释放存储空间，它与普通创建对象的主要区别是什么？" class="headerlink" title="用new动态创建对象时，除了需要最后释放存储空间，它与普通创建对象的主要区别是什么？"></a>用new动态创建对象时，除了需要最后释放存储空间，它与普通创建对象的主要区别是什么？</h1><blockquote>
<p>new 创建的对象在堆内存上，可以通过指针在不同对象和函数间传递；而函数中声明的对象是在栈内存上创建的，要想在作用域外使用必须复制（包括返回值其实也是复制），因为作用域一旦结束，栈内存上的对象都析构了。而堆内存上的对象都要手动删除（除非用智能指针），而且手动删除前这个对象是保证可以被任何拥有该指针的函数访问的。另外堆内存的可用空间比栈内存大得多。</p>
</blockquote>
<h1 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evlw5jg8ibj318g0p0dky.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evlw6nm2yoj318g0p010d.jpg" alt=""><br>注意是如何调用构造函数的</p>
<p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evlwb6vz9cj318g0p0jye.jpg" alt=""><br>注意最后一个。Test <em>pArray[3]，是一个指针数组，该数组中的每一个元素存放的都是一个指针(未初始化的值)，没有任何对象的生成所以在定义这个数组的时候并不会调用Test的构造函数。<br>Test </em>pArray[3]={new Test(4),new Test(1,2)};<br>而{}内即为对该数组进行初始化，初始化的时候呢，new出来了两个Test对象，所以这个时候才会调用构造函数，而new的返回值是个指针，故其就能对该指针数组进行初始化。数组里的前两个元素已经被初始化了。最后一个数组没有被初始化。<br>老师在14分钟处，提到pArray[]数组的第三个元素，说该元素没有被初始化，其指针指向哪里我们也不知道。<br>个人认为这个地方是错误的。<br>最后一个元素也被初始化了，不过没有对象的生成，所以也就没有构造函数的调用，但是其值仍然被初始化为0，这里也就是NULL，严格来说该指针没有指向任何内容，或者说指向了一个空地址。<br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evm20vdkc0j30l80bcjtn.jpg" alt=""></p>
<h1 id="复制构造函数起作用的三种情况"><a href="#复制构造函数起作用的三种情况" class="headerlink" title="复制构造函数起作用的三种情况"></a>复制构造函数起作用的三种情况</h1><h2 id="当用一个对象去初始化同类的另一个对象时"><a href="#当用一个对象去初始化同类的另一个对象时" class="headerlink" title="当用一个对象去初始化同类的另一个对象时"></a>当用一个对象去初始化同类的另一个对象时</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evmqqp8r5pj31480o4439.jpg" alt=""><br>如图,<br>Complex c4=c1;调用了复制构造函数，但是c3=c1,只是一个复制语句，他并没有调用复制构造函数。</p>
<h2 id="如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。"><a href="#如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。" class="headerlink" title="如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。"></a>如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。</h2><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evmxoq94o6j30mw0cwacj.jpg" alt=""></p>
<h2 id="如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用"><a href="#如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用" class="headerlink" title="如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用"></a>如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用</h2><p><strong>这一点我经常忘记</strong><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evmy6rgy4sj30o00ch76n.jpg" alt=""><br>然而这里并没有输出1，说明没有调用复制构造函数。<br>这是编译器优化的原因，具体可<a href="http://blog.sina.com.cn/s/blog_4ab8464c0100kybj.html" target="_blank" rel="external">参考</a></p>
<h1 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h1><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evmzknbgn2j318g0p0102.jpg" alt=""><br>注意Complex c2=12;这里的12并没有被自动转换为一个临时的Complex对象<br>然而在下一行的9，先被自动转换成了一个临时对象，然后再把这个临时对象赋值给了c1</p>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evn0zuyhj0j318g0p0wnn.jpg" alt=""><br>注意</p>
<ol>
<li>d4=6这一句，因为这里要先生成一个临时的对象，所以这里会调用构造和析构函数</li>
<li>Func()函数内部，有一个静态的局部变量<br>关于静态变量的作用域和生存期：<blockquote>
<p>静态局部变量的作用域是（在定义该变量的函数内）生存期是（整个源程序）</p>
</blockquote>
</li>
</ol>
<p>所以d2的作用域虽然是在func()里，但是直到main函数结束才会被析构。由于他的构造比d1晚，所以析构比d1早</p>
<ol>
<li><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evn1bzmwtdj30sr0k3gqv.jpg" alt=""><br>可见Demo d7=7这一句并没有生成一个临时的对象</li>
</ol>
<h1 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h1><p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evn1bzmwtdj30sr0k3gqv.jpg" alt=""><br>静态成员变量一共就一份，为所有对象共享。<br>sizeof运算符不会计算静态成员变量。<br>其实静态成员变量和静态成员函数是放在所有对象外面，被所有对象所共享的。因此静态成员不需要通过对象就可以访问。</p>
<h2 id="如何访问静态成员"><a href="#如何访问静态成员" class="headerlink" title="如何访问静态成员"></a>如何访问静态成员</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evn1zizxh4j318g0p0dmt.jpg" alt=""><br>对于2、3、4提到的静态成员，是有某个具体的对象提供的，但是静态成员并不属于该对象，他是属于所有对象的。</p>
<p><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evn2glgga8j318g0p0wl0.jpg" alt=""><br>注意要对静态成员变量进行一次声明<br>另外，即使是静态成员变量，若其是私有的，在对象外也不可被访问。</p>
<h2 id="在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数"><a href="#在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数" class="headerlink" title="在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数"></a>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数</h2><p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1evn2kt154dj318g0p0jxr.jpg" alt=""><br>为什么呢？<br>就像前面说的，静态成员不作用于任何特定的对象，他是作用于所有对象的。然而在静态成员函数中调用非静态成员变量，程序并不能知道这个变量是具体哪个对象的成员变量。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evn3a8pokoj318g0p0afq.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evn3af5crzj318g0p0n3i.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1evn3bm9vklj318g0p0ael.jpg" alt=""></p>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1evn6yxnge1j30w30i9td0.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005BpcqWjw1evn7gpljyuj318g0p0grh.jpg" alt=""></p>
<h1 id="常量对象、常量成员函数和常引用"><a href="#常量对象、常量成员函数和常引用" class="headerlink" title="常量对象、常量成员函数和常引用"></a>常量对象、常量成员函数和常引用</h1><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evo2th54m1j30t50g5mzl.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evo2twdt2zj30sc0gpadu.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evo2xbjxhaj30t60glgp8.jpg" alt=""></p>
<blockquote>
<p>两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载</p>
</blockquote>
<p>注意下图，getValue（）分别调用的哪一个函数<br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evo30rkv73j30sz0haq5q.jpg" alt=""></p>
<h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evo33vx0auj30r60hgtb6.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005BpcqWjw1evo36parqrj30rv0gwwgt.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005BpcqWjw1evo36www6pj30rz0gi773.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005BpcqWjw1evo371rts5j30t40gtacs.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下C语言应用编程学习笔记]]></title>
      <url>http://blog.acbingo.cn/2015/08/29/Linux%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><img src="http://g.hiphotos.baidu.com/baike/w%3D268/sign=172430c9f703738dde4a0b248b1bb073/f3d3572c11dfa9ec2436197e63d0f703918fc1bb.jpg" alt=""><br>借助<a href="https://www.shiyanlou.com/courses/24" target="_blank" rel="external">实验楼</a>平台学习这本书。<br><a id="more"></a></p>
<h1 id="GDB-使用"><a href="#GDB-使用" class="headerlink" title="GDB 使用"></a>GDB 使用</h1><h1 id="二、gdb-概-述"><a href="#二、gdb-概-述" class="headerlink" title="二、gdb 概 述"></a>二、gdb 概 述</h1><p>当程序编译完成后，它可能无法正常运行；或许程序会彻底崩溃；或许只是不能正常地运行某些功能；或许它的输出会被挂起；或许不会提示要求正常的输入。无论在何种情况下，跟踪这些问题，特别是在大的工程中，将是开发中最困难的部分，我们将学习gdb(GNU debugger)调试程序的方法，该程序是一个调试器，是用来帮助程序员寻找程序中的错误的软件。</p>
<p>gdb是GNU开发组织发布的一个强大的UNIX/Linux下的程序调试工具。或许，有人比较习惯图形界面方式的，像VC、BCB等IDE环境，但是在UNIX/Linux平台下做软件，gdb这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。 一般来说，gdb主要帮忙用户完成下面4个方面的功能：</p>
<p>启动程序，可以按照用户自定义的要求随心所欲的运行程序。<br>可让被调试的程序在用户所指定的调试的断点处停住 (断点可以是条件表达式)。<br>当程序停住时，可以检查此时程序中所发生的事。<br>动态地改变程序的执行环境。<br>从上面来看，gdb和一般的调试工具区别不大，基本上也是完成这些功能，不过在细节上，会发现gdb这个调试工具的强大。大家可能习惯了图形化的调试工具，但有时候，命令行的调试工具却有着图形化工具所不能完成的功能。­­­­­­­­­­­­­­­­­­­­­­­­­­­<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">//gdb.c</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int func(int n)</div><div class="line">&#123;</div><div class="line">    int sum=0,i;</div><div class="line">    for(i=0; i&lt;n; i++) &#123;</div><div class="line">        sum+=i;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    long result = 0;</div><div class="line">    for(i=1; i&lt;=100; i++) &#123;</div><div class="line">        result += i;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;result[1-100] = %ld \n&quot;, result );</div><div class="line">    printf(&quot;result[1-250] = %d \n&quot;, func(250) );</div><div class="line"> &#125;</div><div class="line">编译生成执行文件(Linux下)：</div><div class="line"></div><div class="line">$ gcc –g gdb.c -o testgdb</div><div class="line">使用gdb调试：</div><div class="line">$ gdb testgdb &lt;---------- 启动gdb</div><div class="line">.......此处省略一万行</div><div class="line"></div><div class="line">键入 l命令相当于list命令，从第一行开始列出源码：</div><div class="line">$ gdb testgdb</div><div class="line">.......此处省略一万行</div><div class="line"></div><div class="line">(gdb) l</div><div class="line">7       &#123;</div><div class="line">8           sum+=i;</div><div class="line">9       &#125;</div><div class="line">10      return sum;</div><div class="line">11 &#125;</div><div class="line">12</div><div class="line">13 int main(void)</div><div class="line">14 &#123;</div><div class="line">15      int i;</div><div class="line">16      long result = 0;</div><div class="line">(gdb)</div><div class="line">17      for(i=1; i&lt;=100; i++)</div><div class="line">18      &#123;</div><div class="line">19          result += i;</div><div class="line">20      &#125;</div><div class="line">21      printf(&quot;result[1-100] = %ld \n&quot;, result );</div><div class="line">22      printf(&quot;result[1-250] = %d \n&quot;, func(250) );</div><div class="line">23 &#125;</div><div class="line">(gdb) break 16 &lt;-------------------- 设置断点，在源程序第16行处。</div><div class="line">Breakpoint 1 at 0x804836a: file test.c, line 16.</div><div class="line">(gdb) break func &lt;-------------------- 设置断点，在函数func()入口处。</div><div class="line">Breakpoint 2 at 0x804832e: file test.c, line 5.</div><div class="line">(gdb) info break &lt;-------------------- 查看断点信息。</div><div class="line">Num Type           Disp Enb Address    What</div><div class="line">1   breakpoint     keep y   0x0804836a in main at test.c:16</div><div class="line">2   breakpoint     keep y   0x0804832e in func at test.c:5</div><div class="line">(gdb) r &lt;--------------------- 运行程序，run命令简写</div><div class="line">Starting program: /home/shiyanlou/testgdb</div><div class="line"></div><div class="line">Breakpoint 1, main () at test.c:16 &lt;---------- 在断点处停住。</div><div class="line">16                   long result = 0;</div><div class="line">(gdb) n &lt;--------------------- 单条语句执行，next命令简写。</div><div class="line">17                   for(i=1; i&lt;=100; i++)</div><div class="line">(gdb) n</div><div class="line">19                           result += i;</div><div class="line">(gdb) n</div><div class="line">17                   for(i=1; i&lt;=100; i++)</div><div class="line">(gdb) n</div><div class="line">19                           result += i;</div><div class="line">(gdb) n</div><div class="line">17                   for(i=1; i&lt;=100; i++)</div><div class="line">(gdb) c     &lt;--------------------- 继续运行程序，continue命令简写。</div><div class="line">Continuing.</div><div class="line">result[1-100] = 5050  &lt;----------程序输出。</div><div class="line"></div><div class="line">Breakpoint 2, func (n=250) at test.c:5</div><div class="line">5                   int sum=0,i;</div><div class="line">(gdb) n</div><div class="line">6                    for(i=0; i&lt;n; i++)</div><div class="line">(gdb) p I    &lt;--------------------- 打印变量i的值，print命令简写。</div><div class="line">$1 = 1107620064</div><div class="line">(gdb) n</div><div class="line">8                           sum+=i;</div><div class="line">(gdb) n</div><div class="line">6                    for(i=0; i&lt;n; i++)</div><div class="line">(gdb) p sum</div><div class="line">$2 = 0</div><div class="line">(gdb) bt     &lt;--------------------- 查看函数堆栈。</div><div class="line">#0 func (n=250) at test.c:6</div><div class="line">#1 0x080483b2 in main () at test.c:22</div><div class="line">#2 0x42015574 in __libc_start_main () from /lib/tls/libc.so.6</div><div class="line">(gdb) finish &lt;--------------------- 退出函数。</div><div class="line">Run till exit from #0 func (n=250) at test.c:6</div><div class="line">0x080483b2 in main () at test.c:22</div><div class="line">22   printf(&quot;result[1-250] = %d /n&quot;, func(250) );</div><div class="line">Value returned is $3 = 31125</div><div class="line">(gdb) c &lt;--------------------- 继续运行。</div><div class="line">Continuing.</div><div class="line">result[1-250] = 31125</div><div class="line"></div><div class="line">Program exited with code 027. &lt;--------程序退出，调试结束。</div><div class="line">(gdb) q     &lt;--------------------- 退出gdb。</div></pre></td></tr></table></figure></p>
<p>有了以上的感性认识，下面来系统地学习一下gdb。</p>
<h1 id="三、使-用-gdb"><a href="#三、使-用-gdb" class="headerlink" title="三、使 用 gdb"></a>三、使 用 gdb</h1><p>gdb主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，必须要把调试信息加到可执行文件中。使用编译器(cc/gcc/g++)的 -g 参数即可。如：</p>
<pre><code>$ gcc -g hello.c -o hello
$ g++ -g hello.cpp -o hello
</code></pre><p>如果没有-g，将看不见程序的函数名和变量名，代替它们的全是运行时的内存地址。当用-g把调试信息加入，并成功编译目标代码以后，看看如何用gdb来调试。 启动gdb的方法有以下几种：</p>
<p>gdb <program> program也就是执行文件，一般在当前目录下。<br>gdb <program> core 用gdb同时调试一个运行程序和core文件，core是程序非法执行后，core dump后产生的文件。<br>gdb <program> <pid> 如果程序是一个服务程序，那么可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试它。program应该在PATH环境变量中搜索得到。 gdb启动时，可以加上一些gdb的启动开关，详细的开关可以用gdb -help查看。下面只列举一些比较常用的参数： -symbols <file> -s <file> 从指定文件中读取符号表。 -se file 从指定文件中读取符号表信息，并把它用在可执行文件中。 -core <file> -c <file> 调试时core dump的core文件。 -directory <directory> -d <directory> 加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。<br>四、作业思考</directory></directory></file></file></file></file></pid></program></program></program></p>
<p>试着在上节课的例子中，使用 gdb 调试。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux学习笔记2]]></title>
      <url>http://blog.acbingo.cn/2015/08/28/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      <content type="html"><![CDATA[<p>linux操作命令的学习<br><a id="more"></a></p>
<h1 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h1><p>wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。</p>
<p>wc 命令是 word count 的缩写。</p>
<h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>wc [选项] [文件]
</code></pre><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td style="text-align:center">统计字节数</td>
</tr>
<tr>
<td>-l</td>
<td style="text-align:center">统计行数</td>
</tr>
<tr>
<td>-m</td>
<td style="text-align:center">统计字符数，这个标志不能与 -c 标志一起使用</td>
</tr>
<tr>
<td>-w</td>
<td style="text-align:center">统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</td>
</tr>
<tr>
<td>-L</td>
<td style="text-align:center">打印最长行的长度</td>
</tr>
</tbody>
</table>
<h2 id="常用范例："><a href="#常用范例：" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：统计文件的字节数、行数、字符数，可以使用如下命令：</p>
<pre><code>wc -c c.txt
wc -l c.txt
wc -m c.txt
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920359258" alt=""></p>
<p>注意每行结尾的换行符也算一个字符，空格也算一个字符。另外，由于系统采用 UTF-8 编码，所以一个汉字为 3 字节，9 个汉字加上一个换行，一共 28 个字节。</p>
<p>例二：统计文件的字节数、行数、字符数，只打印数字，不打印文件名，可以使用如下命令：</p>
<pre><code>cat c.txt | wc -c 
cat c.txt | wc -l 
cat c.txt | wc -m
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920413153" alt=""></p>
<p>例三：统计/bin 目录下的命令个数，可以使用如下命令：</p>
<pre><code>ls /bin | wc -l
</code></pre><h1 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h1><p>grep 是个很强大的命令，用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个 grep 命令选项来生成各种格式的输出。</p>
<p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>grep 可用于 shell 脚本，因为 grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<h2 id="命令格式：-1"><a href="#命令格式：-1" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>grep [选项] pattern [file]
</code></pre><h2 id="常用参数：-1"><a href="#常用参数：-1" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td style="text-align:center">计算找到 ‘搜寻字符串’(即 pattern) 的次数</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:center">忽略大小写的不同，所以大小写视为相同</td>
</tr>
<tr>
<td>-n</td>
<td style="text-align:center">输出行号</td>
</tr>
<tr>
<td>-v</td>
<td style="text-align:center">反向选择，打印不匹配的行</td>
</tr>
<tr>
<td>-r</td>
<td style="text-align:center">递归搜索</td>
</tr>
<tr>
<td>–color=auto</td>
<td style="text-align:center">将找到的关键词部分加上颜色显示</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-1"><a href="#常用范例：-1" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：将/etc/passwd 文件中出现 root 的行取出来，关键词部分加上颜色显示，可以使用如下命令：</p>
<pre><code>grep “root” /etc/passwd --color=auto
cat /etc/passwd | grep “root” --color=auto
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920596878" alt=""></p>
<p>例二：将/etc/passwd 文件中没有出现 root 和 nologin 的行取出来，可以使用如下命令：</p>
<pre><code>grep -v “root” /etc/passwd | grep -v “nologin”
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920644630" alt=""></p>
<p>例三：在当前目录下递归搜索文件中包含 main()的文件，经常用于查找某些函数位于哪些源代码文件中，可以使用如下命令：</p>
<pre><code>grep -r “main()” .
</code></pre><h1 id="正则表达式与-grep-命令"><a href="#正则表达式与-grep-命令" class="headerlink" title="正则表达式与 grep 命令"></a>正则表达式与 grep 命令</h1><p>正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配文件和路径名的 shell 通配符比较相似，但其规模更大。许多命令行工具和大多数的编程语言都支持正则表达式，以此来帮助解决文本操作问题。</p>
<p>正则表达式元字符由以下字符组成：</p>
<pre><code>^ $ . [ ] { } - ? * + ( ) | \ 
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920809160" alt=""></p>
<h2 id="常用范例：-2"><a href="#常用范例：-2" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：利用 Linux 系统自带的字典查找一个五个字母的单词，第三个字母为 j,最后一个字母为 r ，/usr/share/dict 目录下存放字典文件，可以使用如下命令：</p>
<pre><code>grep ‘^..j.r$’ linux.words
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920858625" alt=""></p>
<p>例二：验证固定电话，打印符合条件的电话，固定电话格式基本都是带有 0 的区号+连接符“-”＋电话号码，另外还有可能有分机号，区号有 3 位、4 位，电话号码有 7 位和 8 位的，可以使用如下命令：</p>
<pre><code>grep “^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$” telphone.txt
</code></pre><p>区号：前面一个 0，后面跟 2-3 位数字 ： 0[0-9]{2,3}</p>
<p>电话号码：7-8 位数字： [0-9]{7,8}</p>
<p>分机号：一般都是 3-4 位数字： [0-9]{3,4}<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920922420" alt=""><br>注意执行下面的命令时没有任何匹配输出，这是因为没有加-E 选项，那例一没加为什么可以呢，这是因为 grep 把.当成 shell 通配符，不是正则表达式的元字符。<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid353time1419920941988" alt=""></p>
<h1 id="cut-命令"><a href="#cut-命令" class="headerlink" title="cut 命令"></a>cut 命令</h1><p>cut 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。</p>
<p>如果一行数据包含多个字段（多列），现在想要提取其中的一列或多列，这是 cut 命令就可以大显身手了。</p>
<h2 id="命令格式：-2"><a href="#命令格式：-2" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>cut [选项] [文件名]
</code></pre><h2 id="常用参数：-2"><a href="#常用参数：-2" class="headerlink" title="常用参数："></a>常用参数：</h2><p>|参数|    描述|<br>|-b|    以字节为单位进行分割|<br>|-c|    以字符为单位进行分割|<br>|-d|    自定义分隔符，默认为制表符|<br>|-f|    自定义字段|<br>|–complement|    抽取整个文本行，除了那些由 -c 或 -f 选项指定的文本|</p>
<h2 id="常用范例：-3"><a href="#常用范例：-3" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：取出 student.txt 文件中的第一列和第三列，可以使用如下命令：</p>
<pre><code>cut -f 1,3 -d ‘ ’ student.txt
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420779726136" alt=""></p>
<p>例二：取出 student.txt 文件中的第一列，可以使用如下命令：</p>
<pre><code>cut -f 1 -d ‘ ’ student.txt
</code></pre><p>例三：取出 student.txt 文件中的前三列，可以使用如下命令：</p>
<pre><code>cut -f 1-3 -d ‘ ’ student.txt
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420779770034" alt=""></p>
<p>例四：取出 student.txt 文件中除第一列的其他列，可以使用如下命令：</p>
<pre><code>cut -f 1 -d ‘ ’ student.txt --complement
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420779805413" alt=""><br>例五：给任意一字符串 str，取出其最后一个字符，可以使用如下命令：</p>
<pre><code>num=$(echo -n $str | wc -c)
echo -n $str | cut -b $num 
或者
echo -n $str | cut -b `echo -n $str | wc -c`
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420779859931" alt=""></p>
<h1 id="paste-命令"><a href="#paste-命令" class="headerlink" title="paste 命令"></a>paste 命令</h1><p>paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。</p>
<h2 id="命令格式：-3"><a href="#命令格式：-3" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>paste [选项] [文件名]
</code></pre><h2 id="常用参数：-3"><a href="#常用参数：-3" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s</td>
<td style="text-align:center">将每个文件合并成行而不是按行粘贴</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:center">自定义分隔符，默认为制表符</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-4"><a href="#常用范例：-4" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：将 student.txt 和 telphone.txt 文件中的内容按列拼接，可以使用如下命令：</p>
<pre><code>paste student.txt telphone.txt
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420780031604" alt=""></p>
<p>例二：将 student.txt 和 telphone.txt 文件中的内容按列拼接，指定分隔符为’：’，可以使用如下命令：</p>
<pre><code>paste student.txt telphone.txt -d ‘:’
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420780078087" alt=""></p>
<p>例三：将 student.txt 和 telphone.txt 文件中的内容各自拼接成一行，可以使用如下命令：</p>
<p>paste -s student.txt telphone.txt<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid369time1420780124133" alt=""></p>
<h1 id="tr-命令"><a href="#tr-命令" class="headerlink" title="tr 命令"></a>tr 命令</h1><p>tr 命令常被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程。tr 从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。</p>
<p>tr 只能通过 stdin（标准输入），而无法通过命令行参数来接受输入。</p>
<p>tr 是 translate（转换）的缩写。</p>
<h2 id="命令格式：-4"><a href="#命令格式：-4" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>tr [选项] SET1 SET2
</code></pre><p>将来自 stdin 的输入字符从 SET1 映射到 SET2，并将其输出写入 stdout（标准输出）。SET1 和 SET2 是字符类或字符集。如果两个字符集的长度不相等，那么 SET2 会不断重复其最后一个字符，直到长度与 SET1 相同。如果 SET2 的长度大于 SET1，那么在 SET2 中超出 SET1 的那部分字符则全部被忽略。</p>
<h2 id="常用参数：-4"><a href="#常用参数：-4" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td style="text-align:center">删除匹配 SET1 的内容，并不作替换</td>
</tr>
</tbody>
</table>
<p>常用范例：</p>
<p>例一：将输入的字符大写转换为小写，可以使用如下命令：</p>
<pre><code>echo ‘THIS IS SHIYANLOU!’ | tr ‘A-Z’ ‘a-z’
</code></pre><p>例二：将输入的字符中的数字删除，可以使用如下命令：</p>
<pre><code>echo ‘THIS 123 IS S1HIY5ANLOU!’ | tr -d ‘0-9’
</code></pre><p>例三：tr 命令的一个有趣的用法是执行 ROT13 文本编码。ROT13 是一款微不足道的基于一种简易的替换暗码的加密类型。把 ROT13 称为“加密”是大方的，“文本模糊处理”更准确些。有时候它被用来隐藏文本中潜在的攻击内容。这个方法就是简单地把每个字符在字母表中向前移动 13 位。因为移动的位数是可能的 26 个字符的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。可以使用如下命令：</p>
<pre><code>#加密
echo ‘shiyanlou’ |  tr  ‘a-zA-Z’  ‘n-za-mN-ZA-M’ 
fuvlnaybh
#解密
echo ‘fuvlnaybh’ | tr  ‘a-zA-Z’  ‘n-za-mN-ZA-M’ 
shiyanlou
</code></pre><h1 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h1><p>同文本文件打交道时，总避不开排序，那是因为对于文本处理任务而言，排序（sort）可以起到不小的作用。sort 命令能够帮助我们对文本文件和 stdin 进行排序操作。通常，它会结合其他命令来生成所需要的输出。</p>
<h2 id="命令格式：-5"><a href="#命令格式：-5" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>sort [选项] [文件名]
</code></pre><h2 id="常用参数：-5"><a href="#常用参数：-5" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td style="text-align:center">基于字符串的长度来排序,使用此选项允许根据数字值排序，而不是字母值</td>
</tr>
<tr>
<td>-k</td>
<td style="text-align:center">指定排序关键字</td>
</tr>
<tr>
<td>-b</td>
<td style="text-align:center">默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序</td>
</tr>
<tr>
<td>-m</td>
<td style="text-align:center">只合并多个输入文件</td>
</tr>
<tr>
<td>-r</td>
<td style="text-align:center">按相反顺序排序,结果按照降序排列，而不是升序</td>
</tr>
<tr>
<td>-t</td>
<td style="text-align:center">自定义分隔符，默认为制表符</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-5"><a href="#常用范例：-5" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：列出/usr/share/目录下使用空间最多的前 10 个目录文件，可以使用如下命令：</p>
<pre><code>du -s /usr/share/* | sort -nr | head -10
</code></pre><p>du -s /usr/share/* 命令显示/usr/share/目录下所有文件和目录的磁盘使用空间，目录包含目录下的子目录和文件<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420780699046" alt=""></p>
<p>例二：ls 命令能显示目录下文件的详细信息，包含空间使用大小，但与 du 命令不同的是，ls 命令不计算目录下的子目录和文件的大小。ls 显示格式如下:</p>
<pre><code>-rwxrwxrwx   1  root   root  542  11 月   29  test.php
</code></pre><p>现在想要对 ls 命令输出信息中的空间使用大小字段进行排序，可以使用如下命令：</p>
<pre><code>ls -l /usr/bin/ | sort -nr -k 5 | head -10
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420780744468" alt=""></p>
<p>例三：首先来看下下面的例子：<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420780803123" alt=""><br>由于 11 由 1 开始，比 5 大，所以排在 5 的前面。这时排序可以通过自定义排序字段来排序。使用下面的命令就可以解决。</p>
<p>sort  -k 1,1  -k 2n data.txt<br>第一个-k 选项指明只对第一个字段排序，1,1 意味着“始于并且结束于第一个字段”。 第二个-k 选项 2n 表示对第二个字段按数值排序。 还有一种格式，如-k 3.4，表示始于第三个字段的第四个字符，按数值排序。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420780839828" alt=""></p>
<p>-k 选项的语法格式如下：</p>
<pre><code>[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]
</code></pre><p>这个语法格式可以被其中的逗号（“，”）分为两大部分，Start 部分和 End 部分。</p>
<p>先给你灌输一个思想，那就是“如果不设定 End 部分，那么就认为 End 被设定为行尾”。这个概念很重要的，但往往你不会重视它。</p>
<p>Start 部分也由三部分组成，其中的 Modifier 部分就是类似 n 和 r 的选项部分。我们重点说说 Start 部分的 FStart 和 CStart。 FStart.CStart，其中 FStart 就是表示使用的域，而 CStart 则表示在 FStart 域中从第几个字符开始算“排序首字符”。CStart 是可以省略的，省略的话就表示从本域的开头部分开始。之前例子中的-k 5 就是省略了 CStart 的例子。</p>
<p>同理，在 End 部分中，你可以设定 FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将 CEnd 设定为 0(零)，也是表示结尾到“域尾”。</p>
<h1 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h1><p>uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。</p>
<p>uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与 sort 命令结合起来使用。</p>
<p>uniq 命令是 unique 的缩写。</p>
<h2 id="命令格式：-6"><a href="#命令格式：-6" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>uniq [选项] [文件名]
</code></pre><h2 id="常用参数：-6"><a href="#常用参数：-6" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td style="text-align:center">在每行前加上表示相应行目出现次数的前缀编号</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:center">只输出重复的行</td>
</tr>
<tr>
<td>-u</td>
<td style="text-align:center">只显示唯一的行</td>
</tr>
<tr>
<td>-D</td>
<td style="text-align:center">显示所有重复的行</td>
</tr>
<tr>
<td>-f</td>
<td style="text-align:center">比较时跳过前 n 列</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:center">比较的时候不区分大小写</td>
</tr>
<tr>
<td>-s</td>
<td style="text-align:center">比较时跳过前 n 个字符</td>
</tr>
<tr>
<td>-w</td>
<td style="text-align:center">对每行第 n 个字符以后的内容不作对照</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-6"><a href="#常用范例：-6" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：找出/bin 目录和/usr/bin 目录下所有相同的命令，可以使用如下命令：</p>
<pre><code>ls /bin /usr/bin  | sort | uniq -d
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420781011797" alt=""></p>
<p>例二：现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数。<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420781055838" alt=""><br>实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下：</p>
<pre><code>sort -k 4.1n,4.1n student.txt | uniq -c -f 3 -w 2
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420781089813" alt=""></p>
<p>sort -k 4.1n,4.1n 表示对第四个字段的第一个字符按数值排序。</p>
<p>uniq -c -f 3 -w 2 中-f 3 表示跳过前三列的比较，那么现在只剩下最后一列，-w 2 表示第 2 个字符后的内容不做比较，为什么是 2 呢，因为跳过前三列时并没有跳过最后一列前面的空格分隔符，区号前都还有一个空格。</p>
<h1 id="join-命令"><a href="#join-命令" class="headerlink" title="join 命令"></a>join 命令</h1><p>join 命令类似于 paste，它会往文件中添加列，但是它使用了独特的方法来完成。一个 join 操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的数据结合起来，得到一个期望的结果。这个 join 命令执行相同的操作，它把来自于多个基于共享关键域的文件的数据结合起来。</p>
<p>通俗地说，就是将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行。</p>
<h2 id="命令格式：-7"><a href="#命令格式：-7" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>join [选项] 文件 1 文件 2
</code></pre><h2 id="常用参数：-7"><a href="#常用参数：-7" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-j FIELD</td>
<td style="text-align:center">等同于 -1 FIELD -2 FIELD,-j 指定一个域作为匹配字段</td>
</tr>
<tr>
<td>-1 FIELD</td>
<td style="text-align:center">以 file1 中 FIELD 字段进行匹配</td>
</tr>
<tr>
<td>-2 FIELD</td>
<td style="text-align:center">以 file2 中 FIELD 字段进行匹配</td>
</tr>
<tr>
<td>-t</td>
<td style="text-align:center">自定义分隔符，默认为制表符</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-7"><a href="#常用范例：-7" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：将两个文件中的第一个字段作为匹配字段，连接两个文件，可以使用如下命令：</p>
<pre><code>join  a.txt  b.txt
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420781241207" alt=""></p>
<p>例二：指定两个文件的第三个字段为匹配字段，连接两个文件，可以使用如下命令：</p>
<p>join  -1 3 -2 3 c.txt d.txt<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid370time1420781274456" alt=""><br>从上面的结果可以看到，一开始对 a.txt 和 b.txt 文件内容执行 join 命令时报错，这是因为 join 命令跟 uniq 命令一样，只能用于排过序的数据。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bingo的VIM]]></title>
      <url>http://blog.acbingo.cn/2015/08/27/Bingo's%20exVim/</url>
      <content type="html"><![CDATA[<h1 id="Bingo的VIM"><a href="#Bingo的VIM" class="headerlink" title="Bingo的VIM"></a>Bingo的VIM</h1><p>Bingo的VIM。All In Vim!目前仅适配windows版本，正在努力兼容linux。<br><img src="http://i3.tietuku.com/71e2f001fa795e33.png" alt=""><br><a id="more"></a></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://github.com/ACBingo/bingo-vim" target="_blank" rel="external">github</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="简易安装"><a href="#简易安装" class="headerlink" title="简易安装"></a>简易安装</h2><ol>
<li>点击右侧Download Zip按钮，下载后解压在e盘的根目录下，将e:/vim加入环境变量。(务必是e盘根目录)</li>
<li>下载ycm插件所需的<a href="http://pan.baidu.com/s/1mgs0RWW" target="_blank" rel="external">额外文件</a>.将安装包中的ctags58文件夹以及TDM-GCC-64文件夹整个复制到e:/vim目录下.将安装包内的bundle.zip下的所有文件复制到e:/vim/vimfiles/bundle目录下</li>
<li>安装python 2.7.6,并将其安装目录加入系统path路径</li>
<li><p>安装MinGW，并将其bin目录加入系统path路径。若你安装了codeblocks，可以选择直接将codeblocks自带MinGW加入系统路径。例如，我的路径为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files (x86)\CodeBlocks\MinGW\bin</div></pre></td></tr></table></figure>
</li>
<li><p>进入./vim/vim74文件夹下，将快捷方式gvim.exe移动到你的桌面上。 </p>
</li>
<li>进入./vim文件夹下，用gvim打开_vimrc文件找到这一段<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;if g:isWIN</div><div class="line">&quot;    exec &apos;cd &apos; . fnameescape(&apos;f:\workspace&apos;) </div><div class="line">&quot;else </div><div class="line">&quot;    exec &apos;cd &apos; . fnameescape(&apos;~\workspace&apos;)</div><div class="line">&quot;endif</div></pre></td></tr></table></figure>
</li>
</ol>
<p>将其反注释并改为自己的默认工作目录(若不存在，需要自己新建一个)。</p>
<ol>
<li>打开gvim。执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginClean</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行完毕后。执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<ol>
<li>至此，安装完毕。享受编程的愉悦吧。有任何问题欢迎访问我的博客acbingo.cn进行留言咨询。<h1 id="功能介绍与插件说明"><a href="#功能介绍与插件说明" class="headerlink" title="功能介绍与插件说明"></a>功能介绍与插件说明</h1>Todo<h2 id="先说几个功能先用着"><a href="#先说几个功能先用着" class="headerlink" title="先说几个功能先用着"></a>先说几个功能先用着</h2>目前支持c,cpp,java,python的编译与运行。F9或是\rr键一键编译并运行<br>支持ycm自动补全。没错！vim所有插件中最最最吊的也是最最最最难配置的插件，ycm For windows，该vim已经帮你编译并配置好了。<br>F12一键换肤<br>F3打开文件树<br>ctrl+p 打开文件搜索功能<br>F2打开工具栏<br>普通模式下，tb，打开tagbar，tl，打开tlist<br>支持snippets补全，在cpp文件下，键入init然后按tab键试试？在md文件下呢？更多补全命令先自行参考snippets文件夹<br>ctrl+up,ctrl+down，透明度调整<br>alt+up，alt+down，字号调整<br>暂时想到这么多。。。。</li>
</ol>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢<a href="https://github.com/ruchee/vimrc" target="_blank" rel="external">Ruchee</a><br>感谢<a href="">Fingertap</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux下去掉^M的方法]]></title>
      <url>http://blog.acbingo.cn/2015/08/27/linux%E4%B8%8B%E5%8E%BB%E6%8E%89%5EM%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在linux下，不可避免的会用VIM打开一些windows下编辑过的文本文件。我们会发现文件的每行结尾都会有一个^M符号，这是因为 DOS下的编辑器和Linux编辑器对文件行末的回车符处理不一致<br><a id="more"></a><br>假设你要修改的文件名为filename</p>
<h1 id="方法一，单文件"><a href="#方法一，单文件" class="headerlink" title="方法一，单文件"></a>方法一，单文件</h1><p>利用vim<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$vim filename</div></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:set fileformat=unix</div><div class="line">:w</div><div class="line">:q</div></pre></td></tr></table></figure></p>
<h1 id="方法二，多文件"><a href="#方法二，多文件" class="headerlink" title="方法二，多文件"></a>方法二，多文件</h1><p>上个方法适合单文件的转换，但是要是想批量转换一整个文件夹怎么办呢？<br>假设你要转换的文件夹的路径为/home/test<br>这里要用到dos2unix命令<br>首先安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install dos2unix</div></pre></td></tr></table></figure></p>
<p>然后利用xargs与通道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo find /home/text/ -name &quot;*.*&quot; | xargs dos2unix</div></pre></td></tr></table></figure></p>
<p>若是只想转换后缀名为.vim的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo find /home/text/ -name &quot;*.vim&quot; | xargs dos2unix</div></pre></td></tr></table></figure></p>
<p>正则表达式的强大用处就体现出来了！</p>
<p>另外运用xargs命令，可以达到批量执行某些不自带递归的命令</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim的持久撤销功能]]></title>
      <url>http://blog.acbingo.cn/2015/08/27/vim%E7%9A%84%E6%8C%81%E4%B9%85%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="vim的持久撤销"><a href="#vim的持久撤销" class="headerlink" title="vim的持久撤销"></a>vim的持久撤销</h1><p>Vim 7.3后 提供 持久撤销 (Persistent Undo) 功能，即使文件关闭后，再次打开时仍然可以撤销文件关闭之前的编辑历史。要使用这一功能，在 vimrc 中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot; 重启后撤销历史可用 persistent undo </div><div class="line">set undofile</div><div class="line">set undodir=$VIM\vimfiles\undodir &quot;请手动创建该文件夹</div><div class="line">set undolevels=1000 &quot;maximum number of changes that can be undone</div></pre></td></tr></table></figure></p>
<p>然后，进入./vimfile/目录，新建一个名为 undodir 的文件夹<br>然后大喊vim大法好！<br>Done！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux学习笔记]]></title>
      <url>http://blog.acbingo.cn/2015/08/25/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir [选项]目录</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-m –mode=模式</td>
<td style="text-align:center">设定权限&lt;模式&gt;</td>
</tr>
<tr>
<td>-p –parents</td>
<td style="text-align:center">可以是一个路径名称。若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录</td>
</tr>
<tr>
<td>-v –verbose</td>
<td style="text-align:center">每次创建新目录都显示信息</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h1><hr>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f –force</td>
<td style="text-align:center">忽略不存在的文件，从不给出提示</td>
</tr>
<tr>
<td>-i –interactive</td>
<td style="text-align:center">进行交互式删除</td>
</tr>
<tr>
<td>-r –recursive</td>
<td style="text-align:center">指示 rm 将参数中列出的全部目录和子目录均递归地删除</td>
</tr>
<tr>
<td>-v –verbose</td>
<td style="text-align:center">详细显示进行的步骤</td>
</tr>
</tbody>
</table>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>思考一下下面命令有什么作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;</div></pre></td></tr></table></figure></p>
<h1 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv [选项] 源文件或目录 目标文件或目录</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">概述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b –back</td>
<td style="text-align:center">若需覆盖文件，则覆盖前先行备份</td>
</tr>
<tr>
<td>-f –force</td>
<td style="text-align:center">如果目标文件已经存在，不会询问而直接覆盖</td>
</tr>
<tr>
<td>-i –interactive</td>
<td style="text-align:center">若目标文件已经存在时，就会询问是否覆盖</td>
</tr>
<tr>
<td>-u –update</td>
<td style="text-align:center">若目标文件已经存在，且源文件比较新，才会更新</td>
</tr>
<tr>
<td>-t –target</td>
<td style="text-align:center">该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td>
</tr>
</tbody>
</table>
<ol>
<li><p>将文件 shiyanlou.log 重命名为 zhou.log，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv   shiyanlou.log   zhou.log</div></pre></td></tr></table></figure>
</li>
<li><p>将文件 zhou.log 移动到 test 目录下(test 目录必须已经存在，否则执行重命名)，可以使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv  zhou.log  test</div></pre></td></tr></table></figure>
</li>
<li><p>将文件 a.txt 移动到 test1 目录下，如果文件存在，覆盖前会询问是否覆盖，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv  -i  a.txt  test1</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h1><hr>
<p>cp 命令用来复制文件或者目录，是 Linux 系统中最常用的命令之一。一般情况下，shell 会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i 参数。但是如果是在 shell 脚本中执行 cp 时，没有-i 参数时不会询问是否覆盖。这说明命令行和 shell 脚本的执行方式有些不同。 cp 命令是 copy 的缩写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp [选项] 源文件 目录 cp [选项] -t 目录 源文件</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t –target-directory</td>
<td style="text-align:center">指定目标目录</td>
</tr>
<tr>
<td>-i –interactive</td>
<td style="text-align:center">覆盖前询问(使前面的 -n 选项失效)</td>
</tr>
<tr>
<td>-n –no-clobber</td>
<td style="text-align:center">不要覆盖已存在的文件(使前面的 -i 选项失效)</td>
</tr>
<tr>
<td>-s –symbolic-link</td>
<td style="text-align:center">对源文件建立符号链接，而非复制文件</td>
</tr>
<tr>
<td>-f –force</td>
<td style="text-align:center">强行复制文件或目录， 不论目的文件或目录是否已经存在</td>
</tr>
<tr>
<td>-u –update</td>
<td style="text-align:center">使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td>
</tr>
</tbody>
</table>
<p> 例一：对文件 shiyanlou.log 建立一个符号链接 zhou.log，可以使用如下命令：</p>
<pre><code>cp   -s   shiyanlou.log   zhou.log
</code></pre><p>例二：将 test1 目录下的所有文件复制到 test2 目录下，覆盖前询问，可以使用如下命令：</p>
<pre><code>cp  -i  test1/*  test2
</code></pre><p>例三：将 test1 目录下的最近更新的文件复制到 test2 目录下，覆盖前询问，可以使用如下命令：</p>
<pre><code>cp  -iu  test1/*  test2
</code></pre><h1 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h1><p>cat 命令的功能是将文件或标准输入组合输出到标准输出。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 cat 命令是 concatenate 的缩写。</p>
<p>命令格式：</p>
<pre><code>cat [选项] [文件]
</code></pre><p>常用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A –show-all</td>
<td style="text-align:center">等价于 -vET</td>
</tr>
<tr>
<td>-b –number-nonblank</td>
<td style="text-align:center">对非空输出行编号</td>
</tr>
<tr>
<td>-e</td>
<td style="text-align:center">等价于 -vE</td>
</tr>
<tr>
<td>-E –show-ends</td>
<td style="text-align:center">在每行结束处显示 $</td>
</tr>
<tr>
<td>-n –number</td>
<td style="text-align:center">对输出的所有行编号,由 1 开始对所有输出的行数编号</td>
</tr>
<tr>
<td>-s –squeeze-blank</td>
<td style="text-align:center">有连续两行以上的空白行，就代换为一行的空白行</td>
</tr>
<tr>
<td>-t</td>
<td style="text-align:center">与 -vT 等价</td>
</tr>
<tr>
<td>-T –show-tabs</td>
<td style="text-align:center">将跳格字符显示为 ^I</td>
</tr>
<tr>
<td>-u</td>
<td style="text-align:center">(被忽略)</td>
</tr>
<tr>
<td>-v –show-nonprinting</td>
<td style="text-align:center">使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</td>
</tr>
</tbody>
</table>
<p>常用范例：</p>
<p>例一：把 shiyanlou.log 的文件内容加上行号后输入 zhou.log 这个文件里，可以使用如下命令：</p>
<pre><code>cat -n shiyanlou.log &gt; zhou.log
</code></pre><p>例二：把 shiyanlou.log 的文件内容加上行号后输入 zhou.log 这个文件里，多行空行换成一行输出，可以使用如下命令：</p>
<pre><code>cat -ns shiyanlou.log &gt; zhou.log
</code></pre><p>例三：将 zhou.log 的文件内容反向显示，可以使用如下命令：</p>
<pre><code>tac  zhou.log
</code></pre><p>说明：tac 是将 cat 反写过来，所以它的功能就跟 cat 相反，cat 是由第一行到最后一行连续显示在屏幕上，而 tac 则是由最后一行到第一行反向在屏幕上显示出来。</p>
<h1 id="nl-命令"><a href="#nl-命令" class="headerlink" title="nl 命令"></a>nl 命令</h1><p>nl 命令在 linux 系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号。其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。<br>nl 命令是 number of lines 的缩写。</p>
<h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>nl [选项] [文件]
</code></pre><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>指定行号指定的方式，主要有两种：</td>
</tr>
<tr>
<td>-b a</td>
<td>表示不论是否为空行，也同样列出行号(类似 cat -n)</td>
</tr>
<tr>
<td>-b t</td>
<td>如果有空行，空的那一行不要列出行号(默认值)</td>
</tr>
<tr>
<td>-n</td>
<td>列出行号表示的方法，主要有三种：</td>
</tr>
<tr>
<td>-n ln</td>
<td>行号在屏幕的最左方显示</td>
</tr>
<tr>
<td>-n rn</td>
<td>行号在自己栏位的最右方显示，且不加 0</td>
</tr>
<tr>
<td>-n rz</td>
<td>行号在自己栏位的最右方显示，且加 0</td>
</tr>
<tr>
<td>-w</td>
<td>行号栏位的占用的位数</td>
</tr>
</tbody>
</table>
<p>常用范例：</p>
<p>例一：把 shiyanlou.log 的文件内容加上行号后显示，空行不加行号，可以使用如下命令：</p>
<pre><code>nl -b t shiyanlou.log
</code></pre><p>例二：把 shiyanlou.log 的文件内容加上行号后显示，行号分别在屏幕最左方、最右方不加 0 和最右方加 0 显示，可以使用如下命令：</p>
<pre><code>nl -n ln shiyanlou.log
nl -n rn shiyanlou.log
nl -n rz shiyanlou.log
</code></pre><p>例三：把 shiyanlou.log 的文件内容加上行号后显示，行号在屏幕最右方加 0 显示，行号栏目占位数为 3，可以使用如下命令：</p>
<pre><code>nl -n rz -w 3 shiyanlou.log
</code></pre><h1 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h1><p>more 命令，功能类似 cat ，cat 命令是将整个文件的内容从上到下显示在屏幕上。 more 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按空白键（space）往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more 命令从前向后读取文件，因此在启动时就加载整个文件。</p>
<h2 id="命令格式：-1"><a href="#命令格式：-1" class="headerlink" title="命令格式："></a>命令格式：</h2><p>more [选项] 文件</p>
<h2 id="常用参数：-1"><a href="#常用参数：-1" class="headerlink" title="常用参数："></a>常用参数：</h2><p>|参数    |描述|<br>|+n|    从笫 n 行开始显示|<br>| —— |:——:|<br>|-n    |定义屏幕大小为 n 行|<br>|+/pattern|    在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示|<br>|-c    |从顶部清屏，然后显示|<br>|-d    |提示“Press space to continue，’q’ to quit”，禁用响铃功能|<br>|-p    |通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似|<br>|-s    |把连续的多个空行显示为一行|<br>|-u    |把文件内容中的下画线去掉|</p>
<h2 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h2><table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td style="text-align:center">输出当前行的行号</td>
</tr>
<tr>
<td>q</td>
<td style="text-align:center">退出 more</td>
</tr>
<tr>
<td>空格键</td>
<td style="text-align:center">向下滚动一屏</td>
</tr>
<tr>
<td>b</td>
<td style="text-align:center">返回上一屏</td>
</tr>
</tbody>
</table>
<h2 id="常用范例："><a href="#常用范例：" class="headerlink" title="常用范例："></a>常用范例：</h2><p>下面示例中用到的 shiyanlou.log 文件内容如下：</p>
<p>例一：从第五行开始显示 shiyanlou.log 文件中的内容，可以使用如下命令：</p>
<pre><code>more +5 shiyanlou.log
</code></pre><p>例二：从 shiyanlou.log 文件中查找第一个出现”g”字符串的行，并从该处前两行开始显示输出，可以使用如下命令：</p>
<pre><code>more +/g shiyanlou.log
</code></pre><p>例三：设定每屏行数为 5，可以使用如下命令：</p>
<pre><code>more -5 shiyanlou.log
</code></pre><p>例四：使用 ll 和 more 命令显示/etc 目录信息，可以使用如下命令：</p>
<pre><code>ll /etc | more -10
</code></pre><p>每页显示 10 个文件信息，按 Ctrl+F 或者 空格键 将会显示下 10 条文件信息。</p>
<h1 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h1><blockquote>
<p>less 工具也是对文件或其它输出进行分页显示的工具，应该说是 linux 正统查看文件内容的工具，功能极其强大。</p>
</blockquote>
<h2 id="命令格式：-2"><a href="#命令格式：-2" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>less [选项] 文件
</code></pre><h2 id="常用参数：-2"><a href="#常用参数：-2" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td style="text-align:center">当文件显示结束后，自动离开</td>
</tr>
<tr>
<td>-f</td>
<td style="text-align:center">强迫打开特殊文件，例如外围设备代号、目录和二进制文件</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:center">忽略搜索时的大小写</td>
</tr>
<tr>
<td>-m</td>
<td style="text-align:center">显示类似 more 命令的百分比</td>
</tr>
<tr>
<td>-N</td>
<td style="text-align:center">显示每行的行号</td>
</tr>
<tr>
<td>-s</td>
<td style="text-align:center">显示连续空行为一行</td>
</tr>
</tbody>
</table>
<h2 id="常用操作：-1"><a href="#常用操作：-1" class="headerlink" title="常用操作："></a>常用操作：</h2><table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/字符串</td>
<td style="text-align:center">向下搜索“字符串”的功能</td>
</tr>
<tr>
<td>?字符串</td>
<td style="text-align:center">向上搜索“字符串”的功能</td>
</tr>
<tr>
<td>n</td>
<td style="text-align:center">重复前一个搜索（与 / 或 ? 有关）</td>
</tr>
<tr>
<td>N</td>
<td style="text-align:center">反向重复前一个搜索（与 / 或 ? 有关）</td>
</tr>
<tr>
<td>b</td>
<td style="text-align:center">向前翻一页</td>
</tr>
<tr>
<td>d</td>
<td style="text-align:center">向后翻半页</td>
</tr>
<tr>
<td>q</td>
<td style="text-align:center">退出 less 命令</td>
</tr>
<tr>
<td>空格键</td>
<td style="text-align:center">向后翻一页</td>
</tr>
<tr>
<td>向上键</td>
<td style="text-align:center">向上翻动一行</td>
</tr>
<tr>
<td>向下键</td>
<td style="text-align:center">向下翻动一行</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-1"><a href="#常用范例：-1" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：显示 shiyanlou.log 文件中的内容，并显示行号，可以使用如下命令：</p>
<pre><code>less -N shiyanlou.log
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/linux35.png" alt=""></p>
<p>例二：显示 shiyanlou.log 文件中的内容，搜索字符串”shiyanlou”，可以使用如下命令：</p>
<pre><code>less  shiyanlou.log
/shiyanlou
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/linux226.png" alt=""><br><img src="https://dn-anything-about-doc.qbox.me/linux37.png" alt=""></p>
<p>例三：ps 查看进程信息并通过 less 分页显示 ，可以使用如下命令：</p>
<pre><code>ps -f | less
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/linux38.png" alt=""></p>
<h1 id="less-与-cat-和-more-的区别："><a href="#less-与-cat-和-more-的区别：" class="headerlink" title="less 与 cat 和 more 的区别："></a>less 与 cat 和 more 的区别：</h1><p>cat 命令功能用于显示整个文件的内容，单独使用没有翻页功能。因此经常和 more 命令搭配使用，cat 命令还有就是可以将数个文件合并成一个文件的功能。 more 命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 q 键停止显示。</p>
<p>less 命令功能：less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 q 键即可。 其实这三个命令除了 cat 命令有合并文件的功能，其余功能上相近，只是从浏览习惯和显示方式上有所不同。</p>
<h1 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h1><p>head 命令就像它的名字一样浅显易懂，主要是用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>
<h2 id="命令格式：-3"><a href="#命令格式：-3" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>head [选项] [文件]
</code></pre><h2 id="常用参数：-3"><a href="#常用参数：-3" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td style="text-align:center">隐藏文件名</td>
</tr>
<tr>
<td>-v</td>
<td style="text-align:center">显示文件名</td>
</tr>
<tr>
<td>-c&lt;字节&gt;</td>
<td style="text-align:center">显示字节数</td>
</tr>
<tr>
<td>-n&lt;行数&gt;</td>
<td style="text-align:center">显示的行数</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-2"><a href="#常用范例：-2" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：显示 shiyanlou.log 文件中的前 5 行内容，可以使用如下命令： head -n 5 shiyanlou.log </p>
<p>例二：显示 shiyanlou.log 和 zhou.log 文件中的前 5 行内容，可以使用如下命令： head -n 5 shiyanlou.log zhou.log </p>
<p>例三：显示 shiyanlou.log 文件中除了最后 5 行的内容，可以使用如下命令： head -n -5 shiyanlou.log </p>
<h1 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h1><p>tail 命令主要用于显示指定文件末尾内容。常用查看日志文件。</p>
<h2 id="命令格式：-4"><a href="#命令格式：-4" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>tail [选项] [文件]
</code></pre><h2 id="常用参数：-4"><a href="#常用参数：-4" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td style="text-align:center">循环读取</td>
</tr>
<tr>
<td>-q</td>
<td style="text-align:center">不显示处理信息</td>
</tr>
<tr>
<td>-v</td>
<td style="text-align:center">显示详细的处理信息</td>
</tr>
<tr>
<td>-c&lt;字节&gt;</td>
<td style="text-align:center">显示的字节数</td>
</tr>
<tr>
<td>-n&lt;行数&gt;</td>
<td style="text-align:center">显示行数</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-3"><a href="#常用范例：-3" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：显示 shiyanlou.log 文件中的最后 5 行内容，可以使用如下命令：</p>
<pre><code>tail -n 5 shiyanlou.log
</code></pre><p>例二：显示 shiyanlou.log 文件中的最后 5 行内容，当 shiyanlou.log 文件有新内容增加，自动更新显示。可以使用如下命令：</p>
<pre><code>tail -n 5 -f shiyanlou.log
</code></pre><p>ping www.shiyanlou.com &gt;&gt; shiyanlou.log 这条命令作用是，ping 远程主机，并将信息追加到 shyanlou.log 文件中。&amp; 的作用是将这条命令放在后台执行，这样 shiyanlou.log 文件就会一直有内容增加。说明一下，linux 下执行 ping 命令会一直执行，必须手动停止才行。而 windows 下执行 ping 命令时，发送一定请求后会自动停止。<br><img src="https://dn-anything-about-doc.qbox.me/linux52.png" alt=""><br>使用 tail 命令的-f 选项可以即时输出文件变化后追加的内容，tail -f filename 会把 filename 里最尾部的内容显示在屏幕上，并且不但刷新，使你看到最新的文件内容。 另外顺便说一下怎么查看后台正在运行的任务，及怎么停止任务。 jobs 命令可以查看正在后台运行的任务。kill 命令可以杀死一个任务，但要使用任务的 id。任务的 id 可以通过 ps 命令查看获得。具体操作如下图（不熟悉这些命令没关系，后续都会讲到）<br><img src="https://dn-anything-about-doc.qbox.me/linux52.png" alt=""></p>
<h1 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h1><p>which 命令的作用是，在 PATH 变量指定的路径中搜索可执行文件的所在位置。它一般用来确认系统中是否安装了指定的软件。</p>
<h2 id="命令格式：-5"><a href="#命令格式：-5" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>which 可执行文件名称
</code></pre><h2 id="常用范例：-4"><a href="#常用范例：-4" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：确认是否安装了 gcc，可以使用如下命令：</p>
<pre><code>which gcc
</code></pre><p>例二：查看 cd 命令的位置路径，可以使用如下命令：</p>
<pre><code>which cd
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/linuxcommand/which2.png" alt=""></p>
<p>从上面的显示信息可以看到在实验楼的系统中 cd 是一个 shell 函数。</p>
<p>再来在我本地 linux 系统上执行 which cd 命令，显示的结果如下：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/linuxcommand/which3.png" alt=""></p>
<p>显示在 PATH 变量指定的路径下没有 cd 命令。为什么显示没有呢？这是因为 cd 是 shell 内建命令，而 which 默认是找 PATH 内所指定的目录，内建命令不在其指定的目录中，所以当然一定找不到。</p>
<p>那么就有个问题，为什么实验楼环境中 cd 是一个 shell 函数，而其他 linux 环境中 cd 是内建命令呢？这跟所使用的 bash 有关。<br><img src="https://dn-anything-about-doc.qbox.me/linuxcommand/which4.png" alt=""><br><img src="https://dn-anything-about-doc.qbox.me/linuxcommand/which5.png" alt=""></p>
<p>echo $SHELL 命令查看当前使用的 shell。</p>
<p>补充知识</p>
<p>到底什么是命令？</p>
<p>命令可以是下面四种形式之一：</p>
<p>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。</p>
<p>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，上面我本地环境中的 cd 命令，就是一个 shell 内部命令。</p>
<p>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 比如上面讲到的 cd 命令，在实验楼环境中就是一个 shell 函数。</p>
<p>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</p>
<h1 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h1><p>whereis 命令主要用于定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。</p>
<p>whereis 命令查找速度非常快，这是因为它根本不是在磁盘中漫无目的乱找，而是在一个数据库中（/var/lib/mlocate/）查询。这个数据库是 Linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 updatedb 命令更新一次。也正是因为这个数据库要每天才更新一次，就会使得 whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到。</p>
<h2 id="命令格式：-6"><a href="#命令格式：-6" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>whereis [选项] 文件
</code></pre><h2 id="常用参数：-5"><a href="#常用参数：-5" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>- -b</td>
<td style="text-align:center">定位可执行文件</td>
</tr>
<tr>
<td>- -m</td>
<td style="text-align:center">定位帮助文件</td>
</tr>
<tr>
<td>- -s</td>
<td style="text-align:center">定位源代码文件</td>
</tr>
<tr>
<td>-u</td>
<td style="text-align:center">搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件</td>
</tr>
<tr>
<td>-B</td>
<td style="text-align:center">指定搜索可执行文件的路径</td>
</tr>
<tr>
<td>-M</td>
<td style="text-align:center">指定搜索帮助文件的路径</td>
</tr>
<tr>
<td>-S</td>
<td style="text-align:center">指定搜索源代码文件的路径</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-5"><a href="#常用范例：-5" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：搜索 gcc 可执行文件的路径，可以使用如下命令：</p>
<pre><code>whereis -b gcc
</code></pre><p>例二：搜索 gcc 帮助文件的路径，可以使用如下命令：</p>
<pre><code>whereis -m gcc
</code></pre><p>例三：搜索 gcc 源代码的路径，可以使用如下命令：</p>
<pre><code>whereis -s gcc
</code></pre><h1 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h1><p>locate 命令跟 whereis 命令类似，且它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、联机帮助文件盒源代码文件，如果要获得更全面的搜索结果，可以使用 locate 命令。</p>
<p>locate 命令使用了十分复杂的匹配语法，可以使用特殊字元（如’*’和’?’）来指定需要查找的样本。</p>
<h2 id="命令格式：-7"><a href="#命令格式：-7" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>locate [选项] [搜索字符串]
</code></pre><h2 id="常用参数：-6"><a href="#常用参数：-6" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td style="text-align:center">安静模式，不会显示任何错误讯息</td>
</tr>
<tr>
<td>-n</td>
<td style="text-align:center">至多显示 n 个输出</td>
</tr>
<tr>
<td>-r</td>
<td style="text-align:center">使用正规表达式做寻找的条件</td>
</tr>
<tr>
<td>-V</td>
<td style="text-align:center">显示版本讯息</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-6"><a href="#常用范例：-6" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：搜索 etc 目录下所有以 sh 开头的文件，可以使用如下命令：</p>
<pre><code>locate /etc/sh
</code></pre><p>注意在实验楼环境中一开始执行这个命令会报错：locate 无法执行 stat() ‘/var/lib/mlocate/mlocate.db’：没有那个文件或目录。解决办法是执行sudo updatedb命令。</p>
<p>例二：搜索 etc 目录下文件名包含 lou 的文件，可以使用如下命令：</p>
<pre><code>locate /etc/*lou*
</code></pre><h1 id="find-命令（一）"><a href="#find-命令（一）" class="headerlink" title="find 命令（一）"></a>find 命令（一）</h1><p>find 命令主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。Linux 下 find 命令提供了相当多的查找条件，功能很强大，对应的学习难度也比较大。</p>
<h2 id="命令格式：-8"><a href="#命令格式：-8" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>find [选项] [搜索路径] [表达式]
</code></pre><p>默认路径是当前目录，默认表达式为-print。</p>
<p>表达式可能由下列成份组成：操作符、选项、测试表达式以及动作。</p>
<h2 id="常用参数：-7"><a href="#常用参数：-7" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-print</td>
<td style="text-align:center">find 命令将匹配的文件输出到标准输出</td>
</tr>
<tr>
<td>-exec</td>
<td style="text-align:center">find 命令对匹配的文件执行该参数所给出的 shell 命令</td>
</tr>
<tr>
<td>-name</td>
<td style="text-align:center">按照文件名查找文件</td>
</tr>
<tr>
<td>-type</td>
<td style="text-align:center">查找某一类型的文件</td>
</tr>
<tr>
<td>-prune</td>
<td style="text-align:center">使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同 时使用-depth 选项，那么-prune 将被 find 命令忽略</td>
</tr>
<tr>
<td>-user</td>
<td style="text-align:center">按照文件属主来查找文件</td>
</tr>
<tr>
<td>-group</td>
<td style="text-align:center">按照文件所属的组来查找文件</td>
</tr>
<tr>
<td>-mtime -n +n</td>
<td style="text-align:center">按照文件的更改时间来查找文件，-n 表示文件更改时间距现在小于 n天，+n 表示文件更改时间距现在大于 n 天，find 命令还有-atime 和 -ctime 选项</td>
</tr>
</tbody>
</table>
<p>其他命令命令选项及表达式可参见下图。<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485012419" alt=""></p>
<h2 id="常用范例：-7"><a href="#常用范例：-7" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：打印当前目录下的文件目录列表 ，可以使用如下命令：</p>
<pre><code>find  .  -print
</code></pre><p>例二：打印当前目录下所有以.txt 结尾的文件名 ，可以使用如下命令（截图只显示部分）：</p>
<pre><code>find  .  -name “*.txt” -print
</code></pre><p>me 选项跟-name 选项作用一样，不同在于-iname 会忽略字母大小写。</p>
<p>例三：打印当前目录下所有以.txt 或.pdf 结尾的文件名 ，可以使用如下命令（截图只显示部分）：</p>
<pre><code>find  .  \(-name “*.pdf” -or -name “*.txt”\)
</code></pre><p>例四：打印当前目录下所有不以.txt 结尾的文件名 ，可以使用如下命令：</p>
<pre><code>find  .  ! -name “*.txt”
</code></pre><h1 id="find-命令（二）"><a href="#find-命令（二）" class="headerlink" title="find 命令（二）"></a>find 命令（二）</h1><p>下面将介绍如何根据文件类型、权限、所有者及操作符来查找匹配文件。</p>
<p>根据文件类型来查找文件，使用-type 选项，常见 find 文件类型见下表。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485465186" alt=""></p>
<p>根据文件权限查找文件，使用-perm 选项。所有者使用-user 选项。</p>
<p>另外，find 命令可以通过逻辑操作符来创建更复杂的逻辑关系，例如 find 命令（一）中的例三就使用了操作符-or。find 命令的逻辑操作符见下表。<br><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485513603" alt=""></p>
<h2 id="常用范例：-8"><a href="#常用范例：-8" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：打印当前目录下所有以.txt 结尾的符号链接 ，可以使用如下命令：</p>
<pre><code>find  .  -type l -name “*.txt” -print
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485577965" alt=""></p>
<p>例二：打印当前目录下所有权限为 777 的 php 文件（web 服务器上的 php 文件一般需要执行权限），可以使用如下命令：</p>
<pre><code>find  .  -type f -name “*.php” -perm 777
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485634144" alt=""></p>
<p>例三：打印当前目录下 root 用户拥有的所有文件，可以使用如下命令：</p>
<pre><code>find  .  -type f -user root
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485682625" alt=""><br>例四：打印当前目录下权限不是 777 和 664 的所有文件，可以使用如下命令：</p>
<pre><code>find  .  -type f  \( ! -perm 777  -and  ! -perm 644 \)
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485725524" alt=""></p>
<h1 id="find-命令（三）"><a href="#find-命令（三）" class="headerlink" title="find 命令（三）"></a>find 命令（三）</h1><p>下面将介绍如何使用 find 命令的-exec 选项来实现对查找到的文件执行指定的动作命令。</p>
<h2 id="常用范例：-9"><a href="#常用范例：-9" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：找到当前目录下所有 php 文件，并显示其详细信息，可以使用如下命令：</p>
<pre><code>find . -name “*.php” -exec ls -l {} \;
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485834752" alt=""><br>-exec 是 find 命令对找到的文件执行的动作，这个动作就是对找到的文件执行命令，上面的命令就是 ls -l {}。在这里说明一下{}和\;，{}其实它就是一个占位符，在 find 命令的执行过程中会不断地替换成当前找到的文件，相当于”ls -l 找到的文件”。而\;是-exec 的命令结束标记，因为规定-exec 后面的命令必须以;结束，但;在 shell 中有特殊含义，必须要转义，所以写成\;。</p>
<p>例二：在实验楼环境中有很多自己编写的 c 语言代码文件，现在想要把所有 c 语言代码文件下载下来，如果一个一个的下载很麻烦，我们可以先查找到所有的 c 语言代码文件，然后将这些文件内容写入到一个文件中，下载该文件，可以使用如下命令：</p>
<pre><code>find . -name “*.c” -exec cat {} \; &gt; all.c
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419485908149" alt=""><br>例三：默认下，-exec 后面只能使用单个命令，如果想要多个命令，可以将多个命令写入脚本文件中，然后在-exec 中使用这个脚本，可以使用如下命令：</p>
<pre><code>find . -name “*.c” -exec ./command.sh {} \;
</code></pre><p>脚本内容：</p>
<pre><code>#！ /bin/bash
ls -l $1       # $1 表示第一个参数
cat $1
img
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419486194690" alt=""></p>
<h1 id="xargs-命令"><a href="#xargs-命令" class="headerlink" title="xargs 命令"></a>xargs 命令</h1><p>我们可以用管道将一个命令的 stdout（标准输出）重定向到另一个命令的 stdin（标准输入）。但有些命令只能以命令行参数的形式接收数据，而无法通过 stdin 接收数据流。在这种情况下，无法通过管道将数据重定向给这些命令。</p>
<p>这时 xargs 就可以发挥它的作用了，xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。</p>
<h2 id="命令格式：-9"><a href="#命令格式：-9" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>command | xargs [选项] [command]
</code></pre><p>xargs 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。</p>
<h2 id="常用参数：-8"><a href="#常用参数：-8" class="headerlink" title="常用参数："></a>常用参数：</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td style="text-align:center">指定每行最大的参数数量</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:center">指定分隔符</td>
</tr>
</tbody>
</table>
<h2 id="常用范例：-10"><a href="#常用范例：-10" class="headerlink" title="常用范例："></a>常用范例：</h2><p>例一：将多行输入转换为单行输出，可以使用如下命令：</p>
<pre><code>cat a.txt | xargs
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419486436814" alt=""></p>
<p>例二：将单行输入转换为多行输出，可以使用如下命令：</p>
<pre><code>echo “1 2 3 4 5 6 7” | xargs -n 3
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419486477811" alt=""></p>
<p>例三：将单行输入转换为多行输出，指定分隔符为 i，可以使用如下命令：</p>
<pre><code>cat b.txt | xargs -d i -n 3
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419486635856" alt=""></p>
<p>例四：查找当前目录下所有 c 代码文件，统计总行数，可以使用如下命令：</p>
<pre><code>find . -type f -name “*.c” | xargs wc -l
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid3372labid348time1419486674638" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-7-hdu1698]]></title>
      <url>http://blog.acbingo.cn/2015/08/18/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-hdu1698/</url>
      <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个数N，有一个长度为n的区间，初始时区间元素全部为1，然后x,y,z 代表 从区间x到y间元素变为z<br>求所有操作后1~N区间和</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>线段树区间更新基础题<br>在单点更新的基础上增加一个mark域<br>每次update区间的时候，搜到的区间是要更新区间的子区间，tree[now].val等于当前的区间长度(nowend-nowstart-1)*z<br>但是为了节省时间不再更新到叶子节点，采用延迟标记将更新信息记录在两个儿子节点上，注意这里是把更新信息覆盖记录在儿子上，而不是累加记录<br>之后在访问到儿子节点的时候再把更新信息记录的儿子的两个儿子节点上。。这样就保证在每个节点上只会更新一次(不确定)，节省了很多时间</p>
<p>难点在如何理解延迟标记<br>这里的延迟标记值为更新后的值z，向pushdown函数传递一个参数m，m的值为当前结点所表示的区间长度值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-08-18 16:43</div><div class="line"> * File Name: hdu1698.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define LL long long</div><div class="line">#define ULL unsigned long long</div><div class="line">const int MAXN = 100000;</div><div class="line">struct node &#123;</div><div class="line">    int val;</div><div class="line">    int addMark;</div><div class="line">&#125;tree[4*MAXN];</div><div class="line">void build(int root,int m,int istart,int iend)&#123;</div><div class="line">    tree[root].addMark=0;</div><div class="line">    if (istart==iend)</div><div class="line">    &#123;tree[root].val=m;&#125;</div><div class="line">    else &#123;</div><div class="line">        int mid=(istart+iend)/2;</div><div class="line">        build(root*2+1,m,istart,mid);</div><div class="line">        build(root*2+2,m,mid+1,iend);</div><div class="line">        tree[root].val=tree[root*2+1].val+tree[root*2+2].val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void pushDown(int root,int m)&#123;</div><div class="line">    if (tree[root].addMark!=0)&#123;</div><div class="line">        tree[root*2+1].addMark = tree[root].addMark;</div><div class="line">        tree[root*2+2].addMark = tree[root].addMark;</div><div class="line"></div><div class="line">        tree[root*2+1].val = (m-(m&gt;&gt;1))*tree[root].addMark;</div><div class="line">        tree[root*2+2].val = (m&gt;&gt;1)*tree[root].addMark;</div><div class="line">        tree[root].addMark = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void update(int root, int nstart, int nend, int ustart, int uend, int addVal)</div><div class="line">&#123;</div><div class="line">    //更新区间和当前节点区间没有交集</div><div class="line">    if(ustart &gt; nend || uend &lt; nstart)</div><div class="line">        return ;</div><div class="line">    //当前节点区间包含在更新区间内</div><div class="line">    if(ustart &lt;= nstart &amp;&amp; uend &gt;= nend)</div><div class="line">    &#123;</div><div class="line">        tree[root].addMark = addVal;</div><div class="line">        tree[root].val =  addVal*(nend-nstart+1);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    pushDown(root,nend-nstart+1); //延迟标记向下传递</div><div class="line">    //更新左右孩子节点</div><div class="line">    //cout&lt;&lt;&quot;&amp;&quot;&lt;&lt;tree[0].val&lt;&lt;endl;</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    update(root*2+1, nstart, mid, ustart, uend, addVal);</div><div class="line">    update(root*2+2, mid+1, nend, ustart, uend, addVal);</div><div class="line">    //根据左右子树的值回溯更新当前节点的值</div><div class="line">    tree[root].val = tree[root*2+1].val+tree[root*2+2].val;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int T;</div><div class="line">    int test=0;</div><div class="line">    cin&gt;&gt;T;</div><div class="line">    while (T--)&#123;</div><div class="line">        int n;</div><div class="line">        cin&gt;&gt;n;</div><div class="line">        build(0,1,1,n);</div><div class="line">        //cout&lt;&lt;query(0,1,n,1,n)&lt;&lt;endl;</div><div class="line">        int m;</div><div class="line">        cin&gt;&gt;m;</div><div class="line">        for (int i=0;i&lt;m;i++)&#123;</div><div class="line">            int x,y,z;</div><div class="line">            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</div><div class="line">            update(0,1,n,x,y,z);</div><div class="line">            //cout&lt;&lt;tree[0].val&lt;&lt;endl;</div><div class="line">            //cout&lt;&lt;&quot;%&quot;&lt;&lt;query(0,1,n,1,n)&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,++test,tree[0].val);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><p>另一位<a href="http://blog.csdn.net/metalseed/article/details/8039326" target="_blank" rel="external">大大</a>的代码，有模板价值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdio&gt;  </div><div class="line">#include &lt;algorithm&gt;  </div><div class="line">using namespace std;  </div><div class="line">   </div><div class="line">#define lson l , m , rt &lt;&lt; 1  </div><div class="line">#define rson m + 1 , r , rt &lt;&lt; 1 | 1  </div><div class="line">const int maxn = 111111;  </div><div class="line">int h , w , n;  </div><div class="line">int col[maxn&lt;&lt;2];  </div><div class="line">int sum[maxn&lt;&lt;2];  </div><div class="line">void PushUp(int rt) &#123;  </div><div class="line">    sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];  </div><div class="line">&#125;  </div><div class="line">void PushDown(int rt,int m) &#123;  </div><div class="line">    if (col[rt]) &#123;  </div><div class="line">        col[rt&lt;&lt;1] = col[rt&lt;&lt;1|1] = col[rt];  </div><div class="line">        sum[rt&lt;&lt;1] = (m - (m &gt;&gt; 1)) * col[rt];  </div><div class="line">        sum[rt&lt;&lt;1|1] = (m &gt;&gt; 1) * col[rt];  </div><div class="line">        col[rt] = 0;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">void build(int l,int r,int rt) &#123;  </div><div class="line">    col[rt] = 0;  </div><div class="line">    sum[rt] = 1;  </div><div class="line">    if (l == r) return ;  </div><div class="line">    int m = (l + r) &gt;&gt; 1;  </div><div class="line">    build(lson);  </div><div class="line">    build(rson);  </div><div class="line">    PushUp(rt);  </div><div class="line">&#125;  </div><div class="line">void update(int L,int R,int c,int l,int r,int rt) &#123;  </div><div class="line">    if (L &lt;= l &amp;&amp; r &lt;= R) &#123;  </div><div class="line">        col[rt] = c;  </div><div class="line">        sum[rt] = c * (r - l + 1);  </div><div class="line">        return ;  </div><div class="line">    &#125;  </div><div class="line">    PushDown(rt , r - l + 1);  </div><div class="line">    int m = (l + r) &gt;&gt; 1;  </div><div class="line">    if (L &lt;= m) update(L , R , c , lson);  </div><div class="line">    if (R &gt; m) update(L , R , c , rson);  </div><div class="line">    PushUp(rt);  </div><div class="line">&#125;  </div><div class="line">int main() &#123;  </div><div class="line">    int T , n , m;  </div><div class="line">    scanf(&quot;%d&quot;,&amp;T);  </div><div class="line">    for (int cas = 1 ; cas &lt;= T ; cas ++) &#123;  </div><div class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  </div><div class="line">        build(1 , n , 1);  </div><div class="line">        while (m --) &#123;  </div><div class="line">            int a , b , c;  </div><div class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);  </div><div class="line">            update(a , b , c , 1 , n , 1);  </div><div class="line">        &#125;  </div><div class="line">        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cas , sum[1]);  </div><div class="line">    &#125;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-6-区间更新]]></title>
      <url>http://blog.acbingo.cn/2015/08/18/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>本文参考自<a href="http://dongxicheng.org/structure/segment-tree/" target="_blank" rel="external">董的博客</a>,讲的很清楚啊，可见作者思路很清晰，膜拜Orz</p>
<h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><p>区间查询指用户输入一个区间，获取该区间的有关信息，如区间中最大值，最小值，第N大的值等。<br>比如前面一个图中所示的树，如果询问区间是[0,2]，或者询问的区间是[3,3]，不难直接找到对应的节点回答这一问题。但并不是所有的提问都这么容易回答，比如[0,3]，就没有哪一个节点记录了这个区间的最小值。当然，解决方法也不难找到：把[0,2]和[3,3]两个区间（它们在整数意义上是相连的两个区间）的最小值“合并”起来，也就是求这两个最小值的最小值，就能求出[0,3]范围的最小值。同理，对于其他询问的区间，也都可以找到若干个相连的区间，合并后可以得到询问的区间。<br>区间查询的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// node 为线段树的结点类型，其中Left 和Right 分别表示区间左右端点</div><div class="line"> </div><div class="line">// Lch 和Rch 分别表示指向左右孩子的指针</div><div class="line"> </div><div class="line">void Query(node *p, int a, int b) // 当前考察结点为p，查询区间为(a,b]</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">  if (a &lt;= p-&gt;Left &amp;&amp; p-&gt;Right &lt;= b)</div><div class="line"> </div><div class="line">  // 如果当前结点的区间包含在查询区间内</div><div class="line"> </div><div class="line">  &#123;</div><div class="line"> </div><div class="line">     ...... // 更新结果</div><div class="line"> </div><div class="line">     return;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Push_Down(p); // 等到下面的修改操作再解释这句</div><div class="line"> </div><div class="line">  int mid = (p-&gt;Left + p-&gt;Right) / 2; // 计算左右子结点的分隔点</div><div class="line"> </div><div class="line">  if (a &lt; mid) Query(p-&gt;Lch, a, b); // 和左孩子有交集，考察左子结点</div><div class="line"> </div><div class="line">  if (b &gt; mid) Query(p-&gt;Rch, a, b); // 和右孩子有交集，考察右子结点</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，这样的过程一定选出了尽量少的区间，它们相连后正好涵盖了整个[l,r]，没有重复也没有遗漏。同时，考虑到线段树上每层的节点最多会被选取2个，一共选取的节点数也是O(log n)的，因此查询的时间复杂度也是O(log n)。<br>线段树并不适合所有区间查询情况，它的使用条件是“相邻的区间的信息可以被合并成两个区间的并区间的信息”。即问题是可以被分解解决的。</p>
<h1 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h1><p>当用户修改一个区间的值时，如果连同其子孙全部修改，则改动的节点数必定会远远超过O(log n)个。因而，如果要想把区间修改操作也控制在O(log n)的时间内，只修改O(log n)个节点的信息就成为必要。<br>借鉴前一节区间查询用到的思路：区间修改时如果修改了一个节点所表示的区间，也不用去修改它的儿子节点。然而，对于被修改节点的祖先节点，也必须更新它所记录的值，否则查询操作就肯定会出问题（正如修改单个节点的情况一样）。<br>这些选出的节点的祖先节点直接更新值即可，而选出的节点的子孙却显然不能这么简单地处理：每个节点的值必须能由两个儿子节点的值得到，如这幅图中的例子：<br><img src="http://dongxicheng.org/wp-content/uploads/2011/04/update.jpg" alt=""><br>这里，节点[0,1]的值应该是4，但是两个儿子的值又分别是3和5。如果查询[0,0]区间的RMQ，算出来的结果会是3，而正确答案显然是4。<br>问题显然在于，尽管修改了一个节点以后，不用修改它的儿子节点，但是它的儿子节点的信息事实上已经被改变了。这就需要我们在节点里增设一个域：标记。把对节点的修改情况储存在标记里面，这样，当我们自上而下地访问某节点时，就能把一路上所遇到的所有标记都考虑进去。<br>但是，在一个节点带上标记时，会给更新这个节点的值带来一些麻烦。继续上面的例子，如果我把位置0的数字从4改成了3，区间[0,0]的值应该变回3，但实际上，由于区间[0,1]有一个“添加了1”的标记，如果直接把值修改为3，则查询区间[0,0]的时候我们会得到3+1=4这个错误结果。但是，把这个3改成2，虽然正确，却并不直观，更不利于推广（参见下面的一个例子）。<br>为此我们引入延迟标记的一些概念。每个结点新增加一个标记，记录这个结点是否被进行了某种修改操作(这种修改操作会影响其子结点)。还是像上面的一样，对于任意区间的修改，我们先按照查询的方式将其划分成线段树中的结点，然后修改这些结点的信息，并给这些结点标上代表这种修改操作的标记。在修改和查询的时候，如果我们到了一个结点p ，并且决定考虑其子结点，那么我们就要看看结点p 有没有标记，如果有，就要按照标记修改其子结点的信息，并且给子结点都标上相同的标记，同时消掉p 的标记。代码框架为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// node 为线段树的结点类型，其中Left 和Right 分别表示区间左右端点</div><div class="line"> </div><div class="line">// Lch 和Rch 分别表示指向左右孩子的指针</div><div class="line"> </div><div class="line">void Change(node *p, int a, int b) // 当前考察结点为p，修改区间为(a,b]</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">  if (a &lt;= p-&gt;Left &amp;&amp; p-&gt;Right &lt;= b)</div><div class="line"> </div><div class="line">  // 如果当前结点的区间包含在修改区间内</div><div class="line"> </div><div class="line">  &#123;</div><div class="line"> </div><div class="line">     ...... // 修改当前结点的信息，并标上标记</div><div class="line"> </div><div class="line">     return;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Push_Down(p); // 把当前结点的标记向下传递</div><div class="line"> </div><div class="line">  int mid = (p-&gt;Left + p-&gt;Right) / 2; // 计算左右子结点的分隔点</div><div class="line"> </div><div class="line">  if (a &lt; mid) Change(p-&gt;Lch, a, b); // 和左孩子有交集，考察左子结点</div><div class="line"> </div><div class="line">  if (b &gt; mid) Change(p-&gt;Rch, a, b); // 和右孩子有交集，考察右子结点</div><div class="line"> </div><div class="line">  Update(p); // 维护当前结点的信息（因为其子结点的信息可能有更改）</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>本模板搬自<a href="http://blog.csdn.net/metalseed/article/details/8039326" target="_blank" rel="external">这里</a></p>
<h2 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h2><p>RMQ，查询区间最值下标—min<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;    </div><div class="line">  </div><div class="line">using namespace std;    </div><div class="line">    </div><div class="line">#define MAXN 100    </div><div class="line">#define MAXIND 256 //线段树节点个数    </div><div class="line">    </div><div class="line">//构建线段树,目的:得到M数组.    </div><div class="line">void build(int node, int b, int e, int M[], int A[])    </div><div class="line">&#123;    </div><div class="line">    if (b == e)    </div><div class="line">        M[node] = b; //只有一个元素,只有一个下标    </div><div class="line">    else    </div><div class="line">    &#123;     </div><div class="line">        build(2 * node, b, (b + e) / 2, M, A);    </div><div class="line">        build(2 * node + 1, (b + e) / 2 + 1, e, M, A);    </div><div class="line">  </div><div class="line">        if (A[M[2 * node]] &lt;= A[M[2 * node + 1]])    </div><div class="line">            M[node] = M[2 * node];    </div><div class="line">        else    </div><div class="line">            M[node] = M[2 * node + 1];    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line">//找出区间 [i, j] 上的最小值的索引    </div><div class="line">int query(int node, int b, int e, int M[], int A[], int i, int j)    </div><div class="line">&#123;    </div><div class="line">    int p1, p2;    </div><div class="line">    </div><div class="line">    //查询区间和要求的区间没有交集    </div><div class="line">    if (i &gt; e || j &lt; b)    </div><div class="line">        return -1;    </div><div class="line">  </div><div class="line">    if (b &gt;= i &amp;&amp; e &lt;= j)    </div><div class="line">        return M[node];    </div><div class="line">   </div><div class="line">    p1 = query(2 * node, b, (b + e) / 2, M, A, i, j);    </div><div class="line">    p2 = query(2 * node + 1, (b + e) / 2 + 1, e, M, A, i, j);    </div><div class="line">    </div><div class="line">    //return the position where the overall    </div><div class="line">    //minimum is    </div><div class="line">    if (p1 == -1)    </div><div class="line">        return M[node] = p2;    </div><div class="line">    if (p2 == -1)    </div><div class="line">        return M[node] = p1;    </div><div class="line">    if (A[p1] &lt;= A[p2])    </div><div class="line">        return M[node] = p1;    </div><div class="line">    return M[node] = p2;    </div><div class="line">    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line">    </div><div class="line">int main()    </div><div class="line">&#123;    </div><div class="line">    int M[MAXIND]; //下标1起才有意义,否则不是二叉树,保存下标编号节点对应区间最小值的下标.    </div><div class="line">    memset(M,-1,sizeof(M));    </div><div class="line">    int a[]=&#123;3,4,5,7,2,1,0,3,4,5&#125;;    </div><div class="line">    build(1, 0, sizeof(a)/sizeof(a[0])-1, M, a);    </div><div class="line">    cout&lt;&lt;query(1, 0, sizeof(a)/sizeof(a[0])-1, M, a, 0, 5)&lt;&lt;endl;    </div><div class="line">    return 0;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="模板2"><a href="#模板2" class="headerlink" title="模板2"></a>模板2</h2><p>连续区间修改或者单节点更新的动态查询问题 （此模板查询区间和）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdio&gt;    </div><div class="line">#include &lt;algorithm&gt;    </div><div class="line">using namespace std;    </div><div class="line">     </div><div class="line">#define lson l , m , rt &lt;&lt; 1    </div><div class="line">#define rson m + 1 , r , rt &lt;&lt; 1 | 1   </div><div class="line">#define root 1 , N , 1   </div><div class="line">#define LL long long    </div><div class="line">const int maxn = 111111;    </div><div class="line">LL add[maxn&lt;&lt;2];    </div><div class="line">LL sum[maxn&lt;&lt;2];    </div><div class="line">void PushUp(int rt) &#123;    </div><div class="line">    sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];    </div><div class="line">&#125;    </div><div class="line">void PushDown(int rt,int m) &#123;    </div><div class="line">    if (add[rt]) &#123;    </div><div class="line">        add[rt&lt;&lt;1] += add[rt];    </div><div class="line">        add[rt&lt;&lt;1|1] += add[rt];    </div><div class="line">        sum[rt&lt;&lt;1] += add[rt] * (m - (m &gt;&gt; 1));    </div><div class="line">        sum[rt&lt;&lt;1|1] += add[rt] * (m &gt;&gt; 1);    </div><div class="line">        add[rt] = 0;    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">void build(int l,int r,int rt) &#123;    </div><div class="line">    add[rt] = 0;    </div><div class="line">    if (l == r) &#123;    </div><div class="line">        scanf(&quot;%lld&quot;,&amp;sum[rt]);    </div><div class="line">        return ;    </div><div class="line">    &#125;    </div><div class="line">    int m = (l + r) &gt;&gt; 1;    </div><div class="line">    build(lson);    </div><div class="line">    build(rson);    </div><div class="line">    PushUp(rt);    </div><div class="line">&#125;    </div><div class="line">void update(int L,int R,int c,int l,int r,int rt) &#123;    </div><div class="line">    if (L &lt;= l &amp;&amp; r &lt;= R) &#123;    </div><div class="line">        add[rt] += c;    </div><div class="line">        sum[rt] += (LL)c * (r - l + 1);    </div><div class="line">        return ;    </div><div class="line">    &#125;    </div><div class="line">    PushDown(rt , r - l + 1);    </div><div class="line">    int m = (l + r) &gt;&gt; 1;    </div><div class="line">    if (L &lt;= m) update(L , R , c , lson);    </div><div class="line">    if (m &lt; R) update(L , R , c , rson);    </div><div class="line">    PushUp(rt);    </div><div class="line">&#125;    </div><div class="line">LL query(int L,int R,int l,int r,int rt) &#123;    </div><div class="line">    if (L &lt;= l &amp;&amp; r &lt;= R) &#123;    </div><div class="line">        return sum[rt];    </div><div class="line">    &#125;    </div><div class="line">    PushDown(rt , r - l + 1);    </div><div class="line">    int m = (l + r) &gt;&gt; 1;    </div><div class="line">    LL ret = 0;    </div><div class="line">    if (L &lt;= m) ret += query(L , R , lson);    </div><div class="line">    if (m &lt; R) ret += query(L , R , rson);    </div><div class="line">    return ret;    </div><div class="line">&#125;    </div><div class="line">int main() &#123;    </div><div class="line">    int N , Q;    </div><div class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;Q);    </div><div class="line">    build(root);    </div><div class="line">    while (Q --) &#123;    </div><div class="line">        char op[2];    </div><div class="line">        int a , b , c;    </div><div class="line">        scanf(&quot;%s&quot;,op);    </div><div class="line">        if (op[0] == &apos;Q&apos;) &#123;    </div><div class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    </div><div class="line">            printf(&quot;%lld\n&quot;,query(a , b ,root));    </div><div class="line">        &#125; else &#123;    </div><div class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);    </div><div class="line">            update(a , b , c , root);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">    return 0;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coursera_程序设计与算法_C程序设计进阶]]></title>
      <url>http://blog.acbingo.cn/2015/08/18/Coursera_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95_C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<h1 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h1><p>在一个字符串中找出元音字母a,e,i,o,u出现的次数。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入一行字符串（字符串中可能有空格，请用gets(s)方法把一行字符串输入到字符数组s中），字符串长度小于80个字符。 </p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一行，依次输出a,e,i,o,u在输入字符串中出现的次数，整数之间用空格分隔。</p>
<p>##样例输入<br>If so, you already have a Google Account. You can sign in on the right.</p>
<p>##样例输出<br>5 4 3 7 3<br><a id="more"></a></p>
<p>##代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    getline(cin,s);</div><div class="line">    int len=s.size();</div><div class="line">    int a=0,b=0,c=0,d=0,e=0;</div><div class="line">    for (int i=0;i&lt;len;i++)&#123;</div><div class="line">        if (s[i]==&apos;a&apos;) a++;</div><div class="line">        if (s[i]==&apos;e&apos;) b++;</div><div class="line">        if (s[i]==&apos;i&apos;) c++;</div><div class="line">        if (s[i]==&apos;o&apos;) d++;</div><div class="line">        if (s[i]==&apos;u&apos;) e++;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：忽略大小写比较字符串大小"><a href="#编程题＃2：忽略大小写比较字符串大小" class="headerlink" title="编程题＃2：忽略大小写比较字符串大小"></a>编程题＃2：忽略大小写比较字符串大小</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到’\0’为止。如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准。但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如”Hello”和”hello”在忽略字母大小写时是相等的。请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入为两行，每行一个字符串，共两个字符串。（请用gets录入每行字符串）（每个字符串长度都小于80）</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>如果第一个字符串比第二个字符串小，输出一个字符”&lt;”</p>
<p>如果第一个字符串比第二个字符串大，输出一个字符”&gt;”</p>
<p>如果两个字符串相等，输出一个字符”=”</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello</div><div class="line">hello</div></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s1,s2;</div><div class="line">    cin&gt;&gt;s1&gt;&gt;s2;</div><div class="line">    for (int i=0;i&lt;s1.size();i++)</div><div class="line">        s1[i]=toupper(s1[i]);</div><div class="line">    for (int i=0;i&lt;s2.size();i++)</div><div class="line">        s2[i]=toupper(s2[i]);</div><div class="line">    if (s1&lt;s2) cout&lt;&lt;&quot;&lt;&quot;;</div><div class="line">    else if (s1&gt;s2) cout&lt;&lt;&quot;&gt;&quot;;</div><div class="line">    else cout&lt;&lt;&quot;=&quot;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃3：最长单词2"><a href="#编程题＃3：最长单词2" class="headerlink" title="编程题＃3：最长单词2"></a>编程题＃3：最长单词2</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>一个以’.’结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一个以’.’结尾的简单英文句子（长度不超过500），单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>该句子中最长的单词。如果多于一个，则输出第一个</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>I am a student of Peking University.</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>University</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    char t[600];</div><div class="line">    gets(t);</div><div class="line">    s=t;</div><div class="line">    s[s.size()-1]=&apos; &apos;;</div><div class="line">    //puts(t);</div><div class="line">    stringstream ss(s);</div><div class="line">    string ans;</div><div class="line">    int len=0;</div><div class="line">    while (ss&gt;&gt;s) if (s.size()&gt;len) &#123;len=s.size();ans=s;&#125;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃4：矩阵交换行"><a href="#编程题＃4：矩阵交换行" class="headerlink" title="编程题＃4：矩阵交换行"></a>编程题＃4：矩阵交换行</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>编写一个函数，输入参数是5*5的二维数组，和n，m两个行下标。功能：判断n，m是否在数组范围内，如果不在，则返回0；如果在范围内，则将n行和m行交换，并返回1。</p>
<p>在main函数中， 生成一个5*5的矩阵，输入矩阵数据，并输入n，m的值。调用前面的函数。如果返回值为0，输出error。如果返回值为1，输出交换n，m后的新矩阵。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>5*5矩阵的数据，以及n和m的值。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>如果不可交换，则输出error；</p>
<p>如果可交换，则输出新矩阵</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 2 1 2</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">3 0 8 2 4</div><div class="line">0 4</div></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">3 0 8 2 4</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">1 2 2 1 2</div></pre></td></tr></table></figure>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/6 19:33:47</div><div class="line"> * File Name: 9-4.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">#include &lt;iomanip&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[5][5];</div><div class="line">    for (int i=0;i&lt;5;i++)</div><div class="line">        for (int j=0;j&lt;5;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    if (n&lt;0||n&gt;4||m&lt;0||m&gt;4) cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</div><div class="line">    else &#123;</div><div class="line">        for (int i=0;i&lt;5;i++)&#123;</div><div class="line">            if (i==n)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[m][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[m][4]&lt;&lt;endl;</div><div class="line">            &#125;else if (i==m)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[n][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[n][4]&lt;&lt;endl;</div><div class="line">            &#125;else &#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[i][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[i][4]&lt;&lt;endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃5：异常细胞检测"><a href="#编程题＃5：异常细胞检测" class="headerlink" title="编程题＃5：异常细胞检测"></a>编程题＃5：异常细胞检测</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>我们拍摄的一张CT照片用一个二维数组来存储，假设数组中的每个点代表一个细胞。每个细胞的颜色用0到255之间（包括0和255）的一个整数表示。我们定义一个细胞是异常细胞，如果这个细胞的颜色值比它上下左右4个细胞的颜色值都小50以上（包括50）。数组边缘上的细胞我们不检测。现在我们的任务是，给定一个存储CT照片的二维数组，写程序统计照片中异常细胞的数目。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数N（100&gt;=N&gt;2）.</p>
<p>下面有 N 行，每行有 N 个0~255之间的整数，整数之间用空格隔开。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出只有一行，包含一个整数，为异常细胞的数目。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">70 70 70 70</div><div class="line">70 10 70 70</div><div class="line">70 70 20 70</div><div class="line">70 70 70 70</div></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    int a[150][150];</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int cnt=0;</div><div class="line">    for (int i=1;i&lt;n-1;i++)</div><div class="line">        for (int j=1;j&lt;n-1;j++)</div><div class="line">            if ((a[i-1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i+1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i][j-1]-a[i][j]&gt;=50)&amp;&amp;(a[i][j+1]-a[i][j]&gt;=50)) &#123;cnt++;&#125;</div><div class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃6：循环移动"><a href="#编程题＃6：循环移动" class="headerlink" title="编程题＃6：循环移动"></a>编程题＃6：循环移动</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>给定一组整数，要求利用数组把这组数保存起来，再利用指针实现对数组中的数循环移动。假定共有n个整数，则要使前面各数顺序向后移m个位置，并使最后m各数变为最前面的m各数。</p>
<p>注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也不要用两个数组的方式实现。</p>
<p>要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">11 4</div><div class="line">15 3 76 67 84 87 13 67 45 34 45</div></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">67 45 34 45 15 3 76 67 84 87 13</div></pre></td></tr></table></figure>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 10:41:45</div><div class="line"> * File Name: 9-6.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    int a[500];</div><div class="line">    for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">    for (int k=0;k&lt;m;k++)&#123;</div><div class="line">        int t=a[n-1];</div><div class="line">        for (int i=n-1;i&gt;0;i--) a[i]=a[i-1];</div><div class="line">        a[0]=t;</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">    cout&lt;&lt;a[n-1]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃7：中位数"><a href="#编程题＃7：中位数" class="headerlink" title="编程题＃7：中位数"></a>编程题＃7：中位数</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数或最中间两个数据的平均值（如果这组数的个数为奇数，则中位数为位于中间位置的那个数；如果这组数的个数为偶数，则中位数是位于中间位置的两个数的平均值）.</p>
<p>给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1 &lt;= N &lt;= 15000.</p>
<p>接着N行为N个数据的输入，N=0时结束输入</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出中位数，每一组测试数据输出一行</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">30</div><div class="line">20</div><div class="line">40</div><div class="line">3</div><div class="line">40</div><div class="line">30</div><div class="line">50</div><div class="line">4</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">0</div></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">25</div><div class="line">40</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:16:29</div><div class="line"> * File Name: 9-7.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while(cin&gt;&gt;n&amp;&amp;n)&#123;</div><div class="line">        int a[n];</div><div class="line">        for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">        sort(a,a+n);</div><div class="line">        if (n%2) cout&lt;&lt;a[n/2]&lt;&lt;endl;</div><div class="line">        else cout&lt;&lt;(a[n/2-1]+a[n/2])/2&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃8：校门外的树"><a href="#编程题＃8：校门外的树" class="headerlink" title="编程题＃8：校门外的树"></a>编程题＃8：校门外的树</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。</p>
<p>马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">500 3</div><div class="line">150 300</div><div class="line">100 200</div><div class="line">470 471</div></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">298</div></pre></td></tr></table></figure>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:25:51</div><div class="line"> * File Name: 9-8.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[10002];</div><div class="line">    int n,m,l;</div><div class="line">    int x,y;</div><div class="line">    memset(a,0,sizeof(a));</div><div class="line">    cin&gt;&gt;l&gt;&gt;m;</div><div class="line">    for (int i=0;i&lt;m;i++)&#123;</div><div class="line">        cin&gt;&gt;x&gt;&gt;y;</div><div class="line">        for(int j=x;j&lt;=y;j++)</div><div class="line">            a[j]=1;</div><div class="line">    &#125;</div><div class="line">    int ans=0;</div><div class="line">    for (int i=0;i&lt;=l;i++)</div><div class="line">        if (a[i]==0) ans++;</div><div class="line">    //if (ans) ans+=1;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-5-hdu2795]]></title>
      <url>http://blog.acbingo.cn/2015/08/18/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-hdu2795/</url>
      <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个 h <em> w 的矩形广告板，现在要在上面贴海报;<br>有n个海报，每个海报的大小规格是 1 </em> x ， 要求每个海报要尽量往上并且尽量靠左贴；<br>求第 i 个海报的所在的位置；<br>如果不能再贴海报则输出 -1；</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>运用线段树来求区间的最大值<br>将位置也就是h来建树，节点存当前区间下还拥有的最大区间</p>
<p>不过一开始也是半天没反应过来，h到了10的9次方，这么大怎么建树呢。。没忍住去看人家，这才恍然大悟，当h&gt;n的时候，最多也就能贴到n层，此时只需把规模开到n即可<br>后来想想若是这题在赛场上做，在没想到这一点的情况下，有可能因为时间复杂度和空间复杂度太大而把线段树的思路毙掉了= =</p>
<p>如果左子树的最大值&gt;=x，就查询左子树，否则如果右子树的最大值&gt;=x,就查询右子树<br>若是左右子树都不满足，说明此时无法张贴，就返回-1(其实若不满足的话，无需进入递归就返回-1了，也就是说，只查询根节点的左右子树是否满足条件即可)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>还是那块模板<br>不过吧updateOne和query写到一块了，因为当你query叶子节点的时候，就已经需要更新了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-08-18 09:13</div><div class="line"> * File Name: hdu2795.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define LL long long</div><div class="line">#define ULL unsigned long long</div><div class="line">const int MAXN = 1000000;</div><div class="line">struct node &#123;</div><div class="line">    int val;</div><div class="line">&#125;tree[4*MAXN];</div><div class="line">int h,w;</div><div class="line">void build(int root,int istart,int iend)&#123;</div><div class="line">    if (istart==iend)&#123;</div><div class="line">        tree[root].val=w;</div><div class="line">    &#125;else &#123;</div><div class="line">        int mid=(istart+iend)/2;</div><div class="line">        build(root*2+1,istart,mid);</div><div class="line">        build(root*2+2,mid+1,iend);</div><div class="line">        tree[root].val=max(tree[root*2+1].val,tree[root*2+2].val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int query(int root,int nstart,int nend,int x)&#123;</div><div class="line">    if (nstart==nend)&#123;</div><div class="line">        if (tree[root].val&gt;=x) &#123;</div><div class="line">            tree[root].val-=x;</div><div class="line">            return nstart;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    int tmp;</div><div class="line">    if (tree[root*2+1].val&gt;=x)  tmp=query(root*2+1,nstart,mid,x);</div><div class="line">    else  if (tree[root*2+2].val&gt;=x)  tmp=query(root*2+2,mid+1,nend,x);</div><div class="line">    else tmp=-1;</div><div class="line">    tree[root].val=max(tree[root*2+1].val,tree[root*2+2].val);</div><div class="line">    return tmp;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while(cin&gt;&gt;h&gt;&gt;w&gt;&gt;n)&#123;</div><div class="line">        h=min(h,n);</div><div class="line">        build(0,1,h);</div><div class="line">        for (int i=0;i&lt;n;i++)&#123;</div><div class="line">            int x;</div><div class="line">            scanf(&quot;%d&quot;,&amp;x );</div><div class="line">            printf(&quot;%d\n&quot;,query(0,1,h,x));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-4-hdu1394]]></title>
      <url>http://blog.acbingo.cn/2015/08/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-hdu1394/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>之前没做过求逆序对数目的题，觉得一个逆序对朴素来就行了，然后看完这个题后主要在想后半部分<br>其实这题就是找规律啊。。。我是没找到，去网上看题解<br>仔细观察可以发现<br>当把a[0]移走，逆序对减少a[0]对，放到最后增加n-1-a[0]个<br>那么，对于一般的<br>当前数列为Si时，数列头部为a[i]，那么ans[i]就可以由ans[i-1]得出递推公式<br>ans[i]=ans[i-1]+(n-1-a[i]-a[i])<br>那么我们只需求初始数列的逆序队数即可<br>观察n规模为5000，暴力及有可能会挂掉，所以需要用nlogn的算法<br>所以考虑到线段树解决</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>时间关系，详情见代码吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-08-14 21:03</div><div class="line"> * File Name: hdu1394.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define LL long long</div><div class="line">#define ULL unsigned long long</div><div class="line">const int MAXN = 5000+5;</div><div class="line">int arr[MAXN];</div><div class="line">struct Node         // 线段树</div><div class="line">&#123;</div><div class="line">    int left;</div><div class="line">    int right;</div><div class="line">    int counter;</div><div class="line">&#125;segTree[4*MAXN];</div><div class="line">/* 构建线段树 根节点开始构建区间[lef,rig]的线段树*/</div><div class="line">void construct(int index, int lef, int rig)</div><div class="line">&#123;</div><div class="line">    segTree[index].left = lef;</div><div class="line">    segTree[index].right = rig;</div><div class="line">    if(lef == rig)   // 叶节点</div><div class="line">    &#123;</div><div class="line">        segTree[index].counter = 0;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid = (lef+rig) &gt;&gt; 1;</div><div class="line">    construct((index&lt;&lt;1)+1, lef, mid);</div><div class="line">    construct((index&lt;&lt;1)+2, mid+1, rig);</div><div class="line">    segTree[index].counter = 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 包含x的区间的值都+1 即对包含x的logn个节点的路径进行更新*/</div><div class="line">void insert(int index, int x)</div><div class="line">&#123;</div><div class="line">    ++segTree[index].counter;</div><div class="line">    if(segTree[index].left == segTree[index].right)</div><div class="line">    &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid = (segTree[index].left + segTree[index].right) &gt;&gt; 1;</div><div class="line">    if(x &lt;= mid)</div><div class="line">    &#123;</div><div class="line">        insert((index&lt;&lt;1)+1, x);</div><div class="line">    &#125;else</div><div class="line">    &#123;</div><div class="line">        insert((index&lt;&lt;1)+2, x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 查询点x的逆序数，即查询[x,BORDER]的区间和 */</div><div class="line">int query(int index, int left, int right)</div><div class="line">&#123;</div><div class="line">    if(segTree[index].left == left &amp;&amp; segTree[index].right == right)</div><div class="line">    &#123;</div><div class="line">        return segTree[index].counter;</div><div class="line">    &#125;</div><div class="line">    int mid = (segTree[index].left+segTree[index].right) &gt;&gt; 1;</div><div class="line">    if(right &lt;= mid)</div><div class="line">    &#123;</div><div class="line">        return query((index&lt;&lt;1)+1,left,right);</div><div class="line">    &#125;else if(left &gt; mid)</div><div class="line">    &#123;</div><div class="line">        return query((index&lt;&lt;1)+2,left,right);</div><div class="line">    &#125;</div><div class="line">    return query((index&lt;&lt;1)+1,left,mid) + query((index&lt;&lt;1)+2,mid+1,right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n))&#123;</div><div class="line">        construct(0,0,n);</div><div class="line">        int ans=0;</div><div class="line">        for (int i=0;i&lt;n;i++)&#123;</div><div class="line">            scanf(&quot;%d&quot;,&amp;arr[i]);</div><div class="line">            ans+=query(0,arr[i],n-1);</div><div class="line">            </div><div class="line">            insert(0,arr[i]);</div><div class="line">        &#125;</div><div class="line">        //cout&lt;&lt;1;</div><div class="line">        int tmp=0;</div><div class="line">        tmp=ans;</div><div class="line">        for (int i=0;i&lt;n;i++)&#123;</div><div class="line">            tmp+=n-arr[i]-1-arr[i];</div><div class="line">            ans=min(ans,tmp);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%d\n&quot;,ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="线段树2"><a href="#线段树2" class="headerlink" title="线段树2"></a>线段树2</h1><p>明天给出另一种结构的代码，就当是巩固线段树知识了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">/*78ms,320KB*/</div><div class="line"></div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">#define lson l, m, rt &lt;&lt; 1</div><div class="line">#define rson m + 1, r, rt &lt;&lt; 1 | 1</div><div class="line">#define root 0, n, 1</div><div class="line">const int mx = 5000;</div><div class="line"></div><div class="line">int sum[mx &lt;&lt; 2], x[mx];</div><div class="line"></div><div class="line">inline void pushup(int rt)</div><div class="line">&#123;</div><div class="line">	sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int p, int addval, int l, int r, int rt)</div><div class="line">&#123;</div><div class="line">	if (l == r)</div><div class="line">	&#123;</div><div class="line">		sum[rt] += addval;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int m = (l + r) &gt;&gt; 1;</div><div class="line">	if (p &lt;= m) update(p, addval, lson);</div><div class="line">	else update(p, addval, rson);</div><div class="line">	pushup(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int query(int ql, int qr, int l, int r, int rt)</div><div class="line">&#123;</div><div class="line">	if (ql &lt;= l &amp;&amp; r &lt;= qr)</div><div class="line">	&#123;</div><div class="line">		return sum[rt];</div><div class="line">	&#125;</div><div class="line">	int sum = 0, m = (l + r) &gt;&gt; 1;</div><div class="line">	if (ql &lt;= m) sum += query(ql, qr, lson);</div><div class="line">	if (m &lt; qr) sum += query(ql, qr, rson);</div><div class="line">	return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int n, i, inver, minans;</div><div class="line">	while (~scanf(&quot;%d&quot;, &amp;n))</div><div class="line">	&#123;</div><div class="line">		memset(sum, 0, sizeof(sum));</div><div class="line">		--n;</div><div class="line">		inver = 0;</div><div class="line">		for (i = 0; i &lt;= n; ++i)</div><div class="line">		&#123;</div><div class="line">			scanf(&quot;%d&quot;, &amp;x[i]);</div><div class="line">			inver += query(x[i], n, root);</div><div class="line">			update(x[i], 1, root);</div><div class="line">			x[i] &lt;&lt;= 1;</div><div class="line">		&#125;</div><div class="line">		minans = inver;</div><div class="line">		for (i = 0; i &lt;= n; ++i)</div><div class="line">		&#123;</div><div class="line">			inver += n - x[i];</div><div class="line">			minans = min(minans, inver);</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, minans);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[求逆序对的个数]]></title>
      <url>http://blog.acbingo.cn/2015/08/14/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>本文部分内容参考自<a href="http://www.ahathinking.com" target="_blank" rel="external">勇幸|Thinking</a>,感谢原作者</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><a href="http://baike.baidu.com/view/184395.htm" target="_blank" rel="external">逆序对</a><br>设A[1…n]是一个包含n个不同数的数组。如果在i<j的情况下，有a[i]>A[j]，则（i，j）就称为A中的一个逆序对（inversion）【《算法导论》2-4】</j的情况下，有a[i]></p>
<h1 id="解法一，暴力"><a href="#解法一，暴力" class="headerlink" title="解法一，暴力"></a>解法一，暴力</h1><p>暴力方法最直接，也最容易想到，两层for循环就可以算出来逆序数：每遇到一个元素回头遍历寻找比其大的元素个数即可，当然向后寻找比其小的元素个数也可以，复杂度为O(n^2)，代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int sum = 0;</div><div class="line">for(int i = 0; i &lt; size; ++i)</div><div class="line">&#123;</div><div class="line">    for(int j = i+1; j &lt; size; ++j)</div><div class="line">    &#123;</div><div class="line">        if(arr[i] &gt; arr[j])</div><div class="line">        &#123;</div><div class="line">            ++sum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">return sum;</div></pre></td></tr></table></figure></p>
<h1 id="解法二，归并排序"><a href="#解法二，归并排序" class="headerlink" title="解法二，归并排序"></a>解法二，归并排序</h1><blockquote>
<p>《算法导论》2-4关于逆序对的几点讨论：<br>1) 如果数组的元素取自集合[1,2,…,n]，那么，怎样的数组含有最多的逆序对？它包含多少个逆序对？<br>很容易想到，当一个数列为逆序时，即[n,n-1,n-2,…,1]，逆序数是最多的，是多少？当n=1，inversion=0；n=2，inversion在原来基础上增加1；n=3，inversion增加2…n=n时，inversion增加n-1，所以总的inversion为等差求和n(n-1)/2；也可以这样理解，数列[n,n-1,n-2,…,1]中任取两个数皆为逆序对，故逆序数为C(n,2)，即n(n-1)/2。<br>2) 插入排序的运行时间与输入数组中逆序对的数量之间有怎样的关系？<br>我们知道插入排序的程序如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for(int i = 1; i &lt; n; ++i)</div><div class="line">&#123;</div><div class="line">    int key = arr[i];</div><div class="line">    for(int j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; key; --j)</div><div class="line">    &#123;</div><div class="line">        arr[j] = arr[j-1];</div><div class="line">    &#125;</div><div class="line">    arr[j] = key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，每次内层循环都尝试将当前元素放在“合适”的位置上，所以对于内层循环的每一次迭代，都是在消除当前元素相对之前元素所对应的一系列逆序对，故总的循环便是消除数列所有的逆序对；<br>3) 给出一个算法，它能用O(nlgn)的最坏运行时间，确定n个元素的任何排列中逆序对的数目。（提示：修改合并排序）</p>
</blockquote>
<p>《算法导论》在这里直接提示修改合并排序，所以自然就是用到分治归并的思想，那么逆序对是出现在什么时候？出现多少呢？<br>我们知道归并排序是通过分治，然后归并两个有序的序列成一个有序序列。现假设两段有序序列分别是[beg,mid]和[mid+1,end]，在归并过程中（i,j分别为两段序列的下标），如果a[i]<a[j]，则不会产生逆序对；但当a[i]>a[j]时，就出现逆序对了，出现了多少？既然[beg,mid]是有序的，那么[i-mid]序列就都能与a[j]构成逆序对，故：mid-i+1<br>复杂度O(nlgn)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">/* 归并求逆序对数, arr 存储最终有序结果</div><div class="line"> * 在函数外申请一个临时数组作为参数传入</div><div class="line"> * 避免递归不断创建临时数组的开销</div><div class="line"> */</div><div class="line">int Merge(int * arr, int beg, int mid, int end, int * tmp_arr)</div><div class="line">&#123;</div><div class="line">    memcpy(tmp_arr+beg,arr+beg,sizeof(int)*(end-beg+1));</div><div class="line">    int i = beg;</div><div class="line">    int j = mid + 1;</div><div class="line">    int k = beg;</div><div class="line">    int inversion = 0;  // 合并过程中的逆序数</div><div class="line">    while(i &lt;= mid &amp;&amp; j &lt;= end)</div><div class="line">    &#123;</div><div class="line">        if(tmp_arr[i] &lt;= tmp_arr[j])</div><div class="line">        &#123;</div><div class="line">            arr[k++] = tmp_arr[i++];</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            arr[k++] = tmp_arr[j++];</div><div class="line">            inversion += (mid - i + 1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while(i &lt;= mid)</div><div class="line">    &#123;</div><div class="line">        arr[k++] = tmp_arr[i++];</div><div class="line">    &#125;</div><div class="line">    while(j &lt;= end)</div><div class="line">    &#123;</div><div class="line">        arr[k++] = tmp_arr[j++];</div><div class="line">    &#125;</div><div class="line">    return inversion;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int MergeInversion(int * arr, int beg, int end, int * tmp_arr)</div><div class="line">&#123;</div><div class="line">    int inversions = 0;    // 记录倒序数</div><div class="line">    if(beg &lt; end)</div><div class="line">    &#123;</div><div class="line">        int mid = (beg + end) &gt;&gt; 1;</div><div class="line">        inversions += MergeInversion(arr, beg, mid, tmp_arr);</div><div class="line">        inversions += MergeInversion(arr, mid+1, end, tmp_arr);</div><div class="line">        inversions += Merge(arr, beg, mid, end, tmp_arr);</div><div class="line">    &#125;</div><div class="line">    return inversions;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 测试序列 ：answer: 10 */</div><div class="line">int testPoint[10] = &#123;</div><div class="line">    1, 4, 2, 9, 48,</div><div class="line">   15, 13, 44, 6, 90</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">    int arrcopy[10];      // 临时数组</div><div class="line">    memcpy(arrcopy,testPoint,sizeof testPoint);</div><div class="line">    printf(&quot;the num of inversions is: %d\n&quot;,</div><div class="line">            MergeInversion(testPoint,0,9,arrcopy));</div><div class="line">&#125;</div></pre></td></tr></table></figure></a[j]，则不会产生逆序对；但当a[i]></p>
<h1 id="解法三，线段树"><a href="#解法三，线段树" class="headerlink" title="解法三，线段树"></a>解法三，线段树</h1><p><strong>线段树的时间复杂度为O(N^2),和归并排序不同的是线段树可以快速的动态更新呀</strong><br>一般来讲，在解决数列的区间问题上，线段树有很高的出镜率。逆序数便是一个“区间和”的问题：对于数列中的每个元素，它对应的逆序数便是之前序列中大于该元素的元素个数和。<br>有了这样的分析，便可以用线段树来解决了：对于数列中每一个元素x，它必将对应这线段树中的一条长logn的路径，该路径中的每条线段都包含x，故每遍历到一个元素则将包含该元素的路径中的每条线段次数都加1，而查询该元素所对应的逆序数便是查询线段树中[x,up]的区间和，其中up为该序列的上界。<br>举个例子：序列：5，4，3，2，1的逆序数，设up为10<br>i=0，arr[i]=5，查询区间[5,10]的元素个数，此时线段树空，故inversion=0；将5插入包含它的线段路径。<br>i=1，arr[i]=4，查询区间[4,10]的元素个数，为1，故inversion+=1；将4插入包含它的线段路径。<br>i=2，arr[i]=3，查询区间[3,10]的元素个数，为2，故inversion+=0；将3插入包含它的线段路径。<br>以此类推。。。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">/* 线段树求逆序数 */</div><div class="line">#define BORDER 100  // 设测试数列最大不超过100</div><div class="line"> </div><div class="line">struct Node         // 线段树</div><div class="line">&#123;</div><div class="line">    int left;</div><div class="line">    int right;</div><div class="line">    int counter;</div><div class="line">&#125;segTree[4*BORDER];</div><div class="line"> </div><div class="line">/* 构建线段树 根节点开始构建区间[lef,rig]的线段树*/</div><div class="line">void construct(int index, int lef, int rig)</div><div class="line">&#123;</div><div class="line">    segTree[index].left = lef;</div><div class="line">    segTree[index].right = rig;</div><div class="line">    if(lef == rig)   // 叶节点</div><div class="line">    &#123;</div><div class="line">        segTree[index].counter = 0;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid = (lef+rig) &gt;&gt; 1;</div><div class="line">    construct((index&lt;&lt;1)+1, lef, mid);</div><div class="line">    construct((index&lt;&lt;1)+2, mid+1, rig);</div><div class="line">    segTree[index].counter = 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 包含x的区间的值都+1 即对包含x的logn个节点的路径进行更新*/</div><div class="line">void insert(int index, int x)</div><div class="line">&#123;</div><div class="line">    ++segTree[index].counter;</div><div class="line">    if(segTree[index].left == segTree[index].right)</div><div class="line">    &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid = (segTree[index].left + segTree[index].right) &gt;&gt; 1;</div><div class="line">    if(x &lt;= mid)</div><div class="line">    &#123;</div><div class="line">        insert((index&lt;&lt;1)+1, x);</div><div class="line">    &#125;else</div><div class="line">    &#123;</div><div class="line">        insert((index&lt;&lt;1)+2, x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 查询点x的逆序数，即查询[x,BORDER]的区间和 */</div><div class="line">int query(int index, int left, int right)</div><div class="line">&#123;</div><div class="line">    if(segTree[index].left == left &amp;&amp; segTree[index].right == right)</div><div class="line">    &#123;</div><div class="line">        return segTree[index].counter;</div><div class="line">    &#125;</div><div class="line">    int mid = (segTree[index].left+segTree[index].right) &gt;&gt; 1;</div><div class="line">    if(right &lt;= mid)</div><div class="line">    &#123;</div><div class="line">        return query((index&lt;&lt;1)+1,left,right);</div><div class="line">    &#125;else if(left &gt; mid)</div><div class="line">    &#123;</div><div class="line">        return query((index&lt;&lt;1)+2,left,right);</div><div class="line">    &#125;</div><div class="line">    return query((index&lt;&lt;1)+1,left,mid) + query((index&lt;&lt;1)+2,mid+1,right);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 测试序列 ：answer: 10 */</div><div class="line">int testPoint[10] = &#123;</div><div class="line">    1, 4, 2, 9, 48,</div><div class="line">   15, 13, 44, 6, 90</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">    construct(0,0,100);           // 构建[0,100]线段树</div><div class="line">    int reverseSum = 0;           // 记录逆序对数</div><div class="line">    for(int i = 0; i &lt; 10; ++i)   // 查询当前逆序数</div><div class="line">    &#123;</div><div class="line">        reverseSum += query(0,testPoint[i],BORDER);</div><div class="line">        printf(&quot;num of reverse order is: %d\n&quot;, reverseSum);</div><div class="line">        insert(0,testPoint[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于线段树的插入和查询操作皆可以在lgn的时间内完成，故遍历一个数列求逆序数的时间复杂度为O(nlgn)，空间复杂度为O(nlgn)。<br>接下来我将会用线段树解决hdu1394这个题</p>
<h1 id="解法四，树状数组"><a href="#解法四，树状数组" class="headerlink" title="解法四，树状数组"></a>解法四，树状数组</h1><p>Todo…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-3-hdu1754]]></title>
      <url>http://blog.acbingo.cn/2015/08/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-hdu1754/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>简单的线段树单点更新。父节点记录max值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-08-14 08:58</div><div class="line"> * File Name: hdu1754.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define LL long long</div><div class="line">#define ULL unsigned long long</div><div class="line">const int MAXN = 200000+5;</div><div class="line">struct Node &#123;</div><div class="line">    int val;</div><div class="line">&#125;tree[MAXN*20+1000];</div><div class="line">//int arr[MAXN];</div><div class="line">void build(int root,int arr[],int istart,int iend)&#123;</div><div class="line">    if (istart==iend) tree[root].val=arr[istart];</div><div class="line">    else &#123;</div><div class="line">        int mid =(istart+iend)/2;</div><div class="line">        build(root*2+1,arr,istart,mid);</div><div class="line">        build(root*2+2,arr,mid+1,iend);</div><div class="line">        tree[root].val=max(tree[root*2+1].val,tree[root*2+2].val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int query(int root,int nstart,int nend,int qstart,int qend)&#123;</div><div class="line">    //查询区间和当前节点区间没有交集</div><div class="line">    if(qstart &gt; nend || qend &lt; nstart)</div><div class="line">        return 0;</div><div class="line">    //当前节点区间包含在查询区间内</div><div class="line">    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)</div><div class="line">        return tree[root].val;</div><div class="line">    //分别从左右子树查询，返回两者查询结果的较小值</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    return max(query(root*2+1, nstart, mid, qstart, qend),</div><div class="line">               query(root*2+2, mid + 1, nend, qstart, qend));</div><div class="line">&#125;</div><div class="line">int updateOne(int root,int nstart,int nend,int index,int addVal)&#123;</div><div class="line">    if (nstart==nend)&#123;</div><div class="line">        if (index==nstart)</div><div class="line">            tree[root].val=addVal;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    int mid=(nstart+nend)/2;</div><div class="line">    if (index&lt;=mid)</div><div class="line">        updateOne(root*2+1,nstart,mid,index,addVal);</div><div class="line">    else updateOne(root*2+2,mid+1,nend,index,addVal);</div><div class="line">    tree[root].val=max(tree[root*2+1].val,tree[root*2+2].val);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int n,m;</div><div class="line">    int a[MAXN];</div><div class="line">    while(scanf(&quot;%d%d&quot;, &amp;n,&amp;m)!=EOF)&#123;</div><div class="line">        for (int i=1;i&lt;=n;i++)</div><div class="line">            scanf(&quot;%d&quot;,&amp;a[i] );</div><div class="line">        build(0,a,1,n);</div><div class="line">        //updateOne(0,1,n,3,100);</div><div class="line">        //cout&lt;&lt;query(0,1,n,1,5);</div><div class="line">        char ch;</div><div class="line">        for (int i=0;i&lt;m;i++)&#123;</div><div class="line">            getchar();//注意这里，要把换行读掉，不知道为什么，在gcc11中样例没有出现这个问题，所以导致wa好多次看人家代码才发现</div><div class="line">            scanf(&quot;%c&quot;, &amp;ch);</div><div class="line">            //cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</div><div class="line">            if (ch==&apos;Q&apos;)&#123;</div><div class="line">                int x,y;</div><div class="line">                scanf(&quot;%d%d&quot;, &amp;x,&amp;y);</div><div class="line">                printf(&quot;%d\n&quot;,query(0,1,n,x,y));</div><div class="line">            &#125;</div><div class="line">            if (ch==&apos;U&apos;)&#123;</div><div class="line">                int x,y;</div><div class="line">                scanf(&quot;%d%d&quot;, &amp;x,&amp;y);</div><div class="line">                </div><div class="line">                updateOne(0,1,n,x,y);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题多次RE啊。就是数组开小了。<br>生成的线段树的规模能达到maxn<em>20。。<br>一直以为规模也就能到maxn</em>2，结果执着的wa了好多次<br>另外需要注意的一点是，在读char之前，要把换行都掉<br>两种解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getchar();</div><div class="line">scanf(&quot;%c%d%d&quot;, &amp;ch,&amp;x,y&amp;);</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scanf(&quot;%*c%c%d%d&quot;, &amp;ch,&amp;x,y&amp;);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-2-hdu1166]]></title>
      <url>http://blog.acbingo.cn/2015/08/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-hdu1166/</url>
      <content type="html"><![CDATA[<h1 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h1><p>初学者用来学习线段树最合适不过了。<br>最最基础的线段树,只更新叶子节点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>运用上篇文章中的模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015-08-12 10:55</div><div class="line"> * File Name: hdu1166.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define LL long long</div><div class="line">#define ULL unsigned long long</div><div class="line">const int MAXN = 50000+5;</div><div class="line">struct Node &#123;</div><div class="line">    int val;</div><div class="line">&#125;tree[MAXN*20+100];</div><div class="line">int arr[50000+5];</div><div class="line">void build(int root,int arr[],int istart,int iend)&#123;</div><div class="line">    if (istart==iend) tree[root].val=arr[istart];</div><div class="line">    else &#123;</div><div class="line">        int mid =(istart+iend)/2;</div><div class="line">        build(root*2+1,arr,istart,mid);</div><div class="line">        build(root*2+2,arr,mid+1,iend);</div><div class="line">        tree[root].val=tree[root*2+1].val+tree[root*2+2].val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int query(int root,int nstart,int nend,int qstart,int qend)&#123;</div><div class="line">    if (qstart&lt;=nstart&amp;&amp;qend&gt;=nend) &#123;</div><div class="line">        //cout&lt;&lt;nstart&lt;&lt;&quot; &quot;&lt;&lt;nend&lt;&lt;endl;</div><div class="line">        return tree[root].val;</div><div class="line">    &#125;</div><div class="line">    int mid=(nstart+nend)/2;</div><div class="line">    int tmp=0;</div><div class="line">    if (mid&gt;=qstart) tmp+=query(root*2+1,nstart,mid,qstart,qend);</div><div class="line">    if (mid+1&lt;=qend) tmp+=query(root*2+2,mid+1,nend,qstart,qend);</div><div class="line">    return tmp;</div><div class="line">&#125;</div><div class="line">int updateOne(int root,int nstart,int nend,int index,int addVal)&#123;</div><div class="line">    if (nstart==nend)&#123;</div><div class="line">        if (index==nstart)</div><div class="line">            tree[root].val+=addVal;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    int mid=(nstart+nend)/2;</div><div class="line">    if (index&lt;=mid)</div><div class="line">        updateOne(root*2+1,nstart,mid,index,addVal);</div><div class="line">    else updateOne(root*2+2,mid+1,nend,index,addVal);</div><div class="line">    tree[root].val=tree[root*2+1].val+tree[root*2+2].val;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int T,n,test=0;</div><div class="line">    cin&gt;&gt;T;</div><div class="line">    while (T--)&#123;</div><div class="line">        cin&gt;&gt;n;</div><div class="line">        for (int i=1;i&lt;=n;i++)&#123;</div><div class="line">            cin &gt;&gt; arr[i];</div><div class="line">        &#125;</div><div class="line">        build(0,arr,1,n);</div><div class="line">        //cout&lt;&lt;tree[0].val&lt;&lt;endl;</div><div class="line">        //cout&lt;&lt;query(0,1,n,3,7);</div><div class="line">        //updateOne(0,1,n,5,100);</div><div class="line">        //cout&lt;&lt;query(0,1,n,3,7);</div><div class="line">        string s;</div><div class="line">        int p,q;</div><div class="line">        test++;</div><div class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;test&lt;&lt;&quot;:&quot;&lt;&lt;endl;</div><div class="line">        while (cin&gt;&gt;s&amp;&amp;s!=&quot;End&quot;)&#123;</div><div class="line">            cin&gt;&gt;p&gt;&gt;q;</div><div class="line">            if (s==&quot;Query&quot;) cout&lt;&lt;query(0,1,n,p,q)&lt;&lt;endl;</div><div class="line">            if (s==&quot;Add&quot;) updateOne(0,1,n,p,q);</div><div class="line">            if (s==&quot;Sub&quot;) updateOne(0,1,n,p,-q);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><p>发现了某大牛的代码，i-=&amp;-i这一行叼不行了<br>然而时间和上段代码一样，在hdu上都是跑904ms，代码量少了一半，然而时间还是完全一样！<br>看样子hdu检测时间就是nb啊= =，在uva上完全一样的代码不同时间交跑出来的时间还不一样。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">//#define CLOSE ios::sync_with_stdio(false)</div><div class="line">#define maxn 50000+5</div><div class="line">using namespace std;</div><div class="line">int bit[maxn*20],n;</div><div class="line">int sum(int i)&#123;</div><div class="line">    int s=0;</div><div class="line">    while (i&gt;0)&#123;</div><div class="line">        s+=bit[i];</div><div class="line">        i-=i&amp;-i;</div><div class="line">    &#125;</div><div class="line">    return s;</div><div class="line">&#125;</div><div class="line">void add(int i,int x)&#123;</div><div class="line">    while (i&lt;=n)&#123;</div><div class="line">        bit[i]+=x;</div><div class="line">        i+=i&amp;-i;</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int T,test=0;</div><div class="line">    //scanf(&quot;%d&quot;,&amp;T );</div><div class="line">    cin&gt;&gt;T;</div><div class="line">    while(T--)&#123;</div><div class="line">        memset(bit,0,sizeof(bit));</div><div class="line">        //scanf(&quot;%d&quot;,&amp;n );</div><div class="line">        cin&gt;&gt;n;</div><div class="line">        for (int i=1;i&lt;=n;i++)&#123;</div><div class="line">            int k;</div><div class="line">            //scanf(&quot;%d&quot;,&amp;k );</div><div class="line">            cin&gt;&gt;k;</div><div class="line">            add(i,k);</div><div class="line">        &#125;</div><div class="line">        test++;</div><div class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;test&lt;&lt;&quot;:&quot;&lt;&lt;endl;</div><div class="line">        //printf(&quot;Case %d:\n&quot;,test);</div><div class="line">        //char s[maxn];</div><div class="line">        string s;</div><div class="line">        while (cin&gt;&gt;s&amp;&amp;s[0]!=&apos;E&apos;)&#123;</div><div class="line">            if (s[0]==&apos;Q&apos;)&#123;</div><div class="line">                int l,r;</div><div class="line">                //scanf(&quot;%d%d&quot;,&amp;l,&amp;r );</div><div class="line">                cin&gt;&gt;l&gt;&gt;r;</div><div class="line"></div><div class="line">                //printf(&quot;%d\n&quot;,sum(r)-sum(l-1));</div><div class="line">                cout&lt;&lt;sum(r)-sum(l-1)&lt;&lt;endl;</div><div class="line">            &#125;else&#123;</div><div class="line">                int i,x;</div><div class="line">                cin&gt;&gt;i&gt;&gt;x;</div><div class="line">                //scanf(&quot;%d%d&quot;, &amp;i,&amp;x);</div><div class="line">                if (s[0]==&apos;S&apos;) x=-x;</div><div class="line">                add(i,x);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="输入输出效率分析"><a href="#输入输出效率分析" class="headerlink" title="输入输出效率分析"></a>输入输出效率分析</h2><p>正好利用这段代码对cin,cout以及scanf，printf进行效率分析<br><img src="http://i1.tietuku.com/eabef177dc105131.png" alt=""><br>从下往上依次是scanf,printf<br>cin,cout,没有开启流加速<br>cin,cout,开启了流加速<br>看样子开启流加速并没有大的卵用。。<br>另外,对于输入量大的数据必须改掉喜欢cincout的习惯呀</p>
<p>ps.听说流加速的效率要看oj后台的judge机，如果是win那就没什么卵用，如果是Linux那就相当有卵用</p>
<h2 id="递归效率分析"><a href="#递归效率分析" class="headerlink" title="递归效率分析"></a>递归效率分析</h2><p><img src="http://i1.tietuku.com/bccb1fb1be0dea30.png" alt=""><br><img src="http://i1.tietuku.com/56303c00dcce3610.png" alt=""><br>看代码量，一个扔到函数里，递归实现的， 一个是单独用数组下标跳转实现的,时间完全一样！<br>根据队里某大神实测栈空间大约2M，是否爆栈不是递归多少层决定的，而是占多少内存决定的，一个子函数到底会占多少内存和代码长度申请变量多少都有关系</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线段树学习笔记-1-入门]]></title>
      <url>http://blog.acbingo.cn/2015/08/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本文转载自<a href="http://www.cnblogs.com/TenosDoIt/p/3453089.html" target="_blank" rel="external">JustDoIT</a>,感谢原作者。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线段树，类似区间树，是一个完全二叉树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。<br>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。</p>
<h1 id="从一个例子理解线段树"><a href="#从一个例子理解线段树" class="headerlink" title="从一个例子理解线段树"></a>从一个例子理解线段树</h1><p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新。<br>对这个问题一个简单的解法是：遍历数组区间找到最小值，时间复杂度是O(n),额外的空间复杂度O(1)。当数据量特别大，而查询操作很频繁的时候，耗时可能会不满足需求。<br>另一种解法：使用一个二维数组来保存提前计算好的区间[i,j]内的最小值，那么预处理时间为O(n^2)，查询耗时O(1), 但是需要额外的O(n^2)空间，当数据量很大时，这个空间消耗是庞大的，而且当改变了数组中的某一个值时，更新二维数组中的最小值也很麻烦。<br>我们可以用线段树来解决这个问题：预处理耗时O(n)，查询、更新操作O(logn)，需要额外的空间O(n)。根据这个问题我们构造如下的二叉树</p>
<ul>
<li>叶子节点是原始组数arr中的元素</li>
<li>非叶子节点代表它的所有子孙叶子节点所在区间的最小值<br>例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）：<br><img src="http://images.cnitblog.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg" alt=""><br>由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含n个叶子节点的完全二叉树，它一定有n-1个非叶节点，总共2n-1个节点，因此存储线段是需要的空间复杂度是O(n)。那么线段树的操作：创建线段树、查询、节点更新 是如何运作的呢（以下所有代码都是针对求区间最小值问题）？<h2 id="创建线段树"><a href="#创建线段树" class="headerlink" title="创建线段树"></a>创建线段树</h2>对于线段树我们可以选择和普通二叉树一样的链式结构。由于线段树是完全二叉树，我们也可以用数组来存储，下面的讨论及代码都是数组来存储线段树，节点结构如下（注意到用数组存储时，有效空间为2n-1,实际空间确不止这么多，比如上面的线段树中叶子节点1、3虽然没有左右子树，但是的确占用了数组空间，实际空间是满二叉树的节点数目,但是这个空间复杂度也是O(n)的)。<br>struct SegTreeNode<br>{<br>　　int val;<br>};<br>定义包含n个节点的线段树 SegTreeNode segTree[n]，segTree[0]表示根节点。那么对于节点segTree[i]，它的左孩子是segTree[2<em>i+1],右孩子是segTree[2</em>i+2]。<br>我们可以从根节点开始，平分区间，递归的创建线段树，线段树的创建函数如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const int MAXNUM = 1000;</div><div class="line">struct SegTreeNode</div><div class="line">&#123;</div><div class="line">    int val;</div><div class="line">&#125;segTree[MAXNUM*4];//定义线段树</div><div class="line"></div><div class="line">/*</div><div class="line">功能：构建线段树</div><div class="line">root：当前线段树的根节点下标</div><div class="line">arr: 用来构造线段树的数组</div><div class="line">istart：数组的起始位置</div><div class="line">iend：数组的结束位置</div><div class="line">*/</div><div class="line">void build(int root, int arr[], int istart, int iend)</div><div class="line">&#123;</div><div class="line">    if(istart == iend)//叶子节点</div><div class="line">        segTree[root].val = arr[istart];</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        int mid = (istart + iend) / 2;</div><div class="line">        build(root*2+1, arr, istart, mid);//递归构造左子树</div><div class="line">        build(root*2+2, arr, mid+1, iend);//递归构造右子树</div><div class="line">        //根据左右子树根节点的值，更新当前根节点的值</div><div class="line">        segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>，定义tree结构数组的时候，该数组的大小是maxn*4！注意这里，否认程序会RE;</p>
<h2 id="查询线段树"><a href="#查询线段树" class="headerlink" title="查询线段树"></a>查询线段树</h2><p>已经构建好了线段树，那么怎样在它上面超找某个区间的最小值呢？查询的思想是选出一些区间，使他们相连后恰好涵盖整个查询区间，因此线段树适合解决“相邻的区间的信息可以被合并成两个区间的并区间的信息”的问题。代码如下，具体见代码解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">功能：线段树的区间查询</div><div class="line">root：当前线段树的根节点下标</div><div class="line">[nstart, nend]: 当前节点所表示的区间</div><div class="line">[qstart, qend]: 此次查询的区间</div><div class="line">*/</div><div class="line">int query(int root, int nstart, int nend, int qstart, int qend)</div><div class="line">&#123;</div><div class="line">    //查询区间和当前节点区间没有交集</div><div class="line">    if(qstart &gt; nend || qend &lt; nstart)</div><div class="line">        return INFINITE;</div><div class="line">    //当前节点区间包含在查询区间内</div><div class="line">    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)</div><div class="line">        return segTree[root].val;</div><div class="line">    //分别从左右子树查询，返回两者查询结果的较小值</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    return min(query(root*2+1, nstart, mid, qstart, qend),</div><div class="line">               query(root*2+2, mid + 1, nend, qstart, qend));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>举例说明（对照上面的二叉树）：<br>1、当我们要查询区间[0,2]的最小值时，从根节点开始，要分别查询左右子树，查询左子树时节点区间[0,2]包含在查询区间[0,2]内，返回当前节点的值1，查询右子树时，节点区间[3,5]和查询区间[0,2]没有交集，返回正无穷INFINITE，查询结果取两子树查询结果的较小值1，因此结果是1.<br>2、查询区间[0,3]时，从根节点开始，查询左子树的节点区间[0,2]包含在区间[0,3]内，返回当前节点的值1；查询右子树时，继续递归查询右子树的左右子树，查询到非叶节点4时，又要继续递归查询：叶子节点4的节点区间[3,3]包含在查询区间[0,3]内，返回4，叶子节点9的节点区间[4,4]和[0,3]没有交集，返回INFINITE,因此非叶节点4返回的是min(4, INFINITE) = 4，叶子节点3的节点区间[5,5]和[0,3]没有交集，返回INFINITE,因此非叶节点3返回min(4, INFINITE) = 4, 因此根节点返回 min(1,4) = 1。</p>
<h2 id="单节点更新"><a href="#单节点更新" class="headerlink" title="单节点更新"></a>单节点更新</h2><p>单节点更新是指只更新线段树的某个叶子节点的值，但是更新叶子节点会对其父节点的值产生影响，因此更新子节点后，要回溯更新其父节点的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">功能：更新线段树中某个叶子节点的值</div><div class="line">root：当前线段树的根节点下标</div><div class="line">[nstart, nend]: 当前节点所表示的区间</div><div class="line">index: 待更新节点在原始数组arr中的下标</div><div class="line">addVal: 更新的值（原来的值加上addVal）</div><div class="line">*/</div><div class="line">void updateOne(int root, int nstart, int nend, int index, int addVal)</div><div class="line">&#123;</div><div class="line">    if(nstart == nend)</div><div class="line">    &#123;</div><div class="line">        if(index == nstart)//找到了相应的节点，更新之</div><div class="line">            segTree[root].val += addVal;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    if(index &lt;= mid)//在左子树中更新</div><div class="line">        updateOne(root*2+1, nstart, mid, index, addVal);</div><div class="line">    else updateOne(root*2+2, mid+1, nend, index, addVal);//在右子树中更新</div><div class="line">    //根据左右子树的值回溯更新当前节点的值</div><div class="line">    segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如我们要更新叶子节点4（addVal = 6）,更新后值变为10，那么其父节点的值从4变为9，非叶结点3的值更新后不变，根节点更新后也不变。</p>
<h2 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h2><p>区间更新是指更新某个区间内的叶子节点的值，因为涉及到的叶子节点不止一个，而叶子节点会影响其相应的非叶父节点，那么回溯需要更新的非叶子节点也会有很多，如果一次性更新完，操作的时间复杂度肯定不是O(lgn)，例如当我们要更新区间[0,3]内的叶子节点时，需要更新出了叶子节点3,9外的所有其他节点。为此引入了线段树中的延迟标记概念，这也是线段树的精华所在。<br>延迟标记：每个节点新增加一个标记，记录这个节点是否进行了某种修改(这种修改操作会影响其子节点)，对于任意区间的修改，我们先按照区间查询的方式将其划分成线段树中的节点，然后修改这些节点的信息，并给这些节点标记上代表这种修改操作的标记。在修改和查询的时候，如果我们到了一个节点p，并且决定考虑其子节点，那么我们就要看节点p是否被标记，如果有，就要按照标记修改其子节点的信息，并且给子节点都标上相同的标记，同时消掉节点p的标记。<br>因此需要在线段树结构中加入延迟标记域，本文例子中我们加入标记与addMark，表示节点的子孙节点在原来的值的基础上加上addMark的值，同时还需要修改创建函数build 和 查询函数 query，修改的代码用红色字体表示，其中区间更新的函数为update，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">const int INFINITE = INT_MAX;</div><div class="line">const int MAXNUM = 1000;</div><div class="line">struct SegTreeNode</div><div class="line">&#123;</div><div class="line">    int val;</div><div class="line">    int addMark;//延迟标记</div><div class="line">&#125;segTree[MAXNUM*20];//定义线段树</div><div class="line"></div><div class="line">/*</div><div class="line">功能：构建线段树</div><div class="line">root：当前线段树的根节点下标</div><div class="line">arr: 用来构造线段树的数组</div><div class="line">istart：数组的起始位置</div><div class="line">iend：数组的结束位置</div><div class="line">*/</div><div class="line">void build(int root, int arr[], int istart, int iend)</div><div class="line">&#123;</div><div class="line">    segTree[root].addMark = 0;//----设置标延迟记域</div><div class="line">    if(istart == iend)//叶子节点</div><div class="line">        segTree[root].val = arr[istart];</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        int mid = (istart + iend) / 2;</div><div class="line">        build(root*2+1, arr, istart, mid);//递归构造左子树</div><div class="line">        build(root*2+2, arr, mid+1, iend);//递归构造右子树</div><div class="line">        //根据左右子树根节点的值，更新当前根节点的值</div><div class="line">        segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">功能：当前节点的标志域向孩子节点传递</div><div class="line">root: 当前线段树的根节点下标</div><div class="line">*/</div><div class="line">void pushDown(int root)</div><div class="line">&#123;</div><div class="line">    if(segTree[root].addMark != 0)</div><div class="line">    &#123;</div><div class="line">        //设置左右孩子节点的标志域，因为孩子节点可能被多次延迟标记又没有向下传递</div><div class="line">        //所以是 “+=”</div><div class="line">        segTree[root*2+1].addMark += segTree[root].addMark;</div><div class="line">        segTree[root*2+2].addMark += segTree[root].addMark;</div><div class="line">        //根据标志域设置孩子节点的值。因为我们是求区间最小值，因此当区间内每个元</div><div class="line">        //素加上一个值时，区间的最小值也加上这个值</div><div class="line">        segTree[root*2+1].val += segTree[root].addMark;</div><div class="line">        segTree[root*2+2].val += segTree[root].addMark;</div><div class="line">        //传递后，当前节点标记域清空</div><div class="line">        segTree[root].addMark = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">功能：线段树的区间查询</div><div class="line">root：当前线段树的根节点下标</div><div class="line">[nstart, nend]: 当前节点所表示的区间</div><div class="line">[qstart, qend]: 此次查询的区间</div><div class="line">*/</div><div class="line">int query(int root, int nstart, int nend, int qstart, int qend)</div><div class="line">&#123;</div><div class="line">    //查询区间和当前节点区间没有交集</div><div class="line">    if(qstart &gt; nend || qend &lt; nstart)</div><div class="line">        return INFINITE;</div><div class="line">    //当前节点区间包含在查询区间内</div><div class="line">    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)</div><div class="line">        return segTree[root].val;</div><div class="line">    //分别从左右子树查询，返回两者查询结果的较小值</div><div class="line">    pushDown(root); //----延迟标志域向下传递</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    return min(query(root*2+1, nstart, mid, qstart, qend),</div><div class="line">               query(root*2+2, mid + 1, nend, qstart, qend));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">功能：更新线段树中某个区间内叶子节点的值</div><div class="line">root：当前线段树的根节点下标</div><div class="line">[nstart, nend]: 当前节点所表示的区间</div><div class="line">[ustart, uend]: 待更新的区间</div><div class="line">addVal: 更新的值（原来的值加上addVal）</div><div class="line">*/</div><div class="line">void update(int root, int nstart, int nend, int ustart, int uend, int addVal)</div><div class="line">&#123;</div><div class="line">    //更新区间和当前节点区间没有交集</div><div class="line">    if(ustart &gt; nend || uend &lt; nstart)</div><div class="line">        return ;</div><div class="line">    //当前节点区间包含在更新区间内</div><div class="line">    if(ustart &lt;= nstart &amp;&amp; uend &gt;= nend)</div><div class="line">    &#123;</div><div class="line">        segTree[root].addMark += addVal;</div><div class="line">        segTree[root].val += addVal;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    pushDown(root); //延迟标记向下传递</div><div class="line">    //更新左右孩子节点</div><div class="line">    int mid = (nstart + nend) / 2;</div><div class="line">    update(root*2+1, nstart, mid, ustart, uend, addVal);</div><div class="line">    update(root*2+2, mid+1, nend, ustart, uend, addVal);</div><div class="line">    //根据左右子树的值回溯更新当前节点的值</div><div class="line">    segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>区间更新举例说明：当我们要对区间[0,2]的叶子节点增加2，利用区间查询的方法从根节点开始找到了非叶子节点[0-2]，把它的值设置为1+2 = 3，并且把它的延迟标记设置为2，更新完毕；当我们要查询区间[0,1]内的最小值时，查找到区间[0,2]时，发现它的标记不为0，并且还要向下搜索，因此要把标记向下传递，把节点[0-1]的值设置为2+2 = 4，标记设置为2，节点[2-2]的值设置为1+2 = 3，标记设置为2（其实叶子节点的标志是不起作用的，这里是为了操作的一致性），然后返回查询结果：[0-1]节点的值4；当我们再次更新区间[0,1]（增加3）时，查询到节点[0-1],发现它的标记值为2，因此把它的标记值设置为2+3 = 5，节点的值设置为4+3 = 7；<br>其实当区间更新的区间左右值相等时（[i,i]），就相当于单节点更新，单节点更新只是区间更新的特例。</p>
<h1 id="线段树实战"><a href="#线段树实战" class="headerlink" title="线段树实战"></a>线段树实战</h1><p>之后的几篇文章会通过acm的一些题目来运用线段树</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[GeeksforGeeks] (<a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="external">http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/</a>)<br><a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="external">GeeksforGeeks</a><br>懂得博客<a href="http://dongxicheng.org/structure/segment-tree/" target="_blank" rel="external">数据结构之线段树</a><br>MetaSeed<a href="http://blog.csdn.net/metalseed/article/details/8039326" target="_blank" rel="external">数据结构专题—线段树</a><br>otOnlySuccess<a href="http://www.notonlysuccess.com/index.php/segment-tree-complete/" target="_blank" rel="external">完全版 线段树</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coursera_程序设计与算法_计算导论与C语言基础_期末编程测试]]></title>
      <url>http://blog.acbingo.cn/2015/08/11/Coursera_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95_%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%9C%9F%E6%9C%AB%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h1 id="编程题＃1：判断闰年"><a href="#编程题＃1：判断闰年" class="headerlink" title="编程题＃1：判断闰年"></a>编程题＃1：判断闰年</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>判断某年是否是闰年。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入只有一行，包含一个整数a(0 &lt; a &lt; 3000)</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>一行，如果公元a年是闰年输出Y，否则输出N<br><a id="more"></a></p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2006</div></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">N</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main () &#123;</div><div class="line">    int a;</div><div class="line">    cin&gt;&gt;a;</div><div class="line">    if (a%4==0) &#123;</div><div class="line">        if (a%100==0&amp;&amp;a%400) cout&lt;&lt;&apos;N&apos;&lt;&lt;endl;</div><div class="line">        else cout&lt;&lt;&apos;Y&apos;&lt;&lt;endl;</div><div class="line">    &#125;else cout&lt;&lt;&apos;N&apos;&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃2：能被3，5，7整除的数"><a href="#编程题＃2：能被3，5，7整除的数" class="headerlink" title="编程题＃2：能被3，5，7整除的数"></a>编程题＃2：能被3，5，7整除的数</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数，判断它能否被3，5，7整除，并输出以下信息：</p>
<p>1、能同时被3，5，7整除（直接输出3 5 7，每个数中间一个空格）；</p>
<p>2、能被其中两个数整除（输出两个数，小的在前，大的在后。例如：3 5或者 3 7或者5 7,中间用空格分隔）</p>
<p>3、能被其中一个数整除（输出这个除数）</p>
<p>4、不能被任何数整除；（输出小写字符’n’,不包括单引号)</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>一个数字</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>一行数字,从小到大排列,包含3,5,7中为该输入的除数的数字,数字中间用空格隔开</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">5</div><div class="line">15</div><div class="line">105</div></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3 5 7</div><div class="line">5</div><div class="line">3 5</div><div class="line">3 5 7</div></pre></td></tr></table></figure>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while (cin&gt;&gt;n)&#123;</div><div class="line">        int a=0,b=0,c=0;</div><div class="line">        if (n%3==0) a++;</div><div class="line">        if (n%5==0) b++;</div><div class="line">        if (n%7==0) c++;</div><div class="line">        if (a&amp;&amp;b&amp;&amp;c) cout&lt;&lt;&quot;3 5 7&quot;&lt;&lt;endl;</div><div class="line">        if (a&amp;&amp;b&amp;&amp;!c) cout&lt;&lt;&quot;3 5&quot;&lt;&lt;endl;</div><div class="line">        if (a&amp;&amp;!b&amp;&amp;c) cout&lt;&lt;&quot;3 7&quot;&lt;&lt;endl;</div><div class="line">        if (!a&amp;&amp;b&amp;&amp;c) cout&lt;&lt;&quot;5 7&quot;&lt;&lt;endl;</div><div class="line">        if (!a&amp;&amp;!b&amp;&amp;c) cout&lt;&lt;&quot;7&quot;&lt;&lt;endl;</div><div class="line">        if (!a&amp;&amp;b&amp;&amp;!c) cout&lt;&lt;&quot;5&quot;&lt;&lt;endl;</div><div class="line">        if (a&amp;&amp;!b&amp;&amp;!c) cout&lt;&lt;&quot;3&quot;&lt;&lt;endl;</div><div class="line">        if (!a&amp;&amp;!b&amp;&amp;!c) cout&lt;&lt;&quot;n&quot;&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃3：最远距离"><a href="#编程题＃3：最远距离" class="headerlink" title="编程题＃3：最远距离"></a>编程题＃3：最远距离</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>给定一组点(x,y)，求距离最远的两个点之间的距离。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>第一行是点数n（n大于等于2）</p>
<p>接着每一行代表一个点，由两个浮点数x y组成。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一行是最远两点之间的距离。</p>
<p>使用cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; dis) &lt;&lt; endl;输出距离值并精确到小数点后4位。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">6</div><div class="line">34.0 23.0</div><div class="line">28.1 21.6</div><div class="line">14.7 17.1</div><div class="line">17.0 27.2</div><div class="line">34.7 67.1</div><div class="line">29.3 65.1</div></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">53.8516</div></pre></td></tr></table></figure>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main () &#123;</div><div class="line">    double x,y,t;</div><div class="line">    t=0;</div><div class="line">    int n;</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    double a[1000][2];</div><div class="line">    for (int i=0;i&lt;n;i++)&#123;</div><div class="line">            cin&gt;&gt;a[i][0]&gt;&gt;a[i][1];</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">        &#123;</div><div class="line">            double tmp=dis(a[i][0],a[i][1],a[j][0],a[j][1]);</div><div class="line">            if (t&lt;tmp) t=tmp;</div><div class="line">        &#125;</div><div class="line">    cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; t &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃4：简单计算器"><a href="#编程题＃4：简单计算器" class="headerlink" title="编程题＃4：简单计算器"></a>编程题＃4：简单计算器</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>一个最简单的计算器，支持+, -, *, / 四种运算。仅需考虑输入输出为整数的情况，数据和运算结果不会超过int表示的范围。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入只有一行，共有三个参数，其中第1、2个参数为整数，第3个参数为操作符（+,-,*,/）。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出只有一行，一个整数，为运算结果。然而：</p>
<ol>
<li><p>如果出现除数为0的情况，则输出：Divided by zero!</p>
</li>
<li><p>如果出现无效的操作符(即不为 +, -, *, / 之一），则输出：Invalid operator!</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 +</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3</div></pre></td></tr></table></figure>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int main () &#123;</div><div class="line">    int a,b;</div><div class="line">    char ch;</div><div class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;ch;</div><div class="line">    if (b==0&amp;&amp;ch==&apos;/&apos;) cout&lt;&lt;&quot;Divided by zero!&quot;&lt;&lt;endl;</div><div class="line">    else &#123;</div><div class="line">        switch (ch)&#123;</div><div class="line">            case &apos;+&apos;:cout&lt;&lt;a+b&lt;&lt;endl;break;</div><div class="line">            case &apos;-&apos;:cout&lt;&lt;a-b&lt;&lt;endl;break;</div><div class="line">            case &apos;*&apos;:cout&lt;&lt;a*b&lt;&lt;endl;break;</div><div class="line">            case &apos;/&apos;:cout&lt;&lt;a/b&lt;&lt;endl;break;</div><div class="line">            default:</div><div class="line">                cout&lt;&lt;&quot;Invalid operator!&quot;&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃5：字符串插入"><a href="#编程题＃5：字符串插入" class="headerlink" title="编程题＃5：字符串插入"></a>编程题＃5：字符串插入</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>有两个字符串str和substr，str的字符个数不超过10，substr的字符个数为3。（字符个数不包括字符串结尾处的’\0’。）将substr插入到str中ASCII码最大的那个字符后面，若有多个最大则只考虑第一个。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入包括若干行，每一行为一组测试数据，格式为<br>str substr</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>对于每一组测试数据，输出插入之后的字符串。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abcab eee</div><div class="line">12343 555</div></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abceeeab</div><div class="line">12345553</div></pre></td></tr></table></figure>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main () &#123;</div><div class="line">    string a,b;</div><div class="line">    while (cin&gt;&gt;a&gt;&gt;b)&#123;</div><div class="line">    int p=0,t=a[0];</div><div class="line">    for (int i=0;i&lt;a.size();i++)</div><div class="line">        if (a[i]&gt;t) &#123;t=a[i];p=i;&#125;</div><div class="line">    a.insert(p+1,b);</div><div class="line">    cout&lt;&lt;a&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coursera_程序设计与算法_计算导论与C语言基础_数组应用练习]]></title>
      <url>http://blog.acbingo.cn/2015/08/10/Coursera_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95_C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6_C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="编程题＃1：求字母的个数"><a href="#编程题＃1：求字母的个数" class="headerlink" title="编程题＃1：求字母的个数"></a>编程题＃1：求字母的个数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在一个字符串中找出元音字母a,e,i,o,u出现的次数。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入一行字符串（字符串中可能有空格，请用gets(s)方法把一行字符串输入到字符数组s中），字符串长度小于80个字符。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一行，依次输出a,e,i,o,u在输入字符串中出现的次数，整数之间用空格分隔。</p>
<p>##样例输入<br>If so, you already have a Google Account. You can sign in on the right.</p>
<p>##样例输出<br>5 4 3 7 3<br><a id="more"></a></p>
<p>##代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    getline(cin,s);</div><div class="line">    int len=s.size();</div><div class="line">    int a=0,b=0,c=0,d=0,e=0;</div><div class="line">    for (int i=0;i&lt;len;i++)&#123;</div><div class="line">        if (s[i]==&apos;a&apos;) a++;</div><div class="line">        if (s[i]==&apos;e&apos;) b++;</div><div class="line">        if (s[i]==&apos;i&apos;) c++;</div><div class="line">        if (s[i]==&apos;o&apos;) d++;</div><div class="line">        if (s[i]==&apos;u&apos;) e++;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：忽略大小写比较字符串大小"><a href="#编程题＃2：忽略大小写比较字符串大小" class="headerlink" title="编程题＃2：忽略大小写比较字符串大小"></a>编程题＃2：忽略大小写比较字符串大小</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到’\0’为止。如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准。但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如”Hello”和”hello”在忽略字母大小写时是相等的。请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入为两行，每行一个字符串，共两个字符串。（请用gets录入每行字符串）（每个字符串长度都小于80）</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>如果第一个字符串比第二个字符串小，输出一个字符”&lt;”</p>
<p>如果第一个字符串比第二个字符串大，输出一个字符”&gt;”</p>
<p>如果两个字符串相等，输出一个字符”=”</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello</div><div class="line">hello</div></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s1,s2;</div><div class="line">    cin&gt;&gt;s1&gt;&gt;s2;</div><div class="line">    for (int i=0;i&lt;s1.size();i++)</div><div class="line">        s1[i]=toupper(s1[i]);</div><div class="line">    for (int i=0;i&lt;s2.size();i++)</div><div class="line">        s2[i]=toupper(s2[i]);</div><div class="line">    if (s1&lt;s2) cout&lt;&lt;&quot;&lt;&quot;;</div><div class="line">    else if (s1&gt;s2) cout&lt;&lt;&quot;&gt;&quot;;</div><div class="line">    else cout&lt;&lt;&quot;=&quot;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃3：最长单词2"><a href="#编程题＃3：最长单词2" class="headerlink" title="编程题＃3：最长单词2"></a>编程题＃3：最长单词2</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>一个以’.’结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一个以’.’结尾的简单英文句子（长度不超过500），单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>该句子中最长的单词。如果多于一个，则输出第一个</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>I am a student of Peking University.</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>University</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    char t[600];</div><div class="line">    gets(t);</div><div class="line">    s=t;</div><div class="line">    s[s.size()-1]=&apos; &apos;;</div><div class="line">    //puts(t);</div><div class="line">    stringstream ss(s);</div><div class="line">    string ans;</div><div class="line">    int len=0;</div><div class="line">    while (ss&gt;&gt;s) if (s.size()&gt;len) &#123;len=s.size();ans=s;&#125;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃4：矩阵交换行"><a href="#编程题＃4：矩阵交换行" class="headerlink" title="编程题＃4：矩阵交换行"></a>编程题＃4：矩阵交换行</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>编写一个函数，输入参数是5*5的二维数组，和n，m两个行下标。功能：判断n，m是否在数组范围内，如果不在，则返回0；如果在范围内，则将n行和m行交换，并返回1。</p>
<p>在main函数中， 生成一个5*5的矩阵，输入矩阵数据，并输入n，m的值。调用前面的函数。如果返回值为0，输出error。如果返回值为1，输出交换n，m后的新矩阵。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>5*5矩阵的数据，以及n和m的值。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>如果不可交换，则输出error；</p>
<p>如果可交换，则输出新矩阵</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 2 1 2</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">3 0 8 2 4</div><div class="line">0 4</div></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">3 0 8 2 4</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">1 2 2 1 2</div></pre></td></tr></table></figure>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/6 19:33:47</div><div class="line"> * File Name: 9-4.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">#include &lt;iomanip&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[5][5];</div><div class="line">    for (int i=0;i&lt;5;i++)</div><div class="line">        for (int j=0;j&lt;5;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    if (n&lt;0||n&gt;4||m&lt;0||m&gt;4) cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</div><div class="line">    else &#123;</div><div class="line">        for (int i=0;i&lt;5;i++)&#123;</div><div class="line">            if (i==n)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[m][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[m][4]&lt;&lt;endl;</div><div class="line">            &#125;else if (i==m)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[n][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[n][4]&lt;&lt;endl;</div><div class="line">            &#125;else &#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[i][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[i][4]&lt;&lt;endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃5：异常细胞检测"><a href="#编程题＃5：异常细胞检测" class="headerlink" title="编程题＃5：异常细胞检测"></a>编程题＃5：异常细胞检测</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>我们拍摄的一张CT照片用一个二维数组来存储，假设数组中的每个点代表一个细胞。每个细胞的颜色用0到255之间（包括0和255）的一个整数表示。我们定义一个细胞是异常细胞，如果这个细胞的颜色值比它上下左右4个细胞的颜色值都小50以上（包括50）。数组边缘上的细胞我们不检测。现在我们的任务是，给定一个存储CT照片的二维数组，写程序统计照片中异常细胞的数目。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数N（100&gt;=N&gt;2）.</p>
<p>下面有 N 行，每行有 N 个0~255之间的整数，整数之间用空格隔开。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出只有一行，包含一个整数，为异常细胞的数目。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">70 70 70 70</div><div class="line">70 10 70 70</div><div class="line">70 70 20 70</div><div class="line">70 70 70 70</div></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    int a[150][150];</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int cnt=0;</div><div class="line">    for (int i=1;i&lt;n-1;i++)</div><div class="line">        for (int j=1;j&lt;n-1;j++)</div><div class="line">            if ((a[i-1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i+1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i][j-1]-a[i][j]&gt;=50)&amp;&amp;(a[i][j+1]-a[i][j]&gt;=50)) &#123;cnt++;&#125;</div><div class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃6：循环移动"><a href="#编程题＃6：循环移动" class="headerlink" title="编程题＃6：循环移动"></a>编程题＃6：循环移动</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>给定一组整数，要求利用数组把这组数保存起来，再利用指针实现对数组中的数循环移动。假定共有n个整数，则要使前面各数顺序向后移m个位置，并使最后m各数变为最前面的m各数。</p>
<p>注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也不要用两个数组的方式实现。</p>
<p>要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">11 4</div><div class="line">15 3 76 67 84 87 13 67 45 34 45</div></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">67 45 34 45 15 3 76 67 84 87 13</div></pre></td></tr></table></figure>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 10:41:45</div><div class="line"> * File Name: 9-6.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    int a[500];</div><div class="line">    for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">    for (int k=0;k&lt;m;k++)&#123;</div><div class="line">        int t=a[n-1];</div><div class="line">        for (int i=n-1;i&gt;0;i--) a[i]=a[i-1];</div><div class="line">        a[0]=t;</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">    cout&lt;&lt;a[n-1]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃7：中位数"><a href="#编程题＃7：中位数" class="headerlink" title="编程题＃7：中位数"></a>编程题＃7：中位数</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数或最中间两个数据的平均值（如果这组数的个数为奇数，则中位数为位于中间位置的那个数；如果这组数的个数为偶数，则中位数是位于中间位置的两个数的平均值）.</p>
<p>给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1 &lt;= N &lt;= 15000.</p>
<p>接着N行为N个数据的输入，N=0时结束输入</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出中位数，每一组测试数据输出一行</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">30</div><div class="line">20</div><div class="line">40</div><div class="line">3</div><div class="line">40</div><div class="line">30</div><div class="line">50</div><div class="line">4</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">0</div></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">25</div><div class="line">40</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:16:29</div><div class="line"> * File Name: 9-7.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while(cin&gt;&gt;n&amp;&amp;n)&#123;</div><div class="line">        int a[n];</div><div class="line">        for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">        sort(a,a+n);</div><div class="line">        if (n%2) cout&lt;&lt;a[n/2]&lt;&lt;endl;</div><div class="line">        else cout&lt;&lt;(a[n/2-1]+a[n/2])/2&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃8：校门外的树"><a href="#编程题＃8：校门外的树" class="headerlink" title="编程题＃8：校门外的树"></a>编程题＃8：校门外的树</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。</p>
<p>马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">500 3</div><div class="line">150 300</div><div class="line">100 200</div><div class="line">470 471</div></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">298</div></pre></td></tr></table></figure>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:25:51</div><div class="line"> * File Name: 9-8.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[10002];</div><div class="line">    int n,m,l;</div><div class="line">    int x,y;</div><div class="line">    memset(a,0,sizeof(a));</div><div class="line">    cin&gt;&gt;l&gt;&gt;m;</div><div class="line">    for (int i=0;i&lt;m;i++)&#123;</div><div class="line">        cin&gt;&gt;x&gt;&gt;y;</div><div class="line">        for(int j=x;j&lt;=y;j++)</div><div class="line">            a[j]=1;</div><div class="line">    &#125;</div><div class="line">    int ans=0;</div><div class="line">    for (int i=0;i&lt;=l;i++)</div><div class="line">        if (a[i]==0) ans++;</div><div class="line">    //if (ans) ans+=1;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Coursera_程序设计与算法_计算导论与C语言基础_数组应用练习]]></title>
      <url>http://blog.acbingo.cn/2015/08/10/Coursera_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95_%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="编程题＃1：求字母的个数"><a href="#编程题＃1：求字母的个数" class="headerlink" title="编程题＃1：求字母的个数"></a>编程题＃1：求字母的个数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在一个字符串中找出元音字母a,e,i,o,u出现的次数。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入一行字符串（字符串中可能有空格，请用gets(s)方法把一行字符串输入到字符数组s中），字符串长度小于80个字符。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一行，依次输出a,e,i,o,u在输入字符串中出现的次数，整数之间用空格分隔。</p>
<p>##样例输入<br>If so, you already have a Google Account. You can sign in on the right.</p>
<p>##样例输出<br>5 4 3 7 3<br><a id="more"></a></p>
<p>##代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    getline(cin,s);</div><div class="line">    int len=s.size();</div><div class="line">    int a=0,b=0,c=0,d=0,e=0;</div><div class="line">    for (int i=0;i&lt;len;i++)&#123;</div><div class="line">        if (s[i]==&apos;a&apos;) a++;</div><div class="line">        if (s[i]==&apos;e&apos;) b++;</div><div class="line">        if (s[i]==&apos;i&apos;) c++;</div><div class="line">        if (s[i]==&apos;o&apos;) d++;</div><div class="line">        if (s[i]==&apos;u&apos;) e++;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编程题＃2：忽略大小写比较字符串大小"><a href="#编程题＃2：忽略大小写比较字符串大小" class="headerlink" title="编程题＃2：忽略大小写比较字符串大小"></a>编程题＃2：忽略大小写比较字符串大小</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到’\0’为止。如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准。但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如”Hello”和”hello”在忽略字母大小写时是相等的。请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入为两行，每行一个字符串，共两个字符串。（请用gets录入每行字符串）（每个字符串长度都小于80）</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>如果第一个字符串比第二个字符串小，输出一个字符”&lt;”</p>
<p>如果第一个字符串比第二个字符串大，输出一个字符”&gt;”</p>
<p>如果两个字符串相等，输出一个字符”=”</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello</div><div class="line">hello</div></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s1,s2;</div><div class="line">    cin&gt;&gt;s1&gt;&gt;s2;</div><div class="line">    for (int i=0;i&lt;s1.size();i++)</div><div class="line">        s1[i]=toupper(s1[i]);</div><div class="line">    for (int i=0;i&lt;s2.size();i++)</div><div class="line">        s2[i]=toupper(s2[i]);</div><div class="line">    if (s1&lt;s2) cout&lt;&lt;&quot;&lt;&quot;;</div><div class="line">    else if (s1&gt;s2) cout&lt;&lt;&quot;&gt;&quot;;</div><div class="line">    else cout&lt;&lt;&quot;=&quot;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃3：最长单词2"><a href="#编程题＃3：最长单词2" class="headerlink" title="编程题＃3：最长单词2"></a>编程题＃3：最长单词2</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>一个以’.’结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一个以’.’结尾的简单英文句子（长度不超过500），单词之间用空格分隔，没有缩写形式和其它特殊形式</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>该句子中最长的单词。如果多于一个，则输出第一个</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>I am a student of Peking University.</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>University</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    char t[600];</div><div class="line">    gets(t);</div><div class="line">    s=t;</div><div class="line">    s[s.size()-1]=&apos; &apos;;</div><div class="line">    //puts(t);</div><div class="line">    stringstream ss(s);</div><div class="line">    string ans;</div><div class="line">    int len=0;</div><div class="line">    while (ss&gt;&gt;s) if (s.size()&gt;len) &#123;len=s.size();ans=s;&#125;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃4：矩阵交换行"><a href="#编程题＃4：矩阵交换行" class="headerlink" title="编程题＃4：矩阵交换行"></a>编程题＃4：矩阵交换行</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>编写一个函数，输入参数是5*5的二维数组，和n，m两个行下标。功能：判断n，m是否在数组范围内，如果不在，则返回0；如果在范围内，则将n行和m行交换，并返回1。</p>
<p>在main函数中， 生成一个5*5的矩阵，输入矩阵数据，并输入n，m的值。调用前面的函数。如果返回值为0，输出error。如果返回值为1，输出交换n，m后的新矩阵。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>5*5矩阵的数据，以及n和m的值。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>如果不可交换，则输出error；</p>
<p>如果可交换，则输出新矩阵</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 2 1 2</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">3 0 8 2 4</div><div class="line">0 4</div></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">3 0 8 2 4</div><div class="line">5 6 7 8 3</div><div class="line">9 3 0 5 3</div><div class="line">7 2 1 4 6</div><div class="line">1 2 2 1 2</div></pre></td></tr></table></figure>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/6 19:33:47</div><div class="line"> * File Name: 9-4.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">#include &lt;iomanip&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[5][5];</div><div class="line">    for (int i=0;i&lt;5;i++)</div><div class="line">        for (int j=0;j&lt;5;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    if (n&lt;0||n&gt;4||m&lt;0||m&gt;4) cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;</div><div class="line">    else &#123;</div><div class="line">        for (int i=0;i&lt;5;i++)&#123;</div><div class="line">            if (i==n)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[m][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[m][4]&lt;&lt;endl;</div><div class="line">            &#125;else if (i==m)&#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[n][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[n][4]&lt;&lt;endl;</div><div class="line">            &#125;else &#123;</div><div class="line">                for(int j=0;j&lt;4;j++) cout&lt;&lt; setw(4)&lt;&lt;a[i][j];</div><div class="line">                cout&lt;&lt; setw(4)&lt;&lt;a[i][4]&lt;&lt;endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃5：异常细胞检测"><a href="#编程题＃5：异常细胞检测" class="headerlink" title="编程题＃5：异常细胞检测"></a>编程题＃5：异常细胞检测</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>我们拍摄的一张CT照片用一个二维数组来存储，假设数组中的每个点代表一个细胞。每个细胞的颜色用0到255之间（包括0和255）的一个整数表示。我们定义一个细胞是异常细胞，如果这个细胞的颜色值比它上下左右4个细胞的颜色值都小50以上（包括50）。数组边缘上的细胞我们不检测。现在我们的任务是，给定一个存储CT照片的二维数组，写程序统计照片中异常细胞的数目。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数N（100&gt;=N&gt;2）.</p>
<p>下面有 N 行，每行有 N 个0~255之间的整数，整数之间用空格隔开。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出只有一行，包含一个整数，为异常细胞的数目。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line">70 70 70 70</div><div class="line">70 10 70 70</div><div class="line">70 70 20 70</div><div class="line">70 70 70 70</div></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    int a[150][150];</div><div class="line">    cin&gt;&gt;n;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        for (int j=0;j&lt;n;j++)</div><div class="line">            cin&gt;&gt;a[i][j];</div><div class="line">    int cnt=0;</div><div class="line">    for (int i=1;i&lt;n-1;i++)</div><div class="line">        for (int j=1;j&lt;n-1;j++)</div><div class="line">            if ((a[i-1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i+1][j]-a[i][j]&gt;=50)&amp;&amp;(a[i][j-1]-a[i][j]&gt;=50)&amp;&amp;(a[i][j+1]-a[i][j]&gt;=50)) &#123;cnt++;&#125;</div><div class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃6：循环移动"><a href="#编程题＃6：循环移动" class="headerlink" title="编程题＃6：循环移动"></a>编程题＃6：循环移动</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>给定一组整数，要求利用数组把这组数保存起来，再利用指针实现对数组中的数循环移动。假定共有n个整数，则要使前面各数顺序向后移m个位置，并使最后m各数变为最前面的m各数。</p>
<p>注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也不要用两个数组的方式实现。</p>
<p>要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">11 4</div><div class="line">15 3 76 67 84 87 13 67 45 34 45</div></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">67 45 34 45 15 3 76 67 84 87 13</div></pre></td></tr></table></figure>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 10:41:45</div><div class="line"> * File Name: 9-6.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n,m;</div><div class="line">    cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    int a[500];</div><div class="line">    for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">    for (int k=0;k&lt;m;k++)&#123;</div><div class="line">        int t=a[n-1];</div><div class="line">        for (int i=n-1;i&gt;0;i--) a[i]=a[i-1];</div><div class="line">        a[0]=t;</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">    cout&lt;&lt;a[n-1]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃7：中位数"><a href="#编程题＃7：中位数" class="headerlink" title="编程题＃7：中位数"></a>编程题＃7：中位数</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>中位数定义：一组数据按从小到大的顺序依次排列，处在中间位置的一个数或最中间两个数据的平均值（如果这组数的个数为奇数，则中位数为位于中间位置的那个数；如果这组数的个数为偶数，则中位数是位于中间位置的两个数的平均值）.</p>
<p>给出一组无序整数，求出中位数，如果求最中间两个数的平均数，向下取整即可（不需要使用浮点数）</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>该程序包含多组测试数据，每一组测试数据的第一行为N，代表该组测试数据包含的数据个数，1 &lt;= N &lt;= 15000.</p>
<p>接着N行为N个数据的输入，N=0时结束输入</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出中位数，每一组测试数据输出一行</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">30</div><div class="line">20</div><div class="line">40</div><div class="line">3</div><div class="line">40</div><div class="line">30</div><div class="line">50</div><div class="line">4</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">0</div></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">25</div><div class="line">40</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:16:29</div><div class="line"> * File Name: 9-7.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int n;</div><div class="line">    while(cin&gt;&gt;n&amp;&amp;n)&#123;</div><div class="line">        int a[n];</div><div class="line">        for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</div><div class="line">        sort(a,a+n);</div><div class="line">        if (n%2) cout&lt;&lt;a[n/2]&lt;&lt;endl;</div><div class="line">        else cout&lt;&lt;(a[n/2-1]+a[n/2])/2&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编程题＃8：校门外的树"><a href="#编程题＃8：校门外的树" class="headerlink" title="编程题＃8：校门外的树"></a>编程题＃8：校门外的树</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。</p>
<p>马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">500 3</div><div class="line">150 300</div><div class="line">100 200</div><div class="line">470 471</div></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">298</div></pre></td></tr></table></figure>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Author:  Bingo</div><div class="line"> * Created Time:  2015/8/7 11:25:51</div><div class="line"> * File Name: 9-8.cpp</div><div class="line"> */</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;time.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxint = -1u&gt;&gt;1;</div><div class="line">int main () &#123;</div><div class="line">    int a[10002];</div><div class="line">    int n,m,l;</div><div class="line">    int x,y;</div><div class="line">    memset(a,0,sizeof(a));</div><div class="line">    cin&gt;&gt;l&gt;&gt;m;</div><div class="line">    for (int i=0;i&lt;m;i++)&#123;</div><div class="line">        cin&gt;&gt;x&gt;&gt;y;</div><div class="line">        for(int j=x;j&lt;=y;j++)</div><div class="line">            a[j]=1;</div><div class="line">    &#125;</div><div class="line">    int ans=0;</div><div class="line">    for (int i=0;i&lt;=l;i++)</div><div class="line">        if (a[i]==0) ans++;</div><div class="line">    //if (ans) ans+=1;</div><div class="line">    cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hdu4821 String]]></title>
      <url>http://blog.acbingo.cn/2015/08/10/hdu4821%20String/</url>
      <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一个字符串S  问其中有几个子串能满足以下条件：<br>1、长度为m*l<br>2、可以被分成m个l长的不同的子串<br>问题就变成了如何快速的判断着m个子串是否存在相同的</p>
<h1 id="思路与分析"><a href="#思路与分析" class="headerlink" title="思路与分析"></a>思路与分析</h1><p>这题我做了两天，用了四种不同的方法，从TL到WA再到AC。。。一路坎坷。<br>不过收获了很多东西，这题价值很大，堪称经典。<br>运用滑动窗口的思想，长度为m*l的为大窗，将其划分为m个长度为l的小窗。<br>枚举大窗的起点，以l为单位滑动大窗<br>直接将所有的子串存储起来会MLE，所以想到hash<br>将总串s hash，然后想办法快速的取出hash[s[i]~s[j]]<br>最终算法如下:</p>
<ol>
<li>大窗起点</li>
<li>计算当前大窗口下m个小窗的hash值，扔到map里</li>
<li>对map里的元素个数进行统计，若为m，ans++</li>
<li><strong>以l为单位滑动大窗</strong>，每滑动一次，map减掉一个出窗口的l串，加上一个刚刚进窗口的l串，若此时map.size()==m，ans++</li>
<li>大窗起点+1，返回1<h2 id="如何快速计算hash-s-i-s-j"><a href="#如何快速计算hash-s-i-s-j" class="headerlink" title="如何快速计算hash[s[i]~s[j]]"></a>如何快速计算hash[s[i]~s[j]]</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3>这里给出某大神的方法:</li>
<li>base为基数，从S最后一个字符开始,hash[i]=hash[i+1]*base+str[i]-‘a’+1，即将i位以后的串hash成一个unsigned long long</li>
<li>hash[s[i]~s[j]]的值即为: hash[i]-hash[j+1]*nbase[len].nbase[i]表示base的i次方<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct HashTab&#123;</div><div class="line">    ULL Has[1000005];</div><div class="line">    ULL base=31;</div><div class="line">    ULL nbase[1000005];</div><div class="line">    void init(char *s)&#123;</div><div class="line">        int len=strlen(s);</div><div class="line">        for (int i=len-1;i&gt;=0;i--) &#123;</div><div class="line">            Has[i]=Has[i+1]*base+s[i]-&apos;a&apos;+1;</div><div class="line">        &#125;</div><div class="line">        nbase[0]=1;</div><div class="line">        for (int i=1;i&lt;=len;i++)</div><div class="line">            nbase[i]=nbase[i-1]*base;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ULL getHash(LL l,LL r)&#123;//hashtab.getHash(l,r)表示返回s[l~r]的hash值</div><div class="line">        int len=r-l+1;</div><div class="line">        return Has[l]-Has[l+len]*nbase[len];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>没看懂，直接给出函数吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct Hash&#123;</div><div class="line">    LL B,mod,len,Has[1000005],Base[1000005];</div><div class="line">    void init(char *s,LL _B,LL _mod)&#123;</div><div class="line">        len=strlen(s);</div><div class="line">        B=_B; mod=_mod;</div><div class="line">        Base[0]=1; Has[0]=0;</div><div class="line">        for (LL i=1;i&lt;=len;i++)&#123;</div><div class="line">            Base[i]=Base[i-1]*B%mod;</div><div class="line">            Has[i]=(Has[i-1]*B+s[i-1]-&apos;a&apos;+1)%mod;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LL getHash(LL l,LL r)&#123;//hashtab.getHash(l,r)表示返回s[l~r]的hash值</div><div class="line">        l++;r++;</div><div class="line">        return ((Has[r]-Has[l-1]*Base[r-l+1])%mod+mod)%mod;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="主代码"><a href="#主代码" class="headerlink" title="主代码"></a>主代码</h1><p>写的时候要注意下表是否正确哇，边界处到底有没有=号等等。。不然debug的时候是真头疼</p>
<h2 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#define ULL unsigned long long</div><div class="line">#define LL long long</div><div class="line">using namespace std;</div><div class="line">map &lt;ULL,int&gt; mp;</div><div class="line">struct HashTab&#123;</div><div class="line">    ULL Has[1000005];</div><div class="line">    ULL base=31;</div><div class="line">    ULL nbase[1000005];</div><div class="line">    void init(char *s)&#123;</div><div class="line">        int len=strlen(s);</div><div class="line">        for (int i=len-1;i&gt;=0;i--) &#123;</div><div class="line">            Has[i]=Has[i+1]*base+s[i]-&apos;a&apos;+1;</div><div class="line">        &#125;</div><div class="line">        nbase[0]=1;</div><div class="line">        for (int i=1;i&lt;=len;i++)</div><div class="line">            nbase[i]=nbase[i-1]*base;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ULL getHash(LL l,LL r)&#123;</div><div class="line">        int len=r-l+1;</div><div class="line">        return Has[l]-Has[l+len]*nbase[len];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">HashTab _hash;</div><div class="line">int main () &#123;</div><div class="line">    int m,l;</div><div class="line">    char s[100010];</div><div class="line">    while (scanf(&quot;%d%d&quot;,&amp;m,&amp;l)!=EOF)&#123;</div><div class="line">        scanf(&quot;%s&quot;,s);</div><div class="line">        _hash.init(s);</div><div class="line">        int len=strlen(s);</div><div class="line">        int ans=0;</div><div class="line">        for (int i=0;i&lt;l&amp;&amp;i+m*l-1&lt;len;i++)&#123;</div><div class="line">            mp.clear();</div><div class="line">            for (int j=i;j&lt;i+m*l;j+=l)&#123;//计算小窗</div><div class="line">                int tmp=_hash.getHash(j,j+l-1);</div><div class="line">                //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]++;</div><div class="line">            &#125;</div><div class="line">            if (mp.size()==m) ans++;</div><div class="line">            for (int j=i+m*l;j+l&lt;=len;j+=l)&#123;//以l为单位滑动大窗口</div><div class="line">                int tmp=_hash.getHash(j-m*l,j-(m-1)*l-1);</div><div class="line">                //cout&lt;&lt;&quot;-&quot;&lt;&lt;j-m*l&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]--;</div><div class="line">                if (mp[tmp]==0) mp.erase(tmp);</div><div class="line">                tmp=_hash.getHash(j,j+l-1);</div><div class="line">                //cout&lt;&lt;&quot;+&quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]++;</div><div class="line">                if (mp.size()==m) ans++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#define MOD 1000000007</div><div class="line">#define LL long long</div><div class="line">using namespace std;</div><div class="line">map &lt;long long,int&gt; mp;</div><div class="line">struct Hash&#123;</div><div class="line">    LL B,mod,len,Has[1000005],Base[1000005];</div><div class="line">    void init(char *s,LL _B,LL _mod)&#123;</div><div class="line">        len=strlen(s);</div><div class="line">        B=_B; mod=_mod;</div><div class="line">        Base[0]=1; Has[0]=0;</div><div class="line">        for (LL i=1;i&lt;=len;i++)&#123;</div><div class="line">            Base[i]=Base[i-1]*B%mod;</div><div class="line">            Has[i]=(Has[i-1]*B+s[i-1]-&apos;a&apos;+1)%mod;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    LL getHash(LL l,LL r)&#123;</div><div class="line">        l++;r++;</div><div class="line">        return ((Has[r]-Has[l-1]*Base[r-l+1])%mod+mod)%mod;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Hash _hash;</div><div class="line">int main () &#123;</div><div class="line">    int m,l;</div><div class="line">    char s[100010];</div><div class="line">    while (scanf(&quot;%d%d&quot;,&amp;m,&amp;l)!=EOF)&#123;</div><div class="line">        scanf(&quot;%s&quot;,s);</div><div class="line">        _hash.init(s,131,MOD);</div><div class="line">        int len=strlen(s);</div><div class="line">        int ans=0;</div><div class="line">        for (int i=0;i&lt;l&amp;&amp;i+m*l-1&lt;len;i++)&#123;</div><div class="line">            mp.clear();</div><div class="line">            for (int j=i;j&lt;i+m*l;j+=l)&#123;//计算小窗</div><div class="line">                int tmp=_hash.getHash(j,j+l-1);</div><div class="line">                //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]++;</div><div class="line">            &#125;</div><div class="line">            if (mp.size()==m) ans++;</div><div class="line">            for (int j=i+m*l;j+l&lt;=len;j+=l)&#123;//以l为单位滑动大窗口</div><div class="line">                int tmp=_hash.getHash(j-m*l,j-(m-1)*l-1);</div><div class="line">                //cout&lt;&lt;&quot;-&quot;&lt;&lt;j-m*l&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]--;</div><div class="line">                if (mp[tmp]==0) mp.erase(tmp);</div><div class="line">                tmp=_hash.getHash(j,j+l-1);</div><div class="line">                //cout&lt;&lt;&quot;+&quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</div><div class="line">                mp[tmp]++;</div><div class="line">                if (mp.size()==m) ans++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>高神 <a href="http://www.acmtime.com/?p=579" target="_blank" rel="external">http://www.acmtime.com/?p=579</a></li>
<li><a href="http://blog.csdn.net/houserabbit/article/details/25740235" target="_blank" rel="external">http://blog.csdn.net/houserabbit/article/details/25740235</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Rolling Hash(Rabin-Karp算法)匹配字符串]]></title>
      <url>http://blog.acbingo.cn/2015/08/09/Rolling%20Hash(Rabin-Karp%E7%AE%97%E6%B3%95)%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="该算法常用的场景"><a href="#该算法常用的场景" class="headerlink" title="该算法常用的场景"></a>该算法常用的场景</h1><p>字符串中查找子串，字符串中查找anagram形式的子串问题。</p>
<h1 id="关于字符串查找与匹配"><a href="#关于字符串查找与匹配" class="headerlink" title="关于字符串查找与匹配"></a>关于字符串查找与匹配</h1><p>字符串可以理解为字符数组。而字符可以被转换为整数，他们具体的值依赖于他们的编码方式(ASCII/Unicode)。这意味着我们可以把字符串当成一个整形数组。找到一种方式将一组整形数字转化为一个数字，就能够使得我们借助一个预期的输入值来Hash字符串。<br>既然字符串被看成是数组而不是单个元素，比较两个字符串是否想到就没有比较两个数值来得简单直接。去检查A和B是否相等，我们不得不通过枚举所有的A和B的元素来确定对于所有的i来讲A[i]=B[i]。这意味着字符串比较的复杂度依赖于字符串的长度。比较两个长度为n的字符串，需要的复杂度为O(n)。另外，去hash一个字符串是通过枚举整个字符串的元素，所以hash一个长度为n的字符串也需要O(n)的时间复杂度。</p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><ol>
<li>hash P 得到 h(p) 。时间复杂度：O(L)</li>
<li>从S的索引为0开始来枚举S里长度为L的子串，hash子串并计算出h(P)’。时间复杂度为O(nL)。</li>
<li>如果一个子串的hash值与h(P)匹配，将该子串与P进行比较，如果不匹配则停止，如果匹配则继续进行步骤2。时间复杂度：O(L)</li>
</ol>
<p>这个做法的时间复杂度为O(nL)。我们可以通过使用rollinghash来优化这种做法。在步骤2中，我们看到对于O(n)的子串，都花费了O(L)来hash他们(你可以想象成，找了一个长度为L的框，框住了S，每迭代一次向前移动一位，所以会移动n次，而对于每次每个框中的子串都需要迭代这个子串来算哈希值，所以复杂度为nL)。然而你可以看到这些子串中很多字符都是重复的。比如，看一个字符串“algorithms”中长度为5的子串，最开始的两个子串长度为“algor”和“lgori”。如果我们能利用这两个子串又有共同的子串“lgor”这个事实，将会为我们省去很多时间来处理每一个字符串。看起来我们应该使用rollinghash。</p>
<h1 id="“数值”示例"><a href="#“数值”示例" class="headerlink" title="“数值”示例"></a>“数值”示例</h1><p>让我们回到字符串上去，假如我们有P和S都被转化为了两个整形数组：<br>P=[9,0,2,1,0]             (1)<br>S=[4,8,9,0,2,1,0,7]       (2)<br>长度为5的S的子串被列举在下面：<br>S0=[4,8,9,0,2]            (3)<br>S1=[8,9,0,2,1]            (4)<br>S2=[9,0,2,1,0]            (5)<br>…                       (6)<br>我们想知道P是否能与S的某个子串匹配，可以使用上面的“做法”中的三个步骤。我们的Hash函数可以是：<br><img src="http://img.blog.csdn.net/20130511180045224" alt=""><br>或者换句话说，我们将长度为5的整形数组中的每个数值都映射到一个5位数的每一位上，然后用这个数值跟m做“mod”运算。h(P)=90210mod m，h(S0)=48902mod m，以及h(S1)=98021mod m。注意这个哈希函数，我们可以是用h(S0)来帮助计算h(S1)。我们从48902开始，去除第一位得到8902，乘以10得到89020，然后加上下一位数值得到：89021.更通用的公式是：<br><img src="http://img.blog.csdn.net/20130511180144588" alt=""><br>我们可以想象为这是在所有的S的子串上一个滑动的窗口。计算下一个子串的hash值其是值关系到两个元素，这两个元素正好是在这个滑动窗口的两端（一个进来一个出去）。这里与上面有很大的不同，这里我们除了第一次去计算长度为L的第一个子串之后，我们将不在依赖这长度为L的元素集合了，我们只依赖两个元素，这使得计算子串hash值的复杂度变成了O(1)的操作。<br>在这个数值的示例中，我们看到了简单的按位存放整数，并且设置了“底”为10，因此我们可以很轻易得分离出其中的每个数字。为了通用话，我们可以采用如下通用公式：<br><img src="http://img.blog.csdn.net/20130511180251868" alt=""><br>并且计算下一个子串的hash值就是：<br><img src="http://img.blog.csdn.net/20130511180337601" alt=""></p>
<p>感觉他解释的不是很清楚。<br>这里给出个我自己的理解，当n=5,b=10<br>h(Si+1)=(h(Si)mod(b^n)*b+S[i+L])mod m</p>
<p>而另一位大神是这样描述的:<br>Rabin-Karp算法的关键思想是 某一子串的hash值可以根据上一子串的hash在常数时间内计算出来，这样比对的时间复杂度可以降为O(n-k)。Rabin-Karp对字符串的hash算法和上面描述的一样（按整数进制解析再求模），假设原字符串为s，H(i)表示第i个字符开始的k个子字符串的hash值，即<br><img src="http://novoland.github.io/assets/img/003b4350a20067d079bb28c8c9914144" alt="">,（先不考虑%M），则<img src="http://novoland.github.io/assets/img/e322e54447ec197701f436a06970c810" alt="">，时间为常数。<br>又由%的性质可得:<br><img src="http://novoland.github.io/assets/img/b40a2119eeed66cef42c50ca3e85b2f4" alt=""><br><img src="http://novoland.github.io/assets/img/c9ff600fb7cc33cc140d973b7b885a86" alt=""><br><img src="http://novoland.github.io/assets/img/a517aef96ad9117c5a3e1bdda6ffe39c" alt=""><br>即 i+1 处子串的 hash 可以由 i 处子串的 hash 直接计算而得，在中间结果 %M 主要是为了防止溢出。<br>M 一般选取一个非常大的数字，子串的数目相对而言非常少，产生散列碰撞的概率为 1/M，可以忽略不计。<br>代码实现如下，这里当hash一致时没有再回退检查。可以看到 Rabin-Karp 的瓶颈在于每个内循环都进行了乘和模运算，模运算是比较耗时的，而其他算法大部分只需要进行字符比对.</p>
<h1 id="回到字符串的问题上"><a href="#回到字符串的问题上" class="headerlink" title="回到字符串的问题上"></a>回到字符串的问题上</h1><p>既然字符串可以被转换为数字，我们可以在字符串上也像跟数值的示例一样用同样的方法来提高运行效率。算法实现如下：</p>
<ol>
<li>Hash P 得到h(P) 时间复杂度为O(L)</li>
<li>Hash S中长度为L的第一个子串 时间复杂度为O(L)</li>
<li>使用rolling hash 方法来计算S 所有的子串 O(n)，并以计算出的hash值与h(P)进行比较 时间复杂度为O(n)</li>
<li>如果一个子串的hash值与h(p)相等，那么将该子串与P进行比较，如果匹配则继续，否则则中断当前匹配 时间复杂度为O(L)</li>
</ol>
<p>这加快了整个算法的效率，只要所有做比较的总时间为O(n)，那么整个算法的时间复杂度为O(n)。我们进入一个问题，如果我们在我们的hashtable中假设产生了O(n)次“哈希碰撞”（指由于哈希函数的问题，导致多个key对应到同一个值），那么步骤4的总复杂度就为O(nL)。因此我们不得不确保我们的hashtable的大小为n（也就是必须保证每个子串都能唯一对应一个哈希key，这取决于hash函数的设计），这样我们就可以期待子串可以被一次命中，所以我们只需要走步骤4O(1)次。而我们步骤4的时间复杂度为O(L)，在这种情况下，我们仍然可以保证整个问题的时间复杂度为O(n)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line">void Rabin_Karp(string p,string s,int b,int m)&#123;</div><div class="line">    int hash_p=0;//目标串的hash值</div><div class="line">    int hash_i=0;//当前串的hash值</div><div class="line">    int h=1;</div><div class="line">    for (int i=0;i&lt;p.size();i++)&#123;//h==pow(b,p.size());</div><div class="line">        h=(h*b)%m;</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;p.size();i++)&#123;</div><div class="line">        hash_p=(b*hash_p+p[i])%m;</div><div class="line">        hash_i=(b*hash_i+s[i])%m;</div><div class="line">    &#125;</div><div class="line">    for (int i=0;i&lt;=s.size()-p.size();i++)&#123;</div><div class="line">        if (hash_i==hash_p)&#123;</div><div class="line">            int j;</div><div class="line">            for (j=0;j&lt;p.size();j++)&#123;</div><div class="line">                if (s[i+j]!=p[j]) break;</div><div class="line">            &#125;</div><div class="line">            if (j==p.size()) cout&lt;&lt;&quot;yes &quot;&lt;&lt;i&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">        if (i&lt;s.size()-p.size())&#123;</div><div class="line">            hash_i=(hash_i%m*b+s[i+p.size()]+m-s[i]*h%m)%m;//算出下一个hash值</div><div class="line">            if (hash_i&lt;0) hash_i=hash_i+m;//其实这一步在该程序下是没有实际意义的。主要是提醒自己以后涉及到取余问题的时候可能会发生取到负数及0</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    string p,s;</div><div class="line">    p=&quot;Rabin&quot;;</div><div class="line">    s=&quot;Rabin–Karp string search algorithm: Rabin-Karp&quot;;</div><div class="line">    int m=101;//素数</div><div class="line">    int base=26;//基数,这里取26好了</div><div class="line">    Rabin_Karp(p,s,base,m);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="自身匹配问题"><a href="#自身匹配问题" class="headerlink" title="自身匹配问题"></a>自身匹配问题</h1><p>给定一个长度为n的串s，求其子串中是否存在相同的且长度都为l的串，若存在，输出其出现次数以及出现位置。<br>注意此处要求子串长度是一定的，数据小的话暴力就可以搞。</p>
<ol>
<li>hash S的第一个长度为L的子串 时间复杂度为：O(L),放入map表</li>
<li>使用rolling hash 来计算S的所有O(n)个子串,每算出一个然后和map表进行比对，并更新map表，时间为O(nlogn)<br>注意可能会发生“哈希碰撞”。总的来说，m值的大小决定了map表的大小，而map表的大小又决定了哈希碰撞的概率。若是发生了碰撞，个人认为采用缓存区法或者再哈希都比较容易实现。</li>
</ol>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码只实现了判断是否存在相同的子串，╮(╯-╰)╭，没办法，lpl马上开赛了，得赶紧干完呢~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">using namespace std;</div><div class="line">struct Node&#123;</div><div class="line">    int index;</div><div class="line">    int num;</div><div class="line">&#125;;</div><div class="line">map&lt;int,Node&gt; mymap;</div><div class="line">void Rabin_Karp_Self(string s,int l,int b,int m)</div><div class="line">&#123;</div><div class="line">    int h=0;//注意初始化</div><div class="line">    int t=1;</div><div class="line">    for (int i=0;i&lt;l;i++) t=(t*b)%m;</div><div class="line">    for (int i=0;i&lt;l;i++)&#123;//计算第一个窗口的hash值</div><div class="line">        h=((b*h)+s[i])%m;</div><div class="line">    &#125;</div><div class="line">    mymap[h].index=0;mymap[h].num++;</div><div class="line">    for (int i=1;i&lt;=s.size()-l;i++)&#123;</div><div class="line">        //算初当前的hash</div><div class="line">        h=(h%m*b+s[i-1+l]+m-s[i-1]*t%m)%m;//滑动窗口，计算下一个hash值</div><div class="line">        //h=((h*b-s[i-1]*t)+s[i+l-1])%m; </div><div class="line">        //if (h&lt;0) h+=m;  //这里同上题</div><div class="line">        if (mymap.count(h))&#123;</div><div class="line">            int j;</div><div class="line">            for (j=0;j&lt;l;j++) &#123;</div><div class="line">                if (s[j+mymap[h].index]!=s[i+j]) break;</div><div class="line">            &#125;</div><div class="line">            if (j==l) cout&lt;&lt;&quot;yes &quot;&lt;&lt;mymap[h].index&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</div><div class="line">        &#125;else &#123;</div><div class="line">            mymap[h].index=i;mymap[h].index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    string s;</div><div class="line">    int n;</div><div class="line">    s=&quot;Rabin–Karp string search algorithm: Rabin-Karp&quot;;</div><div class="line">    //s=&quot;abcabc&quot;;</div><div class="line">    n=5;</div><div class="line">    int b;int m;</div><div class="line">    b=10;m=10001;</div><div class="line">    Rabin_Karp_Self(s,n,b,m);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若想输出次数和位置，也很简单，node增加一个数组，然后修改下cout那就行了。另外注意哈希碰撞的处理。</p>
<h2 id="不定长的子串"><a href="#不定长的子串" class="headerlink" title="不定长的子串"></a>不定长的子串</h2><p>TODO<br>等对字符串匹配问题的各种算法理解都十分透彻后，再回头考虑这个问题<br>个人认为求不定长子串匹配问题该算法不仅麻烦，时间也算不上最快的。</p>
<h1 id="共同子串问题"><a href="#共同子串问题" class="headerlink" title="共同子串问题"></a>共同子串问题</h1><p>刚才的算法被设计成：在一个字符串S中查找一个模式串P的匹配。然而，现在我们需要处理另一个问题：看看两个长度为n的长字符串S和T，看他们是否拥有长度为L的共同子串。这看起来是一个更难处理的问题，但我们还是能有采用rollinghash使得其复杂度为O(n)。我们采用一个相似的策略：</p>
<ol>
<li>hash S的第一个长度为L的子串 时间复杂度为：O(L)</li>
<li>使用rolling hash 来计算S的所有O(n)个子串，然后把每个子串加入一个hash table中 时间复杂度为：O(n)</li>
<li>hash T的第一个长度为L的子串 时间复杂度为：O(L)</li>
<li>使用rolling hash方法来计算T的所有O(n)个子串，对每个子串，检查hashtable看是否能命中。</li>
<li>如果T的一个子串命中了S的一个子串，那么就进行匹配，如果相等则继续，否则停止匹配。时间复杂度为：O(L)</li>
</ol>
<p>然而，保持运行的次数为O(n)，我们又再次需要注意限制“哈希碰撞”的次数，以减少我们进入步骤5来进行不必要的匹配。这次，如果我们的hashtable的大小为O(n)，那么我们对于T的每个子串所期待的命中复杂度为O(1)(最坏的情况)。这样的结果会导致字符串进行O(n)次比较，总共的复杂度为O(nL)次，这使得字符串的比较在这里成为了瓶颈。我们可以扩大hashtable的大小，同时修改我们的hash函数使得我们的hashtable有O(n的平方)个槽（槽指hash表中真正用于存储数据的单元），来使得对于每个T的子串来讲，可能的碰撞降低到O(1/n)。这可以解决我们的问题，并且使得整个问题的复杂度仍然为O(n)，但我们可能没有必要像这样来创建这么大的hashtable消耗不必要的资源。<br>取而代之的是，我们将利用字符串签名的优势来替代消耗更多存储资源的做法，我们将再为每个子串分配一个hash值，称之为h(k)’。注意，这个h(k)’的hash 函数最终将字符串映射到0到n的平方的范围而不是上面的0到n。现在当我们在hashtable中产生哈希碰撞时，在我们做最终“昂贵”的字符串比较之前，我们首先可以比较两个字符串的签名，如果签名不匹配，那么我们就可以跳过字符串比较。对于两个子串k1和k2，仅当h(k1)=h(k2)以及h(k1)’=h(k2)’时，我们才会做最终的字符串比较。对于一个好的h(k)’的哈希函数，这将大大减少字符串比对，使得比对的复杂度接近O(n)，将共同子串问题的复杂度限制在O(n)。</p>
<h1 id="二维扩展"><a href="#二维扩展" class="headerlink" title="二维扩展"></a>二维扩展</h1><p><a href="http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&amp;%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html" target="_blank" rel="external">http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&amp;%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html</a><br>参考自:<br><a href="http://blog.csdn.net/yanghua_kobe/article/details/8914970" target="_blank" rel="external">http://blog.csdn.net/yanghua_kobe/article/details/8914970</a><br><a href="http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&amp;%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html" target="_blank" rel="external">http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&amp;%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html</a><br><a href="http://blog.csdn.net/chenhanzhun/article/details/39895077" target="_blank" rel="external">http://blog.csdn.net/chenhanzhun/article/details/39895077</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设置vim的默认工作路径]]></title>
      <url>http://blog.acbingo.cn/2015/08/09/%E8%AE%BE%E7%BD%AEvim%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B7%A5%E4%BD%9C%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>想让vim自动设当前编辑的文件所在目录为当前工作路径不冲突，但是当vim新建文件的时候，工作路径会又自动切换缓存path下。<br>如何使当使用vim打开文件时，vim的工作路径是当前文件所在的路径。而当从vim里新建文件的时候，工作路径是自己预设的路径呢？</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exec &apos;cd &apos; . fnameescape(&apos;f:\code&apos;)  </div><div class="line">set autochdir</div></pre></td></tr></table></figure>
<p>注意，命令的执行顺序不能改变</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[滑动窗口的单调队列]]></title>
      <url>http://blog.acbingo.cn/2015/08/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="滑动窗口的单调队列"><a href="#滑动窗口的单调队列" class="headerlink" title="滑动窗口的单调队列"></a>滑动窗口的单调队列</h1><hr>
<p>今天的训练赛HDU 4122，卡到最后也没出来，结束后和队友冷静分析代码后才发现错在一个简单的错误上，修改后A了</p>
<p>赛后看题解，大家的题解中大都提到了要用单调队列。</p>
<p>去网上搜单调队列。。文章无外乎就两种。。= =  抄袭好严重呀</p>
<p>1.<a href="http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" target="_blank" rel="external">http://zhonghuan.info/2014/09/16/%E6%B5%85%E6%9E%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</a></p>
<p><em>简单的单调队列</em></p>
<p>2.<a href="http://blog.pureisle.net/archives/477.html" target="_blank" rel="external">http://blog.pureisle.net/archives/477.html</a></p>
<p><em>结合了滑动窗口的单调队列</em></p>
<p>而HDU4122这个题明显是用到了第二种</p>
<p>差不多该回寝室了。。。明天上午回来搞~</p>
<p>简单的来说，单调队列的作用：不断地向缓存数组里读入元素，也不时地去掉最老的元素，不定期的询问当前缓存数组里的最小的元素。</p>
<blockquote>
<p>单调队列与队列唯一的不同就在于它不仅要保存元素的值，而且要保存元素的索引（当然在实际应用中我们可以只需要保存索引，而通过索引间接找到当前索引的值）。</p>
<p>为了让读者更明白一点，我举个简单的例子。<br>假设数列为：8，7，12，5，16，9，17，2，4，6.N=10,k=3.<br>要求元素的生存时间不超过k（可以正好为k）<br>那么我们构造一个长度为3的单调递减队列：<br>首先，那8和它的索引0放入队列中，我们用（8，0）表示，每一步插入元素时队列中的元素如下：<br>0：插入8，队列为：（8，0）<br>1：插入7，队列为：（8，0），（7，1）<br>2：插入12，队列为：（12，2）<br>3：插入5，队列为：（12，2），（5，3）<br>4：插入16，队列为：（16，4）<br>5：插入9，队列为：（16，4），（9，5）<br>。。。。依此类推<br>那么f(i)就是第i步时队列当中的首元素：8，8，12，12，16，16，。。。</p>
</blockquote>
<p>为了方便操作，运用pair类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">typedef pair&lt;int,int&gt; Pair;</div><div class="line">Pair f[100];</div><div class="line">int a[100];</div><div class="line">int main () &#123;</div><div class="line">    int n,k;</div><div class="line">    cin&gt;&gt;n&gt;&gt;k;</div><div class="line">    for (int i=0;i&lt;n;i++)</div><div class="line">        cin&gt;&gt;a[i];</div><div class="line">    int tail=0,head=0;</div><div class="line">    Pair t(a[0],0);</div><div class="line">    int i=0;</div><div class="line">    f[i]=t;</div><div class="line">    while (i&lt;n-1)&#123;</div><div class="line">        i++;//新元素入队</div><div class="line">        Pair t(a[i],i);</div><div class="line">        int j;</div><div class="line">        for (j=tail;j&gt;=head;j--)&#123;//维护队尾</div><div class="line">            if (t.first&lt;f[j].first) break;</div><div class="line">        &#125;</div><div class="line">        f[j+1]=t;tail=j+1;</div><div class="line">        </div><div class="line">        while (i-f[head].second&gt;k)&#123;//注意这里，有的题意是不超过k，有的题意是不多于k。</div><div class="line">            head++;</div><div class="line">        &#125;</div><div class="line">        cout&lt;&lt;&quot;&amp;&quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</div><div class="line">        cout&lt;&lt;f[head].first&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ssh -T git@github.com出现Permission denied (publickey)]]></title>
      <url>http://blog.acbingo.cn/2015/08/08/ssh%20-T%20git@github.com%E5%87%BA%E7%8E%B0Permission%20denied%20(publickey)/</url>
      <content type="html"><![CDATA[<p>参考自：<a href="http://blog.csdn.net/sunnypotter/article/details/18948053" target="_blank" rel="external">http://blog.csdn.net/sunnypotter/article/details/18948053</a></p>
<p>参考自：<a href="http://stackoverflow.com/questions/18293405/ssh-t-gitgithub-com-permission-denied-publickey" target="_blank" rel="external">http://stackoverflow.com/questions/18293405/ssh-t-gitgithub-com-permission-denied-publickey</a></p>
<p>升级win10后，重新安装git，在配置ssh到github的时候出现了该问题，google之，整理出解决方案如下</p>
<p>在生成ssh后在你的git工作根路径下问出现两个文件（“yourname”和“yourname.pub”）</p>
<p>将这两个文件复制到.ssh的文件夹下并改名为： id_rsa   和   id_rsa.pub</p>
<p>问题解决~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UVa10791-Minimum Sum LCM]]></title>
      <url>http://blog.acbingo.cn/2015/05/29/UVa10791-Minimum-Sum-LCM/</url>
      <content type="html"><![CDATA[<p>分析即为紫薯上的分析。<br>难点是发现当每个aipi作为一个单独的整数时才最优…<br>答案就是将所有不同的相同因子的积相加即可</p>
<a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;cstdio&gt;</span></div><div class="line"><span class="comment">#include&lt;cstring&gt;</span></div><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line"><span class="comment">#include&lt;algorithm&gt;</span></div><div class="line"><span class="comment">#include&lt;vector&gt;</span></div><div class="line"><span class="comment">#include&lt;stack&gt;</span></div><div class="line"><span class="comment">#include&lt;queue&gt;</span></div><div class="line"><span class="comment">#include&lt;map&gt;</span></div><div class="line"><span class="comment">#include&lt;set&gt;</span></div><div class="line"><span class="comment">#include&lt;list&gt;</span></div><div class="line"><span class="comment">#include&lt;string&gt;</span></div><div class="line"><span class="comment">#include&lt;cmath&gt;</span></div><div class="line"><span class="comment">#include&lt;sstream&gt;</span></div><div class="line"><span class="comment">#include&lt;ctime&gt;</span></div><div class="line"><span class="comment">#define _PI acos(-1.0)</span></div><div class="line"><span class="comment">#define INF 1 &lt;&lt; 10</span></div><div class="line"><span class="comment">#define esp 1e-6</span></div><div class="line">typedef long long LL;</div><div class="line">typedef unsigned long long ULL;</div><div class="line">using namespace std;</div><div class="line">/*===========================================</div><div class="line">===========================================*/</div><div class="line">LL v[1000];</div><div class="line">LL vt=0;</div><div class="line">int decPrime(LL n)&#123;</div><div class="line">    LL m=(LL)sqrt(n+0.5);</div><div class="line">    vt=0;</div><div class="line">    <span class="keyword">for</span> (LL i=2;i&lt;=m&amp;&amp;n&gt;1;i++)&#123;</div><div class="line">        <span class="keyword">if</span> (!(n%i))&#123;</div><div class="line">            LL tmp=1;</div><div class="line">            <span class="keyword">while</span> (!(n%i)&amp;&amp;n&gt;1)&#123;</div><div class="line">                tmp*=i;n/=i;</div><div class="line">            &#125;</div><div class="line">            v[vt++]=tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n&gt;1) v[vt++]=n;</div><div class="line">&#125;</div><div class="line">LL n;</div><div class="line">int T=0;</div><div class="line">int <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">    <span class="keyword">while</span> (cin&gt;&gt;n&amp;&amp;n)&#123;</div><div class="line">        T++;</div><div class="line">        LL ans=0;</div><div class="line">        decPrime(n);</div><div class="line">        <span class="keyword">if</span> (vt==0||vt==1) ans=n+1;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(int i=0; i&lt;vt; i++)</div><div class="line">                ans+=v[i];</div><div class="line">        cout&lt;&lt;<span class="string">"Case "</span>&lt;&lt;T&lt;&lt;<span class="string">": "</span>;</div><div class="line">        cout&lt;&lt;ans&lt;&lt;endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[uva100]]></title>
      <url>http://blog.acbingo.cn/2015/05/29/uva100/</url>
      <content type="html"><![CDATA[<p>#Test<br><img src="https://raw.github.com/ruchee/mysite/master/public/images/vim." alt="paopao" title="Vim Ruchee"></p>
]]></content>
    </entry>
    
  
  
</search>
